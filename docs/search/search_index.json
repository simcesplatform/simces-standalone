{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SimCES | Simulation Environment of Complex Energy System SimCES is a distributed simulation platform to enable the management of complex simulation scenarios. Features in short: Distribute your simulation to components Let the components communicate over Internet Run the components on any platform Create and manage simulation configurations in one file Simulate varying scenarios easily Retrieve simulation results from a logging interface Optionally, run components as containers for easier development Motivation Scientific simulation systems receive benefit from a support for distribution as well as the ease of operation and management, but this combination lacks from earlier systems. Imagine a system where you can distribute the simulation task to multiple components and software platforms over a network but still manage the simulation as if you had a single piece of software. A distributed setup enables you to exploit the functionality of various platforms and combine the work of multiple simulator system developers. Besides, even real-life systems are distributed, so distribution enables you to model the world as it actually is. This increases the credibility of simulation results. The earlier distributed simulation approaches are far from easy. Functional Mock-up Interface (FMI) is widely used but assumes you run all simulation components in one computer. Ad hoc networking has been applied, but this is laborious to deploy and maintain in large systems. Finally, the analysis of simulation results is the ultimate aim of the system. There should be a means to access all of the simulation results, including the intermediate calculations of the simulation components. SimCES fulfills these requirements. It does not develop any complex algorithms for you but provides a straightforward yet powerful concept for the management of simulation systems and the communication of simulation components, including the logging of simulation results. Source code SimCES is open source. Therefore, you can find the source code in Github: https://github.com/simcesplatform This website This website has the following main sections: User guide Developer guide Energy-domain-specific simulation components You can find these in the menu.","title":"Introduction"},{"location":"#simces-simulation-environment-of-complex-energy-system","text":"SimCES is a distributed simulation platform to enable the management of complex simulation scenarios. Features in short: Distribute your simulation to components Let the components communicate over Internet Run the components on any platform Create and manage simulation configurations in one file Simulate varying scenarios easily Retrieve simulation results from a logging interface Optionally, run components as containers for easier development","title":"SimCES | Simulation Environment of Complex Energy System"},{"location":"#motivation","text":"Scientific simulation systems receive benefit from a support for distribution as well as the ease of operation and management, but this combination lacks from earlier systems. Imagine a system where you can distribute the simulation task to multiple components and software platforms over a network but still manage the simulation as if you had a single piece of software. A distributed setup enables you to exploit the functionality of various platforms and combine the work of multiple simulator system developers. Besides, even real-life systems are distributed, so distribution enables you to model the world as it actually is. This increases the credibility of simulation results. The earlier distributed simulation approaches are far from easy. Functional Mock-up Interface (FMI) is widely used but assumes you run all simulation components in one computer. Ad hoc networking has been applied, but this is laborious to deploy and maintain in large systems. Finally, the analysis of simulation results is the ultimate aim of the system. There should be a means to access all of the simulation results, including the intermediate calculations of the simulation components. SimCES fulfills these requirements. It does not develop any complex algorithms for you but provides a straightforward yet powerful concept for the management of simulation systems and the communication of simulation components, including the logging of simulation results.","title":"Motivation"},{"location":"#source-code","text":"SimCES is open source. Therefore, you can find the source code in Github: https://github.com/simcesplatform","title":"Source code"},{"location":"#this-website","text":"This website has the following main sections: User guide Developer guide Energy-domain-specific simulation components You can find these in the menu.","title":"This website"},{"location":"about/","text":"About SimCES and this website SimCES | Simulation Environment of Complex Energy System Copyright \u00a9 2021 Tampere University and VTT Technical Research Centre of Finland The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [ RFC2119 ] [ RFC8174 ] when, and only when, they appear in all capitals, as shown here. Source code Get source code from GitHub: https://github.com/simcesplatform Contact If you have any questions or comments regarding SimCES or this website, please find a contact in the maintenance plan . Research projects SimCES and its parts have been developed in the following projects. ProCemPlus , \"Prosumer Centric Energy Communities \u2013 towards Energy Ecosystem\", 2019-2021, funded by Business Finland INTERRFACE , \"TSO-DSO-Consumer INTERFACE aRchitecture to provide innovative grid services for an efficient power system\", 2019-2022, funded by H2020 European Commission Publications Kannisto, P., Hylli, O., Heikkil\u00e4, V., Supponen, A., Aaltonen, T., Repo, S., Syst\u00e4, K., Keski-Koukkari, A., Safdarian, A. & Kulmala, A., \"Software and Communications Platform for Simulation Environment of Complex Energy System (SimCES)\", in 2021 IEEE Madrid PowerTech , 2021. DOI: 10.1109/PowerTech46648.2021.9495020 , available at http://kannisto.org/?page=pubs&item=kannisto_et_al2021simces Author contributions TAU = Tampere University, VTT = VTT Technical Research Centre of Finland Please note that most items have been contributed to by multiple persons. Person Components Packages Other Amir Safdarian (VTT) Price Forecaster Domain Messages, Domain Tools Anna Kulmala (VTT) Supervision Antti Keski-Koukkari (VTT) Resource Forecaster, Storage Domain Messages Antti Supponen (TAU) Grid, Procem-LFM Domain Messages Kalle Ruuth (TAU) Static Time Series Resource Domain Messages, Domain Tools Kari Syst\u00e4 (TAU) Architecture, supervision Matti Vilkko (TAU) Economic Dispatch Supervision Md Tanjimuddim (TAU) Controller Domain Messages Mehdi Attar (TAU) Distribution management system (DMS), Procem-LFM Domain Messages Olli Suominen (TAU) Economic Dispatch Domain Messages Otto Hylli (TAU) Log Reader, Log Writer, Platform Manager, Static time series resource, Storage Domain Messages, Domain Tools, Simulation Tools Petri Kannisto (TAU) Amqp Math Tool Integration Architecture, coordination, general documentation Sami Repo (TAU) Supervision Timo Aaltonen (TAU) Architecture Ville Heikkil\u00e4 (TAU) Controller, Log Reader, Log Writer, Platform Manager, Procem-LFM, Simple Component, Simulation Manager, Static time series resource Domain Messages, Domain Tools, Simulation Tools Usage and installation instructions Ville M\u00f6rsky (TAU) Economic Dispatch Domain Messages","title":"About..."},{"location":"about/#about-simces-and-this-website","text":"SimCES | Simulation Environment of Complex Energy System Copyright \u00a9 2021 Tampere University and VTT Technical Research Centre of Finland The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [ RFC2119 ] [ RFC8174 ] when, and only when, they appear in all capitals, as shown here.","title":"About SimCES and this website"},{"location":"about/#source-code","text":"Get source code from GitHub: https://github.com/simcesplatform","title":"Source code"},{"location":"about/#contact","text":"If you have any questions or comments regarding SimCES or this website, please find a contact in the maintenance plan .","title":"Contact"},{"location":"about/#research-projects","text":"SimCES and its parts have been developed in the following projects. ProCemPlus , \"Prosumer Centric Energy Communities \u2013 towards Energy Ecosystem\", 2019-2021, funded by Business Finland INTERRFACE , \"TSO-DSO-Consumer INTERFACE aRchitecture to provide innovative grid services for an efficient power system\", 2019-2022, funded by H2020 European Commission","title":"Research projects"},{"location":"about/#publications","text":"Kannisto, P., Hylli, O., Heikkil\u00e4, V., Supponen, A., Aaltonen, T., Repo, S., Syst\u00e4, K., Keski-Koukkari, A., Safdarian, A. & Kulmala, A., \"Software and Communications Platform for Simulation Environment of Complex Energy System (SimCES)\", in 2021 IEEE Madrid PowerTech , 2021. DOI: 10.1109/PowerTech46648.2021.9495020 , available at http://kannisto.org/?page=pubs&item=kannisto_et_al2021simces","title":"Publications"},{"location":"about/#author-contributions","text":"TAU = Tampere University, VTT = VTT Technical Research Centre of Finland Please note that most items have been contributed to by multiple persons. Person Components Packages Other Amir Safdarian (VTT) Price Forecaster Domain Messages, Domain Tools Anna Kulmala (VTT) Supervision Antti Keski-Koukkari (VTT) Resource Forecaster, Storage Domain Messages Antti Supponen (TAU) Grid, Procem-LFM Domain Messages Kalle Ruuth (TAU) Static Time Series Resource Domain Messages, Domain Tools Kari Syst\u00e4 (TAU) Architecture, supervision Matti Vilkko (TAU) Economic Dispatch Supervision Md Tanjimuddim (TAU) Controller Domain Messages Mehdi Attar (TAU) Distribution management system (DMS), Procem-LFM Domain Messages Olli Suominen (TAU) Economic Dispatch Domain Messages Otto Hylli (TAU) Log Reader, Log Writer, Platform Manager, Static time series resource, Storage Domain Messages, Domain Tools, Simulation Tools Petri Kannisto (TAU) Amqp Math Tool Integration Architecture, coordination, general documentation Sami Repo (TAU) Supervision Timo Aaltonen (TAU) Architecture Ville Heikkil\u00e4 (TAU) Controller, Log Reader, Log Writer, Platform Manager, Procem-LFM, Simple Component, Simulation Manager, Static time series resource Domain Messages, Domain Tools, Simulation Tools Usage and installation instructions Ville M\u00f6rsky (TAU) Economic Dispatch Domain Messages","title":"Author contributions"},{"location":"core_abstractsimulationcomponent/","text":"AbstractSimulationComponent AbstractSimulationComponent is a base class that contains the common functionality of simulation components. It is written in Python (3.7.9). The source code for the class can be found at: https://github.com/simcesplatform/simulation-tools/blob/master/tools/components.py New components can be developed by creating a child class from the AbstractSimulationComponent and providing an implementation for certain methods. A template for creating a child class, https://github.com/simcesplatform/simulation-tools/blob/master/examples/component_template.py , is available and other information regarding the creation of a new simulation component can be found at Creating new component . The workflow during the initialization process TODO The workflow when receiving a new message A diagram describing the workflow inside the component after receiving a new message from the message bus is given below. Each box represents a method in the class. Those methods that require an implementation in the child class are marked with red color in the diagram. These include: clear_epoch_variables this method should reset all the variables that are used to store epoch specific information general_message_handler any received message other than Epoch or SimState message should be handled here a call to start_epoch is required when a new valid input message has been received ready_for_new_epoch should return true when enough input messages have been received to be able to do something in the current epoch process_epoch this should include calls to any methods that handle sending the resulting messages to the message bus _send_result_message This method is included in the template as an example on how to send a message to the message bus. It should be replaced with the component specific implementation. More information about what these methods should do is included in the component template and in the general documentation about the simulation tools package: https://github.com/simcesplatform/simulation-tools/tree/master#general-instructions-for-creating-a-new-simulation-component .","title":"AbstractSimulationComponent"},{"location":"core_abstractsimulationcomponent/#abstractsimulationcomponent","text":"AbstractSimulationComponent is a base class that contains the common functionality of simulation components. It is written in Python (3.7.9). The source code for the class can be found at: https://github.com/simcesplatform/simulation-tools/blob/master/tools/components.py New components can be developed by creating a child class from the AbstractSimulationComponent and providing an implementation for certain methods. A template for creating a child class, https://github.com/simcesplatform/simulation-tools/blob/master/examples/component_template.py , is available and other information regarding the creation of a new simulation component can be found at Creating new component .","title":"AbstractSimulationComponent"},{"location":"core_abstractsimulationcomponent/#the-workflow-during-the-initialization-process","text":"TODO","title":"The workflow during the initialization process"},{"location":"core_abstractsimulationcomponent/#the-workflow-when-receiving-a-new-message","text":"A diagram describing the workflow inside the component after receiving a new message from the message bus is given below. Each box represents a method in the class. Those methods that require an implementation in the child class are marked with red color in the diagram. These include: clear_epoch_variables this method should reset all the variables that are used to store epoch specific information general_message_handler any received message other than Epoch or SimState message should be handled here a call to start_epoch is required when a new valid input message has been received ready_for_new_epoch should return true when enough input messages have been received to be able to do something in the current epoch process_epoch this should include calls to any methods that handle sending the resulting messages to the message bus _send_result_message This method is included in the template as an example on how to send a message to the message bus. It should be replaced with the component specific implementation. More information about what these methods should do is included in the component template and in the general documentation about the simulation tools package: https://github.com/simcesplatform/simulation-tools/tree/master#general-instructions-for-creating-a-new-simulation-component .","title":"The workflow when receiving a new message"},{"location":"core_amqp-footprint/","text":"Footprint of AMQP items This page estimates the resource consumption of the routing-related items in RabbitMQ. Connections and channels It is recommended to only have one connection per application and keep it alive. Channels should be re-used as well: The handshake process for an AMQP connection is quite involved and requires at least 7 TCP packets (more, if TLS is used). -- -- Don't open a channel each time you are publishing. The best practice is to reuse connections and multiplex a connection between threads with channels. You should ideally only have one connection per process, and then use a channel per thread in your application. [BestPrac1] Heartbeat For RabbitMQ, the default heartbeat value is 60 seconds [Heartbeat]. Still, the value could/should be shorter: Several years worth of feedback from the users and client library maintainers suggest that values lower than 5 seconds are fairly likely to cause false positives, and values of 1 second or lower are very likely to do so. Values within the 5 to 20 seconds range are optimal for most environments. [Heartbeat] Queues Queues must always accommodate at least the messages that have not yet been retrieved from the queue. This cannot be avoided. When no longer needed, it is easy to clean up a queue with the \"auto delete\" flag that leads to the queue being removed once no client uses it anymore. Furthermore, the \"exclusive\" flag will have this effect as well. These should always be enabled, unless the use case does not work with these flags. Exclusive: \"Exclusive queues may only be accessed by the current connection, and are deleted when that connection closes.\" [AmqpRef] Auto delete: \"If set, the queue is deleted when all consumers have finished using it.\" [AmqpRef] Exchanges Exchanges do consume some additional resources: Internal database (Mnesia) tables keep an in-memory copy of all its data (even on disc nodes). Typically this will only be large when there are a large number of queues, exchanges, bindings, users or virtual hosts. [Memory] On the other hand: In Erlang, which RabbitMQ is built on, each node (broker) is a process, as is each queue. -- -- However, an exchange is not a process for scalability reasons, it is simply a row in RabbitMQ\u2019s built-in Mnesia database. [Topol] The conclusion is that exchanges are not expected to take a remarkable share of memory. Therefore, it is assumed that a \"large\" number of exchanges does not cause issues in a server. However, unused exchanges should eventually be removed. References [AmqpRef] https://www.rabbitmq.com/amqp-0-9-1-reference.html [BestPrac1] https://www.cloudamqp.com/blog/2017-12-29-part1-rabbitmq-best-practice.html [Heartbeat] https://www.rabbitmq.com/heartbeats.html [Memory] https://www.rabbitmq.com/memory-use.html [Topol] https://spring.io/blog/2011/04/01/routing-topologies-for-performance-and-scalability-with-rabbitmq/","title":"Footprint of AMQP items"},{"location":"core_amqp-footprint/#footprint-of-amqp-items","text":"This page estimates the resource consumption of the routing-related items in RabbitMQ.","title":"Footprint of AMQP items"},{"location":"core_amqp-footprint/#connections-and-channels","text":"It is recommended to only have one connection per application and keep it alive. Channels should be re-used as well: The handshake process for an AMQP connection is quite involved and requires at least 7 TCP packets (more, if TLS is used). -- -- Don't open a channel each time you are publishing. The best practice is to reuse connections and multiplex a connection between threads with channels. You should ideally only have one connection per process, and then use a channel per thread in your application. [BestPrac1]","title":"Connections and channels"},{"location":"core_amqp-footprint/#heartbeat","text":"For RabbitMQ, the default heartbeat value is 60 seconds [Heartbeat]. Still, the value could/should be shorter: Several years worth of feedback from the users and client library maintainers suggest that values lower than 5 seconds are fairly likely to cause false positives, and values of 1 second or lower are very likely to do so. Values within the 5 to 20 seconds range are optimal for most environments. [Heartbeat]","title":"Heartbeat"},{"location":"core_amqp-footprint/#queues","text":"Queues must always accommodate at least the messages that have not yet been retrieved from the queue. This cannot be avoided. When no longer needed, it is easy to clean up a queue with the \"auto delete\" flag that leads to the queue being removed once no client uses it anymore. Furthermore, the \"exclusive\" flag will have this effect as well. These should always be enabled, unless the use case does not work with these flags. Exclusive: \"Exclusive queues may only be accessed by the current connection, and are deleted when that connection closes.\" [AmqpRef] Auto delete: \"If set, the queue is deleted when all consumers have finished using it.\" [AmqpRef]","title":"Queues"},{"location":"core_amqp-footprint/#exchanges","text":"Exchanges do consume some additional resources: Internal database (Mnesia) tables keep an in-memory copy of all its data (even on disc nodes). Typically this will only be large when there are a large number of queues, exchanges, bindings, users or virtual hosts. [Memory] On the other hand: In Erlang, which RabbitMQ is built on, each node (broker) is a process, as is each queue. -- -- However, an exchange is not a process for scalability reasons, it is simply a row in RabbitMQ\u2019s built-in Mnesia database. [Topol] The conclusion is that exchanges are not expected to take a remarkable share of memory. Therefore, it is assumed that a \"large\" number of exchanges does not cause issues in a server. However, unused exchanges should eventually be removed.","title":"Exchanges"},{"location":"core_amqp-footprint/#references","text":"[AmqpRef] https://www.rabbitmq.com/amqp-0-9-1-reference.html [BestPrac1] https://www.cloudamqp.com/blog/2017-12-29-part1-rabbitmq-best-practice.html [Heartbeat] https://www.rabbitmq.com/heartbeats.html [Memory] https://www.rabbitmq.com/memory-use.html [Topol] https://spring.io/blog/2011/04/01/routing-topologies-for-performance-and-scalability-with-rabbitmq/","title":"References"},{"location":"core_amqpmathtool/","text":"AmqpMathToolConnector This is a software package or API to connect the AMQP message bus to Matlab. The component was implemented in Java. For more information, see https://github.com/simcesplatform/AmqpMathToolIntegration .","title":"AmqpMathToolConnector"},{"location":"core_amqpmathtool/#amqpmathtoolconnector","text":"This is a software package or API to connect the AMQP message bus to Matlab. The component was implemented in Java. For more information, see https://github.com/simcesplatform/AmqpMathToolIntegration .","title":"AmqpMathToolConnector"},{"location":"core_block-quantity-array/","text":"Quantity array block Quantity array block is neither a topic nor message but a JSON block that can be included in any message. Use it whenever there is an array of measurement values or another quantities with an associated unit of measure. JSON structure { \"UnitOfMeasure\": \"kW\", \"Values\": [ \"0.1\", \"0.2\", \"0.3\", \"0.4\" ] } Fields and multiplicity Field Type Multiplicity Explanation UnitOfMeasure String 1 (REQUIRED) Unit of measure. This SHOULD follow the UCUM specification . Value Array of floats 1 (REQUIRED) The values. The array MUST exist, but the number of values is arbitrary.","title":"Block - Quantity array"},{"location":"core_block-quantity-array/#quantity-array-block","text":"Quantity array block is neither a topic nor message but a JSON block that can be included in any message. Use it whenever there is an array of measurement values or another quantities with an associated unit of measure.","title":"Quantity array block"},{"location":"core_block-quantity-array/#json-structure","text":"{ \"UnitOfMeasure\": \"kW\", \"Values\": [ \"0.1\", \"0.2\", \"0.3\", \"0.4\" ] }","title":"JSON structure"},{"location":"core_block-quantity-array/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation UnitOfMeasure String 1 (REQUIRED) Unit of measure. This SHOULD follow the UCUM specification . Value Array of floats 1 (REQUIRED) The values. The array MUST exist, but the number of values is arbitrary.","title":"Fields and multiplicity"},{"location":"core_block-quantity/","text":"Quantity block Quantity block is neither a topic nor message but a JSON block that can be included in any message. Use the quantity block whenever there is a measurement value or another quantity with an associated unit of measure. JSON structure { \"Value\": 12.3, \"UnitOfMeasure\": \"kW\" } Fields and multiplicity Field Type Multiplicity Explanation UnitOfMeasure String 1 (REQUIRED) Unit of measure. This SHOULD follow the UCUM specification . Value Float 1 (REQUIRED) Value","title":"Block - Quantity"},{"location":"core_block-quantity/#quantity-block","text":"Quantity block is neither a topic nor message but a JSON block that can be included in any message. Use the quantity block whenever there is a measurement value or another quantity with an associated unit of measure.","title":"Quantity block"},{"location":"core_block-quantity/#json-structure","text":"{ \"Value\": 12.3, \"UnitOfMeasure\": \"kW\" }","title":"JSON structure"},{"location":"core_block-quantity/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation UnitOfMeasure String 1 (REQUIRED) Unit of measure. This SHOULD follow the UCUM specification . Value Float 1 (REQUIRED) Value","title":"Fields and multiplicity"},{"location":"core_block-time-series/","text":"Time series block Time series block is neither a topic nor message but a JSON block that can be included in any message. JSON structure { \"TimeIndex\" : [ \"2020-02-17T10:00:00Z\", \"2020-02-17T11:00:00Z\", \"2020-02-17T12:00:00Z\" ], \"Series\" : { \"MagnitudeX\" : { \"UnitOfMeasure\" : \"cm\", \"Values\" : [ 1.4, 1.7, 1.6 ] }, \"MagnitudeY\" : { \"UnitOfMeasure\" : \"Cel\", \"Values\" : [ -4.2, -3.7, -3.1 ] } } } Fields and multiplicity Field Type Multiplicity Explanation TimeIndex Array of ISO 8601 date and time; UTC zone 1 (REQUIRED) The time of each value in the time series. These MUST be ordered from lowest to highest (i.e., ascending). Series Series block 1..* (REQUIRED, can be many) The actual time series Series block Field Type Multiplicity Explanation UnitOfMeasure String 1 (REQUIRED) Unit of measure. This SHOULD follow the UCUM specification . Values Array of basic type (JSON string, number or boolean); complex numbers not supported out of the box 1 (REQUIRED) Value for each time. The array length MUST be equal to the length of TimeIndex array.","title":"Block - Time series"},{"location":"core_block-time-series/#time-series-block","text":"Time series block is neither a topic nor message but a JSON block that can be included in any message.","title":"Time series block"},{"location":"core_block-time-series/#json-structure","text":"{ \"TimeIndex\" : [ \"2020-02-17T10:00:00Z\", \"2020-02-17T11:00:00Z\", \"2020-02-17T12:00:00Z\" ], \"Series\" : { \"MagnitudeX\" : { \"UnitOfMeasure\" : \"cm\", \"Values\" : [ 1.4, 1.7, 1.6 ] }, \"MagnitudeY\" : { \"UnitOfMeasure\" : \"Cel\", \"Values\" : [ -4.2, -3.7, -3.1 ] } } }","title":"JSON structure"},{"location":"core_block-time-series/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation TimeIndex Array of ISO 8601 date and time; UTC zone 1 (REQUIRED) The time of each value in the time series. These MUST be ordered from lowest to highest (i.e., ascending). Series Series block 1..* (REQUIRED, can be many) The actual time series","title":"Fields and multiplicity"},{"location":"core_block-time-series/#series-block","text":"Field Type Multiplicity Explanation UnitOfMeasure String 1 (REQUIRED) Unit of measure. This SHOULD follow the UCUM specification . Values Array of basic type (JSON string, number or boolean); complex numbers not supported out of the box 1 (REQUIRED) Value for each time. The array length MUST be equal to the length of TimeIndex array.","title":"Series block"},{"location":"core_cmp-mgmt/","text":"Platform managed and externally managed components The simulation platform exploits virtualization to facilitate the management of components, but this has limitations. In a simulation system, it is common to include components that do not calculate anything complex but implement a simple mathematical model. Some components are even mocks that supply pre-defined information, such as values from an earlier recorded or generated timeseries. Either way, computational power is not a particular requirement. Still, because the simulation platform is distributed and expects loose coupling, even simple components should have their own runtime and a service interface. To reduce the burden of this setup, virtualization with Docker provides a solution, because it enables the declaration of an autonomous computational unit with a few lines of code. Still, this does not suit for any resource-intensive computation, especially if the intention is to use a server cluster. To gain the advantages of virtualization but still enable an arbitrary runtime and resource-intensive calculation, the simulation platform supports two types of components: Platform managed components are executed in Docker in the same computer as the simulation platform. They are started for each simulation run and expected to stop execution when the simulation run ends. Externally managed components can be executed on any platform that can be either virtualized or not. The difference to platform managed is that the simulation platform does not control the startup and end of execution. Instead, the component must be running and connected to the message bus before any simulation can occur. The tradeoff between platform managed and externally managed is easier management versus flexibility in computational capacity.","title":"Platform managed and externally managed components"},{"location":"core_cmp-mgmt/#platform-managed-and-externally-managed-components","text":"The simulation platform exploits virtualization to facilitate the management of components, but this has limitations. In a simulation system, it is common to include components that do not calculate anything complex but implement a simple mathematical model. Some components are even mocks that supply pre-defined information, such as values from an earlier recorded or generated timeseries. Either way, computational power is not a particular requirement. Still, because the simulation platform is distributed and expects loose coupling, even simple components should have their own runtime and a service interface. To reduce the burden of this setup, virtualization with Docker provides a solution, because it enables the declaration of an autonomous computational unit with a few lines of code. Still, this does not suit for any resource-intensive computation, especially if the intention is to use a server cluster. To gain the advantages of virtualization but still enable an arbitrary runtime and resource-intensive calculation, the simulation platform supports two types of components: Platform managed components are executed in Docker in the same computer as the simulation platform. They are started for each simulation run and expected to stop execution when the simulation run ends. Externally managed components can be executed on any platform that can be either virtualized or not. The difference to platform managed is that the simulation platform does not control the startup and end of execution. Instead, the component must be running and connected to the message bus before any simulation can occur. The tradeoff between platform managed and externally managed is easier management versus flexibility in computational capacity.","title":"Platform managed and externally managed components"},{"location":"core_component-manifest/","text":"Creating a component manifest file Each component type should define a component manifest file that tells the platform what is the name of the component type, how the component is managed and information about the required and optional input attributes for the component type. The attribute definitions should match to the ones given in the process parameter block for the component in the Start message . Each component requires its own manifest file. A template for the component manifest file can be found at https://github.com/simcesplatform/platform-manager/blob/master/component_manifest.yml . The component manifest file is done in YAML format which can contain the following attributes: Name (required) The name for the component type. It must unique, i.e. two different component types cannot have the same name. Type (required) either \" platform \" for platform managed or \" external \" for externally managed component DockerImage (required for platform managed component, not needed for externally managed component) the Docker image name including the tag for a platform managed component Description (optional) description for the component not yet used anywhere in the current version Attributes (optional) key-value list of the registered attributes for the component each key should be the attribute name that is used in the Start message in the component's process parameter block each value should be an attribute block where each block can have the following attributes: Optional (optional) ( true/false ) If true , the attribute can be left out when defining a new simulation run. if false , a simulation cannot be started without giving a value for this attribute. By default the attribute is set as required, i.e. Optional is set to false . Default (optional) If the default value is set, it is used as the attribute value in cases where the attribute is not given a value in the simulation configuration. This settings is ignored for a required attribute, i.e. if Optional is false . Environment (optional, ignored with externally managed components) If this is given, the corresponding value is used as the environment variable name instead of the attribute name when passing the starting parameters to a platform managed component. IncludeInStart (optional) ( true/false ) Whether to include the attribute in the Start message. By default the attribute will be included in the Start message, i.e IncludeInStart is set to true . Any attribute that is not defined in the component manifest file but is given a value in the simulation configuration file for a new simulation will be included among the parameters in the Start message (and as environment variable for platform managed component). This allows extending the available starting parameters for a component without updating the manifest file but this feature should only be used during the development phase. No checking is done for any of the \"undocumented\" attributes. The default filename for the component manifest file is \" component_manifest.yml \" at the root folder of the code repository. It is recommended that this naming is used consistently with all components.","title":"Creating a component manifest file"},{"location":"core_component-manifest/#creating-a-component-manifest-file","text":"Each component type should define a component manifest file that tells the platform what is the name of the component type, how the component is managed and information about the required and optional input attributes for the component type. The attribute definitions should match to the ones given in the process parameter block for the component in the Start message . Each component requires its own manifest file. A template for the component manifest file can be found at https://github.com/simcesplatform/platform-manager/blob/master/component_manifest.yml . The component manifest file is done in YAML format which can contain the following attributes: Name (required) The name for the component type. It must unique, i.e. two different component types cannot have the same name. Type (required) either \" platform \" for platform managed or \" external \" for externally managed component DockerImage (required for platform managed component, not needed for externally managed component) the Docker image name including the tag for a platform managed component Description (optional) description for the component not yet used anywhere in the current version Attributes (optional) key-value list of the registered attributes for the component each key should be the attribute name that is used in the Start message in the component's process parameter block each value should be an attribute block where each block can have the following attributes: Optional (optional) ( true/false ) If true , the attribute can be left out when defining a new simulation run. if false , a simulation cannot be started without giving a value for this attribute. By default the attribute is set as required, i.e. Optional is set to false . Default (optional) If the default value is set, it is used as the attribute value in cases where the attribute is not given a value in the simulation configuration. This settings is ignored for a required attribute, i.e. if Optional is false . Environment (optional, ignored with externally managed components) If this is given, the corresponding value is used as the environment variable name instead of the attribute name when passing the starting parameters to a platform managed component. IncludeInStart (optional) ( true/false ) Whether to include the attribute in the Start message. By default the attribute will be included in the Start message, i.e IncludeInStart is set to true . Any attribute that is not defined in the component manifest file but is given a value in the simulation configuration file for a new simulation will be included among the parameters in the Start message (and as environment variable for platform managed component). This allows extending the available starting parameters for a component without updating the manifest file but this feature should only be used during the development phase. No checking is done for any of the \"undocumented\" attributes. The default filename for the component manifest file is \" component_manifest.yml \" at the root folder of the code repository. It is recommended that this naming is used consistently with all components.","title":"Creating a component manifest file"},{"location":"core_conv-msg/","text":"Conventions of messaging Please follow these conventions if you are either: specifying a new message structure developing an application that reads or creates messages MUST: Communication protocol To communicate, the components MUST use AMQP 0-9-1 as the protocol. To implement this protocol, the components MUST use RabbitMQ. MUST: AMQP exchange type To communicate, all components MUST use the exchange type \"topic\" in the message bus. MUST: Character encoding All messages MUST be encoded in UTF-8. This is widely supported and also a common default in many environments. The existing software tools of the platform expect UTF-8. If you use another encoding, you cause a risk of conflicts. MUST: Serialization in JSON All message structures are serialized in JSON (JavaScript Object Notation). JSON is widely supported and platform-independent as well as human and machine readable. The existing software tools of the platform expect JSON. MUST: Inherit from AbstractResult When you create a result message type, you MUST inherit it from AbstractResult . This ensures that the platform can deliver and log the message as expected. Please note that this only applies to full message structures. That is, any re-usable \"blocks\" that can be included in message types, such as Time series block , do not inherit from any base message type. SHOULD: Naming When creating new items, a question arises how to formulate names. See the page Conventions of naming . SHOULD: Re-use existing structures where possible The developer SHOULD avoid creating a new structure if there is a suitable existing structure. For example, if you want to include a timeseries in a message, use the Time series block . For existing structures, see the page Message structures the related pages under it. SHOULD: Time zone When a message carries a time value, the time zone SHOULD always be UTC (Universal Coordinated Time). This prevents any conflicts due to daylight savings, which has conventionally been a difficult issue in software. Furthermore, the simulation platform may be distributed to multiple time zones. Finally, as the times are displayed to human users, it is straightforward to convert a UTC value to local time if required. SHOULD: Date, time and duration format All date and time fields SHOULD follow the standard ISO 8601. This is both human and machine readable, and modern software tools have APIs to process ISO 8601. If absolutely necessary, it is straightforward to even implement a parser, especially as there is likely no requirement to support all the features. The same applies to duration values. SHOULD: Units of measure Certain values have an associated unit of measure. As these values are serialized as a message, the unit SHOULD be explicit and follow these rules: Unit of measure (UCUM) . SHOULD: Omitting optional fields If a field in a message structure is declared OPTIONAL, any software creating a message instance SHOULD omit the field when it has no relevant value. That is, the software SHOULD NOT assign null or an empty value instead. Motivation: The semantics of an \"optional\" field truly refers to the possibility of omitting the field. However, if the value is empty instead, this can cause a question of how to interpret the value. SHOULD: Flags of AMQP queues Each AMQP queue SHOULD use the following flags: Auto delete: true Exclusive: true Auto delete means that the queue is deleted when no longer used. This enables the message bus to automatically clean up unused resources. Exclusive means that no other client can use the queue. In the context of the simulation platform, shared queues are considered needless. The exclusive flag prevents any accidental queue sharing and supposedly leads to the queue being deleted when no longer used. SHOULD: Filter messages with topics Whenever a sequence of published messages contains messages that only a subset of clients want, you SHOULD route the messages with multiple topics to avoid the need to filter messages after reception. Message routing with the message bus is efficient, because this is exactly the use case. Filtering SHOULD NOT take place in recipients, because they would have to first receive each message and then inspect the content to determine whether it is relevant or not. For example, let us imagine that there is a topic called \"PowerConsumption\" that delivers power consumption values from buildings called House A, House B and House C. There is a recipient called Monitor X that only wants to monitor House A. For this, Monitor X must receive all messages and ignore those of House B and House C. Because this is inefficient, the \"PowerConsumption\" topic SHOULD be split to \"PowerConsumption.HouseA\", \"PowerConsumption.HouseB\" and \"PowerConsumption.HouseC\". This does not prevent a recipient from receiving all messages from the subtopics of \"PowerConsumption\", because wildcard subscriptions are possible. Even if it were unclear if subtopics are needed, it is generally a good principle to separate messages. This is because the re-arrangement of topics can be expensive, whereas it is cheap to originally add more topics.","title":"Conventions of messaging"},{"location":"core_conv-msg/#conventions-of-messaging","text":"Please follow these conventions if you are either: specifying a new message structure developing an application that reads or creates messages","title":"Conventions of messaging"},{"location":"core_conv-msg/#must-communication-protocol","text":"To communicate, the components MUST use AMQP 0-9-1 as the protocol. To implement this protocol, the components MUST use RabbitMQ.","title":"MUST: Communication protocol"},{"location":"core_conv-msg/#must-amqp-exchange-type","text":"To communicate, all components MUST use the exchange type \"topic\" in the message bus.","title":"MUST: AMQP exchange type"},{"location":"core_conv-msg/#must-character-encoding","text":"All messages MUST be encoded in UTF-8. This is widely supported and also a common default in many environments. The existing software tools of the platform expect UTF-8. If you use another encoding, you cause a risk of conflicts.","title":"MUST: Character encoding"},{"location":"core_conv-msg/#must-serialization-in-json","text":"All message structures are serialized in JSON (JavaScript Object Notation). JSON is widely supported and platform-independent as well as human and machine readable. The existing software tools of the platform expect JSON.","title":"MUST: Serialization in JSON"},{"location":"core_conv-msg/#must-inherit-from-abstractresult","text":"When you create a result message type, you MUST inherit it from AbstractResult . This ensures that the platform can deliver and log the message as expected. Please note that this only applies to full message structures. That is, any re-usable \"blocks\" that can be included in message types, such as Time series block , do not inherit from any base message type.","title":"MUST: Inherit from AbstractResult"},{"location":"core_conv-msg/#should-naming","text":"When creating new items, a question arises how to formulate names. See the page Conventions of naming .","title":"SHOULD: Naming"},{"location":"core_conv-msg/#should-re-use-existing-structures-where-possible","text":"The developer SHOULD avoid creating a new structure if there is a suitable existing structure. For example, if you want to include a timeseries in a message, use the Time series block . For existing structures, see the page Message structures the related pages under it.","title":"SHOULD: Re-use existing structures where possible"},{"location":"core_conv-msg/#should-time-zone","text":"When a message carries a time value, the time zone SHOULD always be UTC (Universal Coordinated Time). This prevents any conflicts due to daylight savings, which has conventionally been a difficult issue in software. Furthermore, the simulation platform may be distributed to multiple time zones. Finally, as the times are displayed to human users, it is straightforward to convert a UTC value to local time if required.","title":"SHOULD: Time zone"},{"location":"core_conv-msg/#should-date-time-and-duration-format","text":"All date and time fields SHOULD follow the standard ISO 8601. This is both human and machine readable, and modern software tools have APIs to process ISO 8601. If absolutely necessary, it is straightforward to even implement a parser, especially as there is likely no requirement to support all the features. The same applies to duration values.","title":"SHOULD: Date, time and duration format"},{"location":"core_conv-msg/#should-units-of-measure","text":"Certain values have an associated unit of measure. As these values are serialized as a message, the unit SHOULD be explicit and follow these rules: Unit of measure (UCUM) .","title":"SHOULD: Units of measure"},{"location":"core_conv-msg/#should-omitting-optional-fields","text":"If a field in a message structure is declared OPTIONAL, any software creating a message instance SHOULD omit the field when it has no relevant value. That is, the software SHOULD NOT assign null or an empty value instead. Motivation: The semantics of an \"optional\" field truly refers to the possibility of omitting the field. However, if the value is empty instead, this can cause a question of how to interpret the value.","title":"SHOULD: Omitting optional fields"},{"location":"core_conv-msg/#should-flags-of-amqp-queues","text":"Each AMQP queue SHOULD use the following flags: Auto delete: true Exclusive: true Auto delete means that the queue is deleted when no longer used. This enables the message bus to automatically clean up unused resources. Exclusive means that no other client can use the queue. In the context of the simulation platform, shared queues are considered needless. The exclusive flag prevents any accidental queue sharing and supposedly leads to the queue being deleted when no longer used.","title":"SHOULD: Flags of AMQP queues"},{"location":"core_conv-msg/#should-filter-messages-with-topics","text":"Whenever a sequence of published messages contains messages that only a subset of clients want, you SHOULD route the messages with multiple topics to avoid the need to filter messages after reception. Message routing with the message bus is efficient, because this is exactly the use case. Filtering SHOULD NOT take place in recipients, because they would have to first receive each message and then inspect the content to determine whether it is relevant or not. For example, let us imagine that there is a topic called \"PowerConsumption\" that delivers power consumption values from buildings called House A, House B and House C. There is a recipient called Monitor X that only wants to monitor House A. For this, Monitor X must receive all messages and ignore those of House B and House C. Because this is inefficient, the \"PowerConsumption\" topic SHOULD be split to \"PowerConsumption.HouseA\", \"PowerConsumption.HouseB\" and \"PowerConsumption.HouseC\". This does not prevent a recipient from receiving all messages from the subtopics of \"PowerConsumption\", because wildcard subscriptions are possible. Even if it were unclear if subtopics are needed, it is generally a good principle to separate messages. This is because the re-arrangement of topics can be expensive, whereas it is cheap to originally add more topics.","title":"SHOULD: Filter messages with topics"},{"location":"core_conv-name/","text":"Conventions of naming It helps development if the various communication-related items have been named consistently. Then, the developers encounter fewer surprises, which often lead to bugs. The following sections specify the naming conventions of various items. Cases These are the cases referred to on this page: (a) Kebab case E.g., \"kebab-case\" All letters are in lowercase Hyphen between each word No spaces or underscores (b) Pascal case: camel case with capital first letter E.g. \"PascalCase\" Each word starts with a capital letter Other letters are in lowercase No spaces, underscores or hyphens between words See https://techterms.com/definition/pascalcase All items This includes message names, field names, etc. You SHOULD avoid the use of abbreviations For example, say \"Voltage\" rather than \"V\". Exchanges (in AMQP) Case: Kebab case If the name is hierarchical or otherwise contains logical parts, you CAN use periods ('.') as the separator. You SHOULD only use alphanumeric characters and the separators (hyphen and period, i.e., '-' and '.'). Examples: procem-management procem.whatever-id-1234 Topics (in AMQP) Case: Pascal case You SHOULD use periods to separate the levels of a hierarchy or other logical sections, because this enables wildcards to match a section. All words SHOULD be in singular. Any topic that has the purpose \"initialization\" SHOULD start with string \"Init.\". Any other topic SHOULD NOT start with \"Init.\". (For more information about initialization, see Workflow of component in simulation .) Any topic meant for the intermediate results of iteration MUST end with \".Iter\" added to the topic name that delivers the final result of iteration. Any other topic SHOULD NOT end with \".Iter\". (For more information about iteration, see Workflow of component in simulation .) Examples: ResourceState.Generator.Generator1 Init.NIS.NetworkComponentInfo MyTopic.ResourceX MyTopic.ResourceX.Iter Queues (in AMQP) You SHOULD use randomly generated names to avoid naming conflicts between software applications. When the queues are exclusive to applications, there is no reason to use an explicit name. Commonly, the APIs generate a random name if no name is supplied. Field names in message Case: Pascal case You SHOULD use singular if there is one item in the field. If the field contains an array, you SHOULD use plural. Examples: LastUpdatedInEpoch SourceProcessId Message type Case: Pascal case All words SHOULD be in singular. Examples: PriceForecastState ResourceState Enumeration values Case: Kebab case If hierarchical, you SHOULD use periods ('.') as the separator. You SHOULD only use alphanumeric characters and the separators (hyphen and period, i.e., '-' and '.'). Still, numbers SHOULD be used only if absolutely necessary. Examples: warning.convergence warning.input.range ready my-multiword-enum-value my-multiword-enum-value.sub-item","title":"Conventions of naming"},{"location":"core_conv-name/#conventions-of-naming","text":"It helps development if the various communication-related items have been named consistently. Then, the developers encounter fewer surprises, which often lead to bugs. The following sections specify the naming conventions of various items.","title":"Conventions of naming"},{"location":"core_conv-name/#cases","text":"These are the cases referred to on this page: (a) Kebab case E.g., \"kebab-case\" All letters are in lowercase Hyphen between each word No spaces or underscores (b) Pascal case: camel case with capital first letter E.g. \"PascalCase\" Each word starts with a capital letter Other letters are in lowercase No spaces, underscores or hyphens between words See https://techterms.com/definition/pascalcase","title":"Cases"},{"location":"core_conv-name/#all-items","text":"This includes message names, field names, etc. You SHOULD avoid the use of abbreviations For example, say \"Voltage\" rather than \"V\".","title":"All items"},{"location":"core_conv-name/#exchanges-in-amqp","text":"Case: Kebab case If the name is hierarchical or otherwise contains logical parts, you CAN use periods ('.') as the separator. You SHOULD only use alphanumeric characters and the separators (hyphen and period, i.e., '-' and '.'). Examples: procem-management procem.whatever-id-1234","title":"Exchanges (in AMQP)"},{"location":"core_conv-name/#topics-in-amqp","text":"Case: Pascal case You SHOULD use periods to separate the levels of a hierarchy or other logical sections, because this enables wildcards to match a section. All words SHOULD be in singular. Any topic that has the purpose \"initialization\" SHOULD start with string \"Init.\". Any other topic SHOULD NOT start with \"Init.\". (For more information about initialization, see Workflow of component in simulation .) Any topic meant for the intermediate results of iteration MUST end with \".Iter\" added to the topic name that delivers the final result of iteration. Any other topic SHOULD NOT end with \".Iter\". (For more information about iteration, see Workflow of component in simulation .) Examples: ResourceState.Generator.Generator1 Init.NIS.NetworkComponentInfo MyTopic.ResourceX MyTopic.ResourceX.Iter","title":"Topics (in AMQP)"},{"location":"core_conv-name/#queues-in-amqp","text":"You SHOULD use randomly generated names to avoid naming conflicts between software applications. When the queues are exclusive to applications, there is no reason to use an explicit name. Commonly, the APIs generate a random name if no name is supplied.","title":"Queues (in AMQP)"},{"location":"core_conv-name/#field-names-in-message","text":"Case: Pascal case You SHOULD use singular if there is one item in the field. If the field contains an array, you SHOULD use plural. Examples: LastUpdatedInEpoch SourceProcessId","title":"Field names in message"},{"location":"core_conv-name/#message-type","text":"Case: Pascal case All words SHOULD be in singular. Examples: PriceForecastState ResourceState","title":"Message type"},{"location":"core_conv-name/#enumeration-values","text":"Case: Kebab case If hierarchical, you SHOULD use periods ('.') as the separator. You SHOULD only use alphanumeric characters and the separators (hyphen and period, i.e., '-' and '.'). Still, numbers SHOULD be used only if absolutely necessary. Examples: warning.convergence warning.input.range ready my-multiword-enum-value my-multiword-enum-value.sub-item","title":"Enumeration values"},{"location":"core_create-cmp/","text":"Creating new component Follow these step to create a new component that participates in simulation in the platform. Make sure you understand the basic concepts of the platform (see Basic concepts at Manual for developer ) Outputs : Decide what information the component should generate as result messages Inputs : Resolve what information the component needs as the input to generate the result messages This information comes from other components This is optional, because not all components need input Topics : Specify the topics the component uses to communicate This is based on \"outputs\" and \"inputs\" Re-use existing topics if and only if appropriate Specify new topics as needed See Conventions of naming Make sure the names do not conflict with existing topic names (see Topics (core) and Topics (energy) ) Messages : Determine which data is communicated with \"topics\" This is based on \"outputs\" and \"inputs\" Re-use existing message structures if possible See Message structures (core) and the existing messages at Message type names (core) and Message type names (energy) Specify new message structures as needed See Conventions of messaging Choose whether to manage the execution by the platform or externally See Platform managed and externally managed components Develop the component Follow the workflow in pages Workflow of start and end and Workflow of component in simulation When developing a component using Python, it is advisable to to use the Simulation Tools package . For details about developing a new component using the package, see the instructions and the template file for a new component. An example of a platform managed component, called SimpleComponent, has been made by using the Simulation Tools package and the available documentation. The repository, https://github.com/simcesplatform/simple-component , contains documentation about the development steps taken during the development of the example component. During the component development, things that might have to considered: Environment: Determine what variable information the component must know about the environment (if anything) Parameters: Determine what parametrizable properties the component has (if any) Create a component manifest file using the instructions on page Creating a component manifest file . For platform managed component, build and publish a Docker image for the component. See page Building Docker image for a component for instructions on how to accomplish that. Update the documentation Document the communication and the workflow of the component. See the page for Static time series resource for an example. Document any new message types that are used by the component. See the page for Epoch message for an example. Document the topics used by the component and them to the list topics, for example to Topics (energy) . Document a new Start message block for the component. See Dummy Component block for an example. For externally managed component, provide full installation instructions for the component.","title":"Overview"},{"location":"core_create-cmp/#creating-new-component","text":"Follow these step to create a new component that participates in simulation in the platform. Make sure you understand the basic concepts of the platform (see Basic concepts at Manual for developer ) Outputs : Decide what information the component should generate as result messages Inputs : Resolve what information the component needs as the input to generate the result messages This information comes from other components This is optional, because not all components need input Topics : Specify the topics the component uses to communicate This is based on \"outputs\" and \"inputs\" Re-use existing topics if and only if appropriate Specify new topics as needed See Conventions of naming Make sure the names do not conflict with existing topic names (see Topics (core) and Topics (energy) ) Messages : Determine which data is communicated with \"topics\" This is based on \"outputs\" and \"inputs\" Re-use existing message structures if possible See Message structures (core) and the existing messages at Message type names (core) and Message type names (energy) Specify new message structures as needed See Conventions of messaging Choose whether to manage the execution by the platform or externally See Platform managed and externally managed components Develop the component Follow the workflow in pages Workflow of start and end and Workflow of component in simulation When developing a component using Python, it is advisable to to use the Simulation Tools package . For details about developing a new component using the package, see the instructions and the template file for a new component. An example of a platform managed component, called SimpleComponent, has been made by using the Simulation Tools package and the available documentation. The repository, https://github.com/simcesplatform/simple-component , contains documentation about the development steps taken during the development of the example component. During the component development, things that might have to considered: Environment: Determine what variable information the component must know about the environment (if anything) Parameters: Determine what parametrizable properties the component has (if any) Create a component manifest file using the instructions on page Creating a component manifest file . For platform managed component, build and publish a Docker image for the component. See page Building Docker image for a component for instructions on how to accomplish that. Update the documentation Document the communication and the workflow of the component. See the page for Static time series resource for an example. Document any new message types that are used by the component. See the page for Epoch message for an example. Document the topics used by the component and them to the list topics, for example to Topics (energy) . Document a new Start message block for the component. See Dummy Component block for an example. For externally managed component, provide full installation instructions for the component.","title":"Creating new component"},{"location":"core_develop-overview/","text":"Overview for developer Basic concepts Time and synchronization with epochs Platform managed and externally managed components Service-oriented architecture How to develop Creating new component Building Docker image for a component Creating a component manifest file Conventions of messaging Conventions of naming Pseudocode reference Simulation Tools package AbstractSimulationComponent Workflow of component in simulation Workflow of start and end Communication Topics, queues and exchanges Exchange, management Exchange, simulation-specific Topics (core) Reliable messaging in RabbitMQ Footprint of AMQP items Message structures (core) Message structures (core) Message type names (core) Units of measure (UCUM) Message - AbstractMessage Message - AbstractResult Message - Epoch Message - SimState Message - Start Message - Status Block - Quantity Block - Quantity array Block - Time series Platforms internals Logging system LogWriter Platform Manager Simulation lifecycle Simulation Manager Dummy Component AmqpMathToolConnector","title":"Overview"},{"location":"core_develop-overview/#overview-for-developer","text":"","title":"Overview for developer"},{"location":"core_develop-overview/#basic-concepts","text":"Time and synchronization with epochs Platform managed and externally managed components Service-oriented architecture","title":"Basic concepts"},{"location":"core_develop-overview/#how-to-develop","text":"Creating new component Building Docker image for a component Creating a component manifest file Conventions of messaging Conventions of naming Pseudocode reference Simulation Tools package AbstractSimulationComponent Workflow of component in simulation Workflow of start and end","title":"How to develop"},{"location":"core_develop-overview/#communication","text":"Topics, queues and exchanges Exchange, management Exchange, simulation-specific Topics (core) Reliable messaging in RabbitMQ Footprint of AMQP items","title":"Communication"},{"location":"core_develop-overview/#message-structures-core","text":"Message structures (core) Message type names (core) Units of measure (UCUM) Message - AbstractMessage Message - AbstractResult Message - Epoch Message - SimState Message - Start Message - Status Block - Quantity Block - Quantity array Block - Time series","title":"Message structures (core)"},{"location":"core_develop-overview/#platforms-internals","text":"Logging system LogWriter Platform Manager Simulation lifecycle Simulation Manager Dummy Component AmqpMathToolConnector","title":"Platforms internals"},{"location":"core_docker-image/","text":"Building Docker image for a component A component that is platform managed should have a Docker image that can be used by the platform to include in it in simulation runs. Building a Docker image requires a Dockerfile that contains the machine instructions on how to start the component. For a component developed in Python the template file Dockerfile-template can be used as a starting point. It is based on the Dockerfile for the Static Time Series Resource component. The template file contains comment lines that should help creating a Dockerfile for a new component. The new Dockerfile should be placed at the root folder of the component source code. The recommended name for the file is \" Dockerfile \". For the SimCES platform components, the GitHub Container registry can be used to store the Docker images at the same place as the source code. See section Using GitHub Container registry for instructions on how to use it. Other Docker registries including Docker Hub and private registries can be used as well but no specific instructions for them are given. The basic workflow is as follows: Use the docker login command to gain access to the Docker registry (only required for the first access). See section Login to the container registry for details. Create the Dockerfile for the component using the template file as a starting point. Use the docker build command to build the Docker image. See section Building Docker image for details. Use the docker push command to push the created image to the registry. See section Pushing image to container registry for details. (Optional) Make the image publicly available so that users can use the image without access credentials Note, that the tag part in the Docker image name is used to differentiate between the different versions among the Docker images of the same name. To use the version 0.5 for a Docker image for a component called my_component , use the image name: ghcr.io/simcesplatform/my_component:0.5 Using a Docker image name without the tag actually means that the default tag, latest , is used. I.e., in terms of Docker image names, ghcr.io/simcesplatform/my_component is the same as ghcr.io/simcesplatform/my_component:latest Using GitHub Container registry When using the GitHub Container registry, the Docker image names for images linked to the SimCES platform will start with \" ghcr.io/simcesplatform \". For example, the image name for component called my_component could be \" ghcr.io/simcesplatform/my_component:latest \". All of the following assumes that the user has a GitHub account and the required privileges in the simcesplatform GitHub organization. Login to the container registry To be able to push Docker images to the container registry it is first required that the user logins to the registry. This is usually only required once for each user for each environment. Steps required to login to the container registry: Create a new personal access token (PAT) for your GitHub account by following instructions on page: https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token (steps 1-9) In the scope selection (step 8), at least \" write:packages \" must be selected to be able use the PAT to push images to the registry. The newly created PAT must be stored somewhere private. It cannot be viewed after the creation. Login to the Container registry Use command: docker login ghcr.io For username, use your GitHub account username For password, use the PAT you just created If the login was successful, you should see: \" Login Succeeded \" Building Docker image To build a Docker image for the component from the source code using a name \" ghcr.io/simcesplatform/my_component:latest \" do the following: Run the following from the folder containing the Dockerfile : docker build --tag ghcr.io/simcesplatform/my_component:latest . If the used Dockerfile is name Dockerfile-my-component instead of Dockerfile , the following can be used: docker build --tag ghcr.io/simcesplatform/my_component:latest --file Dockerfile-my-component . Note, that the Docker image name must match to the image name that was used in the component manifest file for the component. Pushing image to container registry The following uses a Docker image ghcr.io/simcesplatform/my_component:latest as an example and assumes that the image in question has been already built and that the login to the container registry has been done. To push the image to GitHub Container registry: docker push ghcr.io/simcesplatform/my_component:latest Optional steps to make the new Docker image publicly available without credentials to the container registry: Check that the pushed image appears in the package list of the simcesplatform organization: https://github.com/orgs/simcesplatform/packages Go to the image page by clicking the image name (the url should be: https://github.com/orgs/simcesplatform/packages/container/package/my_component ) Go to the image settings page by clicking \" Package settings \" on the right-hand side of the image page (the url should be: https://github.com/orgs/simcesplatform/packages/container/my_component/settings ) Change the image visibility to \" Public \" using the \" Change visibility \" option in the image settings page. (Optional) link the image to a repository From the image page, click \" Connect repository \" button and choose the repository you want to connect the image to. Afterwards, the image will be shown on the repository page as one the packages connected to the repository.","title":"Building Docker image for a component"},{"location":"core_docker-image/#building-docker-image-for-a-component","text":"A component that is platform managed should have a Docker image that can be used by the platform to include in it in simulation runs. Building a Docker image requires a Dockerfile that contains the machine instructions on how to start the component. For a component developed in Python the template file Dockerfile-template can be used as a starting point. It is based on the Dockerfile for the Static Time Series Resource component. The template file contains comment lines that should help creating a Dockerfile for a new component. The new Dockerfile should be placed at the root folder of the component source code. The recommended name for the file is \" Dockerfile \". For the SimCES platform components, the GitHub Container registry can be used to store the Docker images at the same place as the source code. See section Using GitHub Container registry for instructions on how to use it. Other Docker registries including Docker Hub and private registries can be used as well but no specific instructions for them are given. The basic workflow is as follows: Use the docker login command to gain access to the Docker registry (only required for the first access). See section Login to the container registry for details. Create the Dockerfile for the component using the template file as a starting point. Use the docker build command to build the Docker image. See section Building Docker image for details. Use the docker push command to push the created image to the registry. See section Pushing image to container registry for details. (Optional) Make the image publicly available so that users can use the image without access credentials Note, that the tag part in the Docker image name is used to differentiate between the different versions among the Docker images of the same name. To use the version 0.5 for a Docker image for a component called my_component , use the image name: ghcr.io/simcesplatform/my_component:0.5 Using a Docker image name without the tag actually means that the default tag, latest , is used. I.e., in terms of Docker image names, ghcr.io/simcesplatform/my_component is the same as ghcr.io/simcesplatform/my_component:latest","title":"Building Docker image for a component"},{"location":"core_docker-image/#using-github-container-registry","text":"When using the GitHub Container registry, the Docker image names for images linked to the SimCES platform will start with \" ghcr.io/simcesplatform \". For example, the image name for component called my_component could be \" ghcr.io/simcesplatform/my_component:latest \". All of the following assumes that the user has a GitHub account and the required privileges in the simcesplatform GitHub organization.","title":"Using GitHub Container registry"},{"location":"core_docker-image/#login-to-the-container-registry","text":"To be able to push Docker images to the container registry it is first required that the user logins to the registry. This is usually only required once for each user for each environment. Steps required to login to the container registry: Create a new personal access token (PAT) for your GitHub account by following instructions on page: https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token (steps 1-9) In the scope selection (step 8), at least \" write:packages \" must be selected to be able use the PAT to push images to the registry. The newly created PAT must be stored somewhere private. It cannot be viewed after the creation. Login to the Container registry Use command: docker login ghcr.io For username, use your GitHub account username For password, use the PAT you just created If the login was successful, you should see: \" Login Succeeded \"","title":"Login to the container registry"},{"location":"core_docker-image/#building-docker-image","text":"To build a Docker image for the component from the source code using a name \" ghcr.io/simcesplatform/my_component:latest \" do the following: Run the following from the folder containing the Dockerfile : docker build --tag ghcr.io/simcesplatform/my_component:latest . If the used Dockerfile is name Dockerfile-my-component instead of Dockerfile , the following can be used: docker build --tag ghcr.io/simcesplatform/my_component:latest --file Dockerfile-my-component . Note, that the Docker image name must match to the image name that was used in the component manifest file for the component.","title":"Building Docker image"},{"location":"core_docker-image/#pushing-image-to-container-registry","text":"The following uses a Docker image ghcr.io/simcesplatform/my_component:latest as an example and assumes that the image in question has been already built and that the login to the container registry has been done. To push the image to GitHub Container registry: docker push ghcr.io/simcesplatform/my_component:latest Optional steps to make the new Docker image publicly available without credentials to the container registry: Check that the pushed image appears in the package list of the simcesplatform organization: https://github.com/orgs/simcesplatform/packages Go to the image page by clicking the image name (the url should be: https://github.com/orgs/simcesplatform/packages/container/package/my_component ) Go to the image settings page by clicking \" Package settings \" on the right-hand side of the image page (the url should be: https://github.com/orgs/simcesplatform/packages/container/my_component/settings ) Change the image visibility to \" Public \" using the \" Change visibility \" option in the image settings page. (Optional) link the image to a repository From the image page, click \" Connect repository \" button and choose the repository you want to connect the image to. Afterwards, the image will be shown on the repository page as one the packages connected to the repository.","title":"Pushing image to container registry"},{"location":"core_dummycomponent/","text":"Dummy Component TODO","title":"Dummy Component"},{"location":"core_dummycomponent/#dummy-component","text":"TODO","title":"Dummy Component"},{"location":"core_exchange-mgmt/","text":"Management Exchange Management Exchange enables a communication channel that is available even when no simulation is running. To use the Exchange, the following information MUST match between all software applications. Otherwise, one or more applications will fail to use the exchange. Item Value Comment Type topic Necessary for topic-based communication Name procem-management Predefined name, so that any client can use the exchange Durable true The exchange will survive broker restart. This enables any clients to reconnect as soon as possible without a requirement to re-create the exchange. Auto delete false The exchange will remain even if no client used it, as the management exchange should always be available regardless if a simulation is running or not. Please note that this value is independent of the \"auto delete\" flag of message queues!","title":"Exchange, management"},{"location":"core_exchange-mgmt/#management-exchange","text":"Management Exchange enables a communication channel that is available even when no simulation is running. To use the Exchange, the following information MUST match between all software applications. Otherwise, one or more applications will fail to use the exchange. Item Value Comment Type topic Necessary for topic-based communication Name procem-management Predefined name, so that any client can use the exchange Durable true The exchange will survive broker restart. This enables any clients to reconnect as soon as possible without a requirement to re-create the exchange. Auto delete false The exchange will remain even if no client used it, as the management exchange should always be available regardless if a simulation is running or not. Please note that this value is independent of the \"auto delete\" flag of message queues!","title":"Management Exchange"},{"location":"core_exchange-sim/","text":"Simulation-specific exchanges Item Value Comment Type topic Necessary for topic-based communication Name procem.[unique-id-derived-from-simulation-id] The exchange name is decided by Platform Manager at simulation startup. Durable false The exchange would disappear in a broker restart. The intention is that the simulation should not continue if the broker restarts. Instead, there should be another simulation run. Auto delete true The exchange will be deleted when no longer in use (i.e., after the simulation run). This enables an automatic cleanup of unused resources. Please note that this value is independent of the \"auto delete\" flag of message queues!","title":"Exchange, simulation-specific"},{"location":"core_exchange-sim/#simulation-specific-exchanges","text":"Item Value Comment Type topic Necessary for topic-based communication Name procem.[unique-id-derived-from-simulation-id] The exchange name is decided by Platform Manager at simulation startup. Durable false The exchange would disappear in a broker restart. The intention is that the simulation should not continue if the broker restarts. Instead, there should be another simulation run. Auto delete true The exchange will be deleted when no longer in use (i.e., after the simulation run). This enables an automatic cleanup of unused resources. Please note that this value is independent of the \"auto delete\" flag of message queues!","title":"Simulation-specific exchanges"},{"location":"core_features/","text":"Features Loose coupling of components It is easier to manage a complex simulation system if the components only have the dependencies necessary for communication. The platform uses publish-subscribe communication, which decouples systems in \"time, space and synchronisation\" [1]. This means that the components do not interact directly but only via a communication platform. As the result, it is easier to develop and re-configure the setup as needed. Run simulation with single command Once the environment has been set up, it is started with a single command. The platform takes care of starting and stopping the components. Analysis of results The platform provides a logging system that captures all messages sent from a component. After the simulation, you can explore the messages either one by one or by generating time series from individual messages. Add your own components In the platform, the simulation components have a workflow they must implement. To develop your own component, the sole requirement is to implement the required communication interface and follow the workflow. Parametrize your components The platform provides a mechanism to deliver parameters to the components. You specify by yourself what the parameters are and what values these can have. For example, if your system has a storage of electricity or liquid with size as a property, you can simulate how the size affects the overall system. Geographical distribution If needed, you can distribute the simulations geographically. You can connect a simulation component from anywhere in the world via Internet. This enables a joint effort together with project partners as well as the application of a server cluster located in other premises. Principles of messaging The communication in based on a message bus. This is defined as follows: A Message Bus is a combination of a common data model, a common command set, and a messaging infrastructure to allow different systems to communicate through a shared set of interfaces. [2] As the message bus is in place, the components do not interact directly. Instead, when a component has something to say, it publishes a message. Because the bus uses the publish-subscribe paradigm, any other simulation component can subscribe for the messages to receive them. This is implemented with topics . A topic is an arbitrary string that identifies a subject of interest. The string can be, e.g., \"MyRoom.MySensorA.Temperature\" or \"WeatherInfo.CityX\". The topic-based approach realizes loose coupling, because the components do not directly connect to each other. Time and synchronization The simulator components are distributed but should still operate together, which necessitates a mechanism to synchronize time. This is implemented with epochs . An epoch represents a period of simulated time, e.g., today between 12:00 and 12:15 p.m. The length of epoch can be varied depending on the desired resolution of simulation. As epochs always represent simulated time, the duration is different in real time. This depends mainly on how fast the slowest component can simulate. Managing components in platform or externally The simulation platform exploits virtualization to facilitate the management of components, but this has limitations. Virtualization is suitable for lightweight components that do not require particularly lot of computational power. On the other hand, sometimes a more powerful platform - possibly even a server cluster - is necessary. To enable both easy management and heavy computation, the platform supports two types of components: platform managed and externally managed . Accessing the results During a simulation run, the logging system of the platform stores any messages exchanged between the simulation components. The logging system provides an HTTP API to access the messages. (In technical terms, this API is Restful, although not all HTTP-based technologies are.) Features: View the results with any HTTP client, including a web browser or a custom client View individual messages Build timeseries from multiple messages of the same structure Retrieve data in: JSON (JavaScript Object Notation) CSV (Comma-separated Values; only for timeseries) References [1] Patrick Th. Eugster, Pascal A. Felber, Rachid Guerraoui, and Anne-Marie Kermarrec. 2003. The many faces of publish/subscribe. ACM Comput. Surv. 35, 2 (June 2003), 114\u2013131. DOI:10.1145/857076.857078 [2] Gregor Hohpe and Bobby Woolf, Enterprise Integration Patterns: Message Bus. https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageBus.html","title":"Features"},{"location":"core_features/#features","text":"","title":"Features"},{"location":"core_features/#loose-coupling-of-components","text":"It is easier to manage a complex simulation system if the components only have the dependencies necessary for communication. The platform uses publish-subscribe communication, which decouples systems in \"time, space and synchronisation\" [1]. This means that the components do not interact directly but only via a communication platform. As the result, it is easier to develop and re-configure the setup as needed.","title":"Loose coupling of components"},{"location":"core_features/#run-simulation-with-single-command","text":"Once the environment has been set up, it is started with a single command. The platform takes care of starting and stopping the components.","title":"Run simulation with single command"},{"location":"core_features/#analysis-of-results","text":"The platform provides a logging system that captures all messages sent from a component. After the simulation, you can explore the messages either one by one or by generating time series from individual messages.","title":"Analysis of results"},{"location":"core_features/#add-your-own-components","text":"In the platform, the simulation components have a workflow they must implement. To develop your own component, the sole requirement is to implement the required communication interface and follow the workflow.","title":"Add your own components"},{"location":"core_features/#parametrize-your-components","text":"The platform provides a mechanism to deliver parameters to the components. You specify by yourself what the parameters are and what values these can have. For example, if your system has a storage of electricity or liquid with size as a property, you can simulate how the size affects the overall system.","title":"Parametrize your components"},{"location":"core_features/#geographical-distribution","text":"If needed, you can distribute the simulations geographically. You can connect a simulation component from anywhere in the world via Internet. This enables a joint effort together with project partners as well as the application of a server cluster located in other premises.","title":"Geographical distribution"},{"location":"core_features/#principles-of-messaging","text":"The communication in based on a message bus. This is defined as follows: A Message Bus is a combination of a common data model, a common command set, and a messaging infrastructure to allow different systems to communicate through a shared set of interfaces. [2] As the message bus is in place, the components do not interact directly. Instead, when a component has something to say, it publishes a message. Because the bus uses the publish-subscribe paradigm, any other simulation component can subscribe for the messages to receive them. This is implemented with topics . A topic is an arbitrary string that identifies a subject of interest. The string can be, e.g., \"MyRoom.MySensorA.Temperature\" or \"WeatherInfo.CityX\". The topic-based approach realizes loose coupling, because the components do not directly connect to each other.","title":"Principles of messaging"},{"location":"core_features/#time-and-synchronization","text":"The simulator components are distributed but should still operate together, which necessitates a mechanism to synchronize time. This is implemented with epochs . An epoch represents a period of simulated time, e.g., today between 12:00 and 12:15 p.m. The length of epoch can be varied depending on the desired resolution of simulation. As epochs always represent simulated time, the duration is different in real time. This depends mainly on how fast the slowest component can simulate.","title":"Time and synchronization"},{"location":"core_features/#managing-components-in-platform-or-externally","text":"The simulation platform exploits virtualization to facilitate the management of components, but this has limitations. Virtualization is suitable for lightweight components that do not require particularly lot of computational power. On the other hand, sometimes a more powerful platform - possibly even a server cluster - is necessary. To enable both easy management and heavy computation, the platform supports two types of components: platform managed and externally managed .","title":"Managing components in platform or externally"},{"location":"core_features/#accessing-the-results","text":"During a simulation run, the logging system of the platform stores any messages exchanged between the simulation components. The logging system provides an HTTP API to access the messages. (In technical terms, this API is Restful, although not all HTTP-based technologies are.) Features: View the results with any HTTP client, including a web browser or a custom client View individual messages Build timeseries from multiple messages of the same structure Retrieve data in: JSON (JavaScript Object Notation) CSV (Comma-separated Values; only for timeseries)","title":"Accessing the results"},{"location":"core_features/#references","text":"[1] Patrick Th. Eugster, Pascal A. Felber, Rachid Guerraoui, and Anne-Marie Kermarrec. 2003. The many faces of publish/subscribe. ACM Comput. Surv. 35, 2 (June 2003), 114\u2013131. DOI:10.1145/857076.857078 [2] Gregor Hohpe and Bobby Woolf, Enterprise Integration Patterns: Message Bus. https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageBus.html","title":"References"},{"location":"core_follow-run/","text":"Following a running simulation There are a couple of ways to follow a running simulation that has been started using the simulation platform. Commands for the first two ways are given by Platform Manager after the simulation has been started. All the component outputs can be followed using a Bash script follow_simulation.sh . The output from any participating simulation component can be followed using docker logs command. The logged messages from the simulation can be looked at using Log Reader even during the simulation. See the Log Reader API for more information. The platform managed Docker containers use a name format Sim<id_number>_<component_name> where <id_number> is the first available 2-digit number (00, 01, ..., 99) at the start of the simulation and <component_name> is the component name used in the simulation run. For example, for the first started simulation, the Simulation Manager container should be named Sim00_SimulationManager . The Platform Manager outputs the <id_number> for the started simulation run. Using follow simulation script To start following the running simulation with colored output from all the platform managed components, using Bash compatible terminal navigate to the installation folder and use the command: source follow_simulation.sh <id_number> where <id_number> is given by the Platform Manager after the simulation run has been started. The full command is also part of the Platform Manager output. Note, that due to the way this follow script has been implemented, it cannot be easily cancelled and if you want to stop following the simulation the easiest way to do so is to close the terminal window. Closing the terminal window while a simulation is running does not affect the actual simulation. Using docker logs command To follow the advancing of the simulation, the output from any of the participating components can be followed using the command (can be used from any folder and does not require Bash compatible terminal, e.g. works also with Command Prompt in Windows): docker logs --follow Sim<id_number>_<component_name> where <id_number> is given by the Platform Manager after the simulation run has been started and <component_name> is the name of the component as it is defined in the simulation configuration file. The full command to follow the output from the Simulation Manager is also part of the Platform Manager output. Following the log output can be cancelled using the key combination Ctrl+C . Cancelling the log following does not affect the actual simulation. Fetching log files after a simulation run The platform managed Docker containers are automatically deleted after the simulation is finished, and thus the component outputs cannot be looked at using the follow simulation script or docker logs command after the simulation is finished. After the simulation, the output from the components can be found stored in log files in a Docker volume called simces_simulation_logs in the folder /logs . The log files can be fetched to a local folder using a Bash script logs/copy_logs.sh : Navigate to the folder logs inside the installation folder using a Bash compatible terminal. Use the following command to copy all the log files to the logs folder: source copy_logs.sh The filenames for the log files use the format logfile_<component_name>.log . Note that the files can contain outputs from multiple simulations. The latest outputs are at the end of the log files. The print out the entire log file using command line: cat logfile_<component_name>.log To print out the contents of the log file one page at a time: more logfile_<component_name>.log To print out only the last 15 lines from the log file: tail --lines 15 logfile_<component_name>.log","title":"Follow running simulation"},{"location":"core_follow-run/#following-a-running-simulation","text":"There are a couple of ways to follow a running simulation that has been started using the simulation platform. Commands for the first two ways are given by Platform Manager after the simulation has been started. All the component outputs can be followed using a Bash script follow_simulation.sh . The output from any participating simulation component can be followed using docker logs command. The logged messages from the simulation can be looked at using Log Reader even during the simulation. See the Log Reader API for more information. The platform managed Docker containers use a name format Sim<id_number>_<component_name> where <id_number> is the first available 2-digit number (00, 01, ..., 99) at the start of the simulation and <component_name> is the component name used in the simulation run. For example, for the first started simulation, the Simulation Manager container should be named Sim00_SimulationManager . The Platform Manager outputs the <id_number> for the started simulation run.","title":"Following a running simulation"},{"location":"core_follow-run/#using-follow-simulation-script","text":"To start following the running simulation with colored output from all the platform managed components, using Bash compatible terminal navigate to the installation folder and use the command: source follow_simulation.sh <id_number> where <id_number> is given by the Platform Manager after the simulation run has been started. The full command is also part of the Platform Manager output. Note, that due to the way this follow script has been implemented, it cannot be easily cancelled and if you want to stop following the simulation the easiest way to do so is to close the terminal window. Closing the terminal window while a simulation is running does not affect the actual simulation.","title":"Using follow simulation script"},{"location":"core_follow-run/#using-docker-logs-command","text":"To follow the advancing of the simulation, the output from any of the participating components can be followed using the command (can be used from any folder and does not require Bash compatible terminal, e.g. works also with Command Prompt in Windows): docker logs --follow Sim<id_number>_<component_name> where <id_number> is given by the Platform Manager after the simulation run has been started and <component_name> is the name of the component as it is defined in the simulation configuration file. The full command to follow the output from the Simulation Manager is also part of the Platform Manager output. Following the log output can be cancelled using the key combination Ctrl+C . Cancelling the log following does not affect the actual simulation.","title":"Using docker logs command"},{"location":"core_follow-run/#fetching-log-files-after-a-simulation-run","text":"The platform managed Docker containers are automatically deleted after the simulation is finished, and thus the component outputs cannot be looked at using the follow simulation script or docker logs command after the simulation is finished. After the simulation, the output from the components can be found stored in log files in a Docker volume called simces_simulation_logs in the folder /logs . The log files can be fetched to a local folder using a Bash script logs/copy_logs.sh : Navigate to the folder logs inside the installation folder using a Bash compatible terminal. Use the following command to copy all the log files to the logs folder: source copy_logs.sh The filenames for the log files use the format logfile_<component_name>.log . Note that the files can contain outputs from multiple simulations. The latest outputs are at the end of the log files. The print out the entire log file using command line: cat logfile_<component_name>.log To print out the contents of the log file one page at a time: more logfile_<component_name>.log To print out only the last 15 lines from the log file: tail --lines 15 logfile_<component_name>.log","title":"Fetching log files after a simulation run"},{"location":"core_install/","text":"Installation Follow the given steps to install the platform. Prerequisites The simulation platform and these instructions have been tested on Ubuntu 18.04 with Docker Engine version 20.10.2 and Docker Compose version 1.28.2. Bash For running the helper scripts. The \"curl\" command must also be installed (usually available by default). For Windows, Bash is included with the Git for Windows , for other operating systems it is likely available by default. On Windows the Windows Subsystem for Linux (WSL) can also be used, though setting it up requires more technical knowledge than installing Git for Windows. Docker and Docker Compose For running platform managed components for the simulations. For running the local RabbitMQ message bus as well as the local MongoDB database. These are installed by the installation scripts. Installing the most up-to-date versions of Docker and Docker Compose is the recommended option. On Linux, to be compatible with the platform scripts it is advisable to set Docker to be manageable as a non-root user: https://docs.docker.com/engine/install/linux-postinstall/ Some simulation components might have other requirements. For those, see the component specific documentation. Installing the platform and the core components 1. Create a folder for the simulation platform. In these instructions this main folder is named platform . Note, that you must have full read and write permissions in the created folder, platform . Otherwise, the installation process will not work. 2. Copy the fetch_platform_files.sh script file to the platform folder by downloading it from GitHub using the browser interface (right click on the \"Raw\" button and \"Save Link As...\") or by using the command line: wget https://raw.githubusercontent.com/simcesplatform/Platform-Manager/master/fetch_platform_files.sh 3. Using Git Bash (in Windows) or other terminal that supports Bash navigate to the platform folder. In the terminal you can navigate inside a folder using command: cd <folder_name> If the folder name contains a whitespace character, quotes must be used around the folder name. For example, to navigate to folder \"My Folder\", use: cd \"My Folder\" To navigate to the parent folder, use command: cd .. To check your current folder, use command: pwd To list the files and sub folders in the current folder, use command: ls -l 4. Run the fetch script using the command source fetch_platform_files.sh github Answer \"y\" when prompted to start fetching the source code. If everything went alright, the script should print the following line at the end: All files where found. Platform is ready for installation. 5. (Optional) Setup the settings for the RabbitMQ message bus and the Mongo database. Note, that the default settings can be used for running simulations locally. See section General platform level settings on the available settings. 6. Start the simulation platform by running the following command in the platform folder using a terminal that supports Bash source platform_core_setup.sh The script will fetch all the platform components (their Docker images) and other files that are needed to run the first simulations. After the fetching stage the script will then start all the required background processes. Running the script will take a few minutes. 7. (Optional) Check that all the required platform components have been downloaded. To list the built Docker images run the command docker images You should have at least the images shown in the example listing below: REPOSITORY TAG IMAGE ID CREATED SIZE ghcr.io/simcesplatform/platform-manager latest 1330807ae5cc 9 days ago 909MB ghcr.io/simcesplatform/simulation-manager latest d14c1a9bfbd0 9 days ago 896MB ghcr.io/simcesplatform/manifest-fetcher latest 3486b5fac52a 9 days ago 903MB ghcr.io/simcesplatform/logwriter latest d9f1d537169b 9 days ago 900MB ghcr.io/simcesplatform/dummy-component latest 76811eb2d295 10 days ago 1.12GB ghcr.io/simcesplatform/mongo-express latest f43423478d66 3 months ago 127MB ghcr.io/simcesplatform/logreader latest 42d8ca7ecd53 3 months ago 956MB rabbitmq 3.8.4-management cc86ffa2f398 9 months ago 186MB mongo 4.2.7 66c68b650ad4 9 months ago 388MB 8. (Optional) Check that all the background components have been started. 8.1.To list all the running Docker containers run the command docker ps --format \"table {{.ID}}\\t{{.Image}}\\t{{.Status}}\\t{{.Names}}\" You should have at least those containers running that are shown in the example listing below: CONTAINER ID IMAGE STATUS NAMES ef59c0f21457 ghcr.io/simcesplatform/mongo-express:latest Up 2 minutes simces_mongo_express ff24ba9e33de ghcr.io/simcesplatform/logreader Up 2 minutes simces_log_reader f7d3e82ccc4b ghcr.io/simcesplatform/logwriter Up 2 minutes simces_log_writer_management 1995624af84a rabbitmq:3.8.4-management Up 2 minutes simces_rabbitmq b49675bd1581 mongo:4.2.7 Up 2 minutes simces_mongodb 8.2. Check that the Log Writer instance listening to the management exchange is running properly. This also works as a check for the RabbitMQ message bus. To check the log output from the Log Writer instance use the command docker logs simces_log_writer_management If you see Now listening to messages; exc=procem-management, topic=# and there is no Connect call failed or Closing listener for topics: '#' after the Now listening ... line, the Log Writer instance should be running properly. Note, that it does not matter if output contains connection fail messages before the last Now listening ... line as long as the there no such messages after that line. If the previous check indicates that the Log Writer instance is not working properly, do the following: Stop the Log Writer instance with commands: docker stop simces_log_writer_management docker rm simces_log_writer_management Optionally, check the parameters for the message bus (step 5). Run the platform core setup script from step 6 again. Check the Log Writer output again to see if the problem has been fixed. 8.3. Check that the Log Reader is running. This also works as a check for the Mongo database. The Log Reader should be running on localhost at port 8080. To check that it is responding use a browser to check that you can see the user interface page at the address http://localhost:8080 . For instructions on how to use the Log Reader see Log API For advanced users If you setup the Mongo Express, it can be accessed at the address http://localhost:8081 . Through the Mongo Express, you get admin access to the database by default, so care should be taken when making any changes to the database contents. If you are using the local RabbitMQ instance, you can access the RabbitMQ Management Plugin at the address http://localhost:15672 . After these steps, the simulation platform should be ready for starting test simulation run. To see instructions on how to start a simulation run see the page Running a simulation . Uninstalling the core components The following commands are to be used in the installation folder using a terminal that supports Bash. To stop the running core components: docker-compose -f background/docker-compose-background.yml down --remove-orphans To remove the platform components entirely from the system (WARNING: this will remove all Docker images that are not in use, regardless of whether they are related to the simulation platform or not. However, the logged messages in the database from simulations will not be removed): docker system prune --all The files created in the installation folder have to be removed manually. For advanced users For systems that have other Docker related things installed it is possibly not reasonable to run the general removal command. Use the following at your own discretion. To stop and remove the background components: docker-compose -f background/docker-compose-background.yml down --remove-orphans To stop and remove the Docker containers related to the platform (removes those containers that start with \"simces\" or \"Sim\"): docker ps --all --filter name=\"simces\" --filter name=\"Sim\" --format \"{{.Names}}\" | xargs docker stop docker ps --all --filter name=\"simces\" --filter name=\"Sim\" --format \"{{.Names}}\" | xargs docker rm To remove the Docker images related to the platform: docker images -a | grep \"simcesplatform\\|mongo\\|rabbitmq\\|ubuntu\" | awk '{print $3}' | xargs docker rmi To remove the Docker networks related to the platform: docker network ls --filter name=simces --format \"{{.Name}}\" | xargs docker network rm To also remove all the data related to the platform, i.e. to remove the Docker volumes related to the platform: docker volume ls --filter name=simces --format \"{{.Name}}\" | xargs docker volume rm","title":"Installation"},{"location":"core_install/#installation","text":"Follow the given steps to install the platform.","title":"Installation"},{"location":"core_install/#prerequisites","text":"The simulation platform and these instructions have been tested on Ubuntu 18.04 with Docker Engine version 20.10.2 and Docker Compose version 1.28.2. Bash For running the helper scripts. The \"curl\" command must also be installed (usually available by default). For Windows, Bash is included with the Git for Windows , for other operating systems it is likely available by default. On Windows the Windows Subsystem for Linux (WSL) can also be used, though setting it up requires more technical knowledge than installing Git for Windows. Docker and Docker Compose For running platform managed components for the simulations. For running the local RabbitMQ message bus as well as the local MongoDB database. These are installed by the installation scripts. Installing the most up-to-date versions of Docker and Docker Compose is the recommended option. On Linux, to be compatible with the platform scripts it is advisable to set Docker to be manageable as a non-root user: https://docs.docker.com/engine/install/linux-postinstall/ Some simulation components might have other requirements. For those, see the component specific documentation.","title":"Prerequisites"},{"location":"core_install/#installing-the-platform-and-the-core-components","text":"1. Create a folder for the simulation platform. In these instructions this main folder is named platform . Note, that you must have full read and write permissions in the created folder, platform . Otherwise, the installation process will not work. 2. Copy the fetch_platform_files.sh script file to the platform folder by downloading it from GitHub using the browser interface (right click on the \"Raw\" button and \"Save Link As...\") or by using the command line: wget https://raw.githubusercontent.com/simcesplatform/Platform-Manager/master/fetch_platform_files.sh 3. Using Git Bash (in Windows) or other terminal that supports Bash navigate to the platform folder. In the terminal you can navigate inside a folder using command: cd <folder_name> If the folder name contains a whitespace character, quotes must be used around the folder name. For example, to navigate to folder \"My Folder\", use: cd \"My Folder\" To navigate to the parent folder, use command: cd .. To check your current folder, use command: pwd To list the files and sub folders in the current folder, use command: ls -l 4. Run the fetch script using the command source fetch_platform_files.sh github Answer \"y\" when prompted to start fetching the source code. If everything went alright, the script should print the following line at the end: All files where found. Platform is ready for installation. 5. (Optional) Setup the settings for the RabbitMQ message bus and the Mongo database. Note, that the default settings can be used for running simulations locally. See section General platform level settings on the available settings. 6. Start the simulation platform by running the following command in the platform folder using a terminal that supports Bash source platform_core_setup.sh The script will fetch all the platform components (their Docker images) and other files that are needed to run the first simulations. After the fetching stage the script will then start all the required background processes. Running the script will take a few minutes. 7. (Optional) Check that all the required platform components have been downloaded. To list the built Docker images run the command docker images You should have at least the images shown in the example listing below: REPOSITORY TAG IMAGE ID CREATED SIZE ghcr.io/simcesplatform/platform-manager latest 1330807ae5cc 9 days ago 909MB ghcr.io/simcesplatform/simulation-manager latest d14c1a9bfbd0 9 days ago 896MB ghcr.io/simcesplatform/manifest-fetcher latest 3486b5fac52a 9 days ago 903MB ghcr.io/simcesplatform/logwriter latest d9f1d537169b 9 days ago 900MB ghcr.io/simcesplatform/dummy-component latest 76811eb2d295 10 days ago 1.12GB ghcr.io/simcesplatform/mongo-express latest f43423478d66 3 months ago 127MB ghcr.io/simcesplatform/logreader latest 42d8ca7ecd53 3 months ago 956MB rabbitmq 3.8.4-management cc86ffa2f398 9 months ago 186MB mongo 4.2.7 66c68b650ad4 9 months ago 388MB 8. (Optional) Check that all the background components have been started. 8.1.To list all the running Docker containers run the command docker ps --format \"table {{.ID}}\\t{{.Image}}\\t{{.Status}}\\t{{.Names}}\" You should have at least those containers running that are shown in the example listing below: CONTAINER ID IMAGE STATUS NAMES ef59c0f21457 ghcr.io/simcesplatform/mongo-express:latest Up 2 minutes simces_mongo_express ff24ba9e33de ghcr.io/simcesplatform/logreader Up 2 minutes simces_log_reader f7d3e82ccc4b ghcr.io/simcesplatform/logwriter Up 2 minutes simces_log_writer_management 1995624af84a rabbitmq:3.8.4-management Up 2 minutes simces_rabbitmq b49675bd1581 mongo:4.2.7 Up 2 minutes simces_mongodb 8.2. Check that the Log Writer instance listening to the management exchange is running properly. This also works as a check for the RabbitMQ message bus. To check the log output from the Log Writer instance use the command docker logs simces_log_writer_management If you see Now listening to messages; exc=procem-management, topic=# and there is no Connect call failed or Closing listener for topics: '#' after the Now listening ... line, the Log Writer instance should be running properly. Note, that it does not matter if output contains connection fail messages before the last Now listening ... line as long as the there no such messages after that line. If the previous check indicates that the Log Writer instance is not working properly, do the following: Stop the Log Writer instance with commands: docker stop simces_log_writer_management docker rm simces_log_writer_management Optionally, check the parameters for the message bus (step 5). Run the platform core setup script from step 6 again. Check the Log Writer output again to see if the problem has been fixed. 8.3. Check that the Log Reader is running. This also works as a check for the Mongo database. The Log Reader should be running on localhost at port 8080. To check that it is responding use a browser to check that you can see the user interface page at the address http://localhost:8080 . For instructions on how to use the Log Reader see Log API For advanced users If you setup the Mongo Express, it can be accessed at the address http://localhost:8081 . Through the Mongo Express, you get admin access to the database by default, so care should be taken when making any changes to the database contents. If you are using the local RabbitMQ instance, you can access the RabbitMQ Management Plugin at the address http://localhost:15672 . After these steps, the simulation platform should be ready for starting test simulation run. To see instructions on how to start a simulation run see the page Running a simulation .","title":"Installing the platform and the core components"},{"location":"core_install/#uninstalling-the-core-components","text":"The following commands are to be used in the installation folder using a terminal that supports Bash. To stop the running core components: docker-compose -f background/docker-compose-background.yml down --remove-orphans To remove the platform components entirely from the system (WARNING: this will remove all Docker images that are not in use, regardless of whether they are related to the simulation platform or not. However, the logged messages in the database from simulations will not be removed): docker system prune --all The files created in the installation folder have to be removed manually. For advanced users For systems that have other Docker related things installed it is possibly not reasonable to run the general removal command. Use the following at your own discretion. To stop and remove the background components: docker-compose -f background/docker-compose-background.yml down --remove-orphans To stop and remove the Docker containers related to the platform (removes those containers that start with \"simces\" or \"Sim\"): docker ps --all --filter name=\"simces\" --filter name=\"Sim\" --format \"{{.Names}}\" | xargs docker stop docker ps --all --filter name=\"simces\" --filter name=\"Sim\" --format \"{{.Names}}\" | xargs docker rm To remove the Docker images related to the platform: docker images -a | grep \"simcesplatform\\|mongo\\|rabbitmq\\|ubuntu\" | awk '{print $3}' | xargs docker rmi To remove the Docker networks related to the platform: docker network ls --filter name=simces --format \"{{.Name}}\" | xargs docker network rm To also remove all the data related to the platform, i.e. to remove the Docker volumes related to the platform: docker volume ls --filter name=simces --format \"{{.Name}}\" | xargs docker volume rm","title":"Uninstalling the core components"},{"location":"core_lifecycle/","text":"Simulation lifecycle This page documents the setup of components for a simulation run. To execute, the components need certain parameters depending on the functionality. How these parameters are delivered depends on the way the components are managed (externally or in the platform). Platform managed In this approach, the components is managed by the platform with Docker. This suits for components that: Do not need a server cluster Do not need \"a lot of\" computational resources In this approach, the following workflow repeats in a loop. Each round is started manually. A user starts up components manually as Docker containers In the startup, the user somehow specifies simulation parameters Among the Docker containers, there is Platform Manager that communicates the simulation parameters The parameters are sent to Management Exchange using Start message This enables any externally managed components to receive the parameters The components execute until finished Externally managed In this approach, the component is managed manually. Human users must make sure that the component is running before a simulation can be executed. This approach has at least the following uses: Unit testing and first experiments Components that cannot reasonably be dockerized: Uses a server cluster Requires a lot of computational resources, such as memory Possibly for components that can run concurrent simulations Each externally managed component is first started manually. Then, it runs the following workflow in a loop: Receive \"start\" message (see Start message ) from Management Exchange ; this contains simulation-run-specific parameters Set up the received parameters to the component After this, the component is ready to communicate with other components via the Simulation-specific Exchange Run the component; it will communicate with other components via the Simulation-specific Exchange The workflow is illustrated in the figure below.","title":"Simulation lifecycle"},{"location":"core_lifecycle/#simulation-lifecycle","text":"This page documents the setup of components for a simulation run. To execute, the components need certain parameters depending on the functionality. How these parameters are delivered depends on the way the components are managed (externally or in the platform).","title":"Simulation lifecycle"},{"location":"core_lifecycle/#platform-managed","text":"In this approach, the components is managed by the platform with Docker. This suits for components that: Do not need a server cluster Do not need \"a lot of\" computational resources In this approach, the following workflow repeats in a loop. Each round is started manually. A user starts up components manually as Docker containers In the startup, the user somehow specifies simulation parameters Among the Docker containers, there is Platform Manager that communicates the simulation parameters The parameters are sent to Management Exchange using Start message This enables any externally managed components to receive the parameters The components execute until finished","title":"Platform managed"},{"location":"core_lifecycle/#externally-managed","text":"In this approach, the component is managed manually. Human users must make sure that the component is running before a simulation can be executed. This approach has at least the following uses: Unit testing and first experiments Components that cannot reasonably be dockerized: Uses a server cluster Requires a lot of computational resources, such as memory Possibly for components that can run concurrent simulations Each externally managed component is first started manually. Then, it runs the following workflow in a loop: Receive \"start\" message (see Start message ) from Management Exchange ; this contains simulation-run-specific parameters Set up the received parameters to the component After this, the component is ready to communicate with other components via the Simulation-specific Exchange Run the component; it will communicate with other components via the Simulation-specific Exchange The workflow is illustrated in the figure below.","title":"Externally managed"},{"location":"core_log-api/","text":"Log API Once you have run a simulation, you can access the messages published by your components from LogReader with the log API. Quick start To verify that a simulation has been executed, you can retrieve simulation information. Type this address into your web browser: http://localhost:8080/simulations This assumes that you run the simulation platform locally This will return the information of all simulation runs this far From the response, you can verify that a simulation has occurred by looking at StartTime and EndTime strings. These should have a time value that matches the time you executed the simulation. The above used a direct call to the get simulations API. Alternatively you can use the built-in user interface which can create the API calls for you. So to perform the above operation with the user interface with your browser go to address: http://localhost:8080/ Then under the \"Get metadata for all simulations\" heading press the \"send query\" button. This opens a new browser tab that uses the address from the first example and thus shows the same information. API overview LogReader implements the HTTP based API described below. LogReader also offers a simple web browser based interface for the API available from the application root path for example http://localhost:8080/ . The API offers the following features: Get list of simulations there are messages for. Get information about a single simulation by its id. Get messages for a simulation. Messages can be filtered in various ways such as topic and source process. Get invalid messages published during a simulation run. Create a json or csv time series from attribute values in messages. This documentation assumes that the reader is familiar with the general messaging concepts of the simulation platform such as epochs and the various message attribute value blocks like TimeseriesBlock and QuantityBlock. The following notation is used to document request parameters and members of JSON objects in response and request bodies: name (data type, parameter type, required): description Term Description for the term name parameter or JSON member name data type Data type for the value such as string, integer or ISO datetime parameter type Only for request parameters: either path (if the parameter is in the URL path) or query (if the parameter is part of the URL query parameters) required Indicates that the parameter or JSON member is required. If this keyword is not present, the parameter or member is optional. This is not used with response JSON where all members can be assumed to be present. description Explanation for the purpose of the parameter or JSON member. The API is available from the application root path. So for example if LogReader is running on localhost port 8080 (as is the default) the URL to get all simulations would be http://localhost:8080/simulations . The examples for each API endpoint use localhost port 8080 in example request URLs. Note that the message structures and topics used in the examples may not always match the actual topics and structures defined for the platform. The examples are based on test data included with LogReader which can be imported to the LogReader database. This allows trying out the API. See the LogReader readme for instructions how to use the test data. Get simulations method: GET path: /simulations Returns a list of simulation runs the message database has messages for. Request parameters fromDate (ISO datetime, query): Return simulation runs which have started on or after the given date. toDate (ISO datetime, query): Return simulation runs that have been started before the given date. Response List of simulation runs with the following information available about every run. SimulationId (string): The id of the simulation. Name (string): A human friendly name for the simulation. Description (string): A longer description of the simulation run meant for humans. StartTime (ISO datetime): The real world start time of the simulation run. EndTime (ISO datetime): The real world end time of the simulation run. Epochs (integer): Number of epochs in the simulation run. Processes (array of strings): List of names of processes participating in the simulation run. Example Get list of simulations executed on or after 3th of June 2020 at 10:00. Request http://localhost:8080/simulations?fromDate=2020-06-03T10:00:00Z Response [ { \"Description\": \"This is a test simulation without example messages.\", \"EndTime\": \"2020-06-03T10:05:52.345000Z\", \"Epochs\": 40, \"Name\": \"test simulation 2\", \"Processes\": [ \"simulationManager\", \"weatherDivinity\", \"solarPlant1\", \"battery1\", \"battery2\" ], \"SimulationId\": \"2020-06-03T10:01:52.345Z\", \"StartTime\": \"2020-06-03T10:01:52.345000Z\" }, { \"Description\": \"This is a test simulation without example messages.\", \"EndTime\": \"2020-06-03T04:15:52.345000Z\", \"Epochs\": 100, \"Name\": \"test simulation 2\", \"Processes\": [ \"simulationManager\", \"weatherDivinity\", \"solarPlant1\", \"battery1\" ], \"SimulationId\": \"2020-06-04T04:01:52.345Z\", \"StartTime\": \"2020-06-04T04:01:52.345000Z\" } ] Get simulation method: GET path: /simulations/{simulationId} Returns general information about the given simulation run. Request parameters simulationId (string, path, required): The id of a simulation run. Response Information about the given simulation run with the same contents as in each get simulations response item. Example Get information about simulation with id 2020-06-03T04:01:52.345Z. Request http://localhost:8080/simulations/2020-06-03T04:01:52.345Z Response { \"Description\": \"This is a test simulation with some example messages.\", \"EndTime\": \"2020-06-03T04:11:52.345000Z\", \"Epochs\": 50, \"Name\": \"test simulation 1\", \"Processes\": [ \"simulationManager\", \"weatherDivinity\", \"solarPlant1\", \"battery1\", \"battery2\", \"battery3\" ], \"SimulationId\": \"2020-06-03T04:01:52.345Z\", \"StartTime\": \"2020-06-03T04:01:52.345000Z\" } Get messages for simulation run method: GET path: /simulations/{simulationId}/messages Returns messages from the given simulation run. Without parameters returns all messages. Parameters allow filtering in various ways. Request parameters simulationId (string, path, required): Id of the simulation run messages are fetched from. startEpoch (integer, query): Return messages published on or after the given epoch. Not applicable if epoch, fromSimDate or toSimDate are used. endEpoch (integer, query): Return messages published on or before the given epoch. Not applicable if the epoch, fromSimDate or toSimDate are used. epoch (integer, query): return messages published during the given epoch. Not applicable if fromSimDate, toSimDate endEpoch or startEpoch are used. fromSimDate (ISO datetime, query): Return messages starting from the epoch that includes the given date. Not applicable if startEpoch, epoch or endEpoch are used. toSimDate (ISO datetime, query): Return messages published before or on the epoch that includes the given date. Not applicable if startEpoch, epoch or endEpoch are used. process (string, query): Return messages that have been published by the given processes i.e. messages whose source is the given process. Value is a comma separated list of process ids. topic (string, query): Return messages published to the given topic. Supports the same notation that is used when subscribing to the topics i.e. the same wildcard mechanism including the * and # characters. onlyWarnings : (boolean, query): If true, only messages that include warnings are returned. If false, messages with and without warnings are both returned. False is the default behaviour if this parameter is not used. Response List of messages as they have been saved into the database including the message metadata. The messages will be sorted in ascending order by timestamp. Example Get messages that process solarPlant1 has published to topic energy.production.solar on or before epoch 2 for simulation with id 2020-06-03T04:01:52.345Z. Request http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/messages?process=solarPlant1&topic=energy.production.solar&endEpoch=2 Response [ { \"EpochNumber\": 1, \"MessageId\": \"solarPlant1-1\", \"ReactivePower\": { \"UnitOfMeasure\": \"kV.A{r}\", \"Value\": 0.2 }, \"RealPower\": { \"UnitOfMeasure\": \"kW\", \"Value\": 5 }, \"SimulationId\": \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\": \"solarPlant1\", \"Timestamp\": \"2020-06-03T04:01:56Z\", \"Topic\": \"energy.production.solar\", \"Type\": \"ControlState\", \"bus\": \"bus1\" }, { \"EpochNumber\": 2, \"MessageId\": \"solarPlant1-2\", \"ReactivePower\": { \"UnitOfMeasure\": \"kV.A{r}\", \"Value\": 0.5 }, \"RealPower\": { \"UnitOfMeasure\": \"kW\", \"Value\": 8 }, \"SimulationId\": \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\": \"solarPlant1\", \"Timestamp\": \"2020-06-03T04:02:56Z\", \"Topic\": \"energy.production.solar\", \"Type\": \"ControlState\", \"bus\": \"bus1\" } ] Get invalid messages for simulation run method: GET path: /simulations/{simulationId}/messages/invalid Returns invalid messages from the given simulation run. This is intended for debugging simulation issues. A normal simulation run should not contain invalid messages. Request parameters simulationId (string, path, required): Id of the simulation run messages are fetched from. topic (string, query): Return invalid messages published to the given topic. Supports the same notation that is used when subscribing to the topics i.e. the same wildcard mechanism including the * and # characters. Response List of invalid messages. The messages will be sorted in ascending order by timestamp. The following attributes can be available for each message: Timestamp : Timestamp from the message if the message had a valid timestamp. Otherwise, this is a timestamp added when the message was stored to the database. Topic : The topic the message was published to. InvalidMessage : The message itself if it was valid JSON. InvalidJsonMessage : Message as a string if the message could not be parsed as JSON. Example Get all invalid messages for simulation with id 2020-06-03T04:01:52.345Z. Request http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/messages/invalid Response [ { \"Timestamp\": \"2020-06-03T04:01:53Z\", \"Topic\": \"Epoch\", \"InvalidMessage\": { \"EndTime\": \"2020-06-03T14:00:00Z\", \"EpochNumber\": 1, \"MessageId\": \"SimulationManager-2\", \"SourceProcessId\": \"SimulationManager\", \"StartTime\": \"2020-06-03T13:00:00Z\", \"Timestamp\": \"2020-06-03T04:01:53Z\", \"Type\": \"Epoch\" } }, { \"Timestamp\": \"2020-06-03T04:01:54Z\", \"Topic\": \"Status.Ready\", \"InvalidJsonMessage\": \"Ready\" } ] NOTE: The first message is considered invalid since it is missing the SimulationId attribute. The second message is invalid since it is just a text string containing the word Ready. Get simple timeseries for simulation method: GET path: /simulations/{simulationId}/timeseries Returns timeseries data constructed from values of given attributes of messages that meet the given time, topic and process based filtering conditions. Request parameters Same parameters as in get simulation messages are used except onlyWarnings . In addition, the following parameters are used: attrs (string, query, required) Comma separated list of names of message attributes whose values are suitable for time series and which are then included to the timeseries response. It is possible to refer deeper into the message structure using the dot notation, for example foo.bar. format (string, query): Determines the response format. Possible values are csv and json . If this parameter is not used, json is used as the default value. The following kinds of message attribute values are suitable for time series and can be referred to in the attrs query parameter: Plain number, string or boolean values. QuantityBlocks in which case the Value part of the QuantityBlock is added to the created time series. TimeseriesBlock . If only the attribute containing a time series block is referred to, all attributes in the time series are included. It is also possible to refer to a particular attribute inside the time series block to only include it to the time series to be created. JSON Response A JSON object with the following members: TimeIndex (array of timeIndex objects): List of timeIndex objects that indicate the timestamp for the data. For example, if a timeIndex object is the fifth item in the timeindex list then it has the time for the fifth value in each attribute values list. If there is no value for an attribute for a corresponding timeIndex value, the value will be null. {topic} (topicData object): For each topic there is timeseries data a member named after the topic. The value is a topicData object. timeIndex object timestamp (ISO datetime): Indicates the simulation time for the corresponding data. epoch (integer): Indicates the epoch for the message the corresponding data is from. topicData object {processName} (attributeValues object): For each process the timeseries has values for in the given topic a member where processName is replaced with the id of the process. The value is then attributeValues object. attributeValues object {attr} : For each message attribute a member where attr is replaced with the attribute name. The value is then list of attribute values from the messages or another attributeValues object if the actual values are deeper in the message structure. CSV response CSV data with the following column titles and column value data types epoch (integer): The epoch number for the message the data in the row is from. timestamp (iso datetime): Simulation timestamp for the data in the row. {topic}:{processName}.{attr} : For each topic, process and message attribute the timeseries contains data for, there is a column for it with a title consisting of the topic, process and attribute names. Attribute can consist of multiple parts separated by a period. If there is no data for the row at a certain time then the column has an empty cell. Example 1 Create a timeseries in the JSON format containing the real power and reactive power QuantityBlock values from messages that process solarPlant1 has published to topic energy.production.solar on or before epoch 2 for simulation with id 2020-06-03T04:01:52.345Z. The messages which are the source for this time series are shown in the example response at section Get messages for simulation . Request http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/timeseries?process=solarPlant1&topic=energy.production.solar&endEpoch=2&attrs=RealPower,ReactivePower Response { \"TimeIndex\": [ { \"epoch\": 1, \"timestamp\": \"2020-06-03T13:00:00Z\" }, { \"epoch\": 2, \"timestamp\": \"2020-06-03T14:00:00Z\" } ], \"energy.production.solar\": { \"solarPlant1\": { \"ReactivePower\": [ 0.2, 0.5 ], \"RealPower\": [ 5, 8 ] } } } Example 2 Same as example 1 except the time series should be in the CSV format. Request http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/timeseries?process=solarPlant1&topic=energy.production.solar&endEpoch=2&attrs=RealPower,ReactivePower&format=csv Response epoch;timestamp;energy.production.solar:solarPlant1.RealPower;energy.production.solar:solarPlant1.ReactivePower 1;2020-06-03T13:00:00Z;5.0;0.2 2;2020-06-03T14:00:00Z;8.0;0.5 Example 3 Create a time series in JSON format containing the chargePercentage values from the batteryState timeseries block from messages published to the energy.storage.state topic by processes battery1 and battery2 for simulation with id 2020-06-03T04:01:52.345Z. The published messages look like the following: { \"EpochNumber\": 1, \"MessageId\": \"battery1-1\", \"SimulationId\": \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\": \"battery1\", \"Timestamp\": \"2020-06-03T04:01:56Z\", \"Topic\": \"energy.storage.state\", \"Type\": \"Result\", \"batteryState\": { \"Series\": { \"capacity\": { \"UnitOfMeasure\": \"kWh\", \"Values\": [ 300, 280 ] }, \"chargePercentage\": { \"UnitOfMeasure\": \"%\", \"Values\": [ 90, 88 ] } }, \"TimeIndex\": [ \"2020-06-03T13:00:00Z\", \"2020-06-03T13:30:00Z\" ] } } Request http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/timeseries?process=battery1,battery2&topic=energy.storage.state&attrs=batteryState.chargePercentage Response { \"TimeIndex\": [ { \"epoch\": 1, \"timestamp\": \"2020-06-03T13:00:00Z\" }, { \"epoch\": 1, \"timestamp\": \"2020-06-03T13:30:00Z\" }, { \"epoch\": 2, \"timestamp\": \"2020-06-03T14:00:00Z\" }, { \"epoch\": 2, \"timestamp\": \"2020-06-03T14:30:00Z\" } ], \"energy.storage.state\": { \"battery1\": { \"batteryState\": { \"chargePercentage\": [ 90, 88, 87, 91 ] } }, \"battery2\": { \"batteryState\": { \"chargePercentage\": [ 40, 42, 45, 48 ] } } } } Example 4 Same as example 3 except timeseries is created in CSV format. Request http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/timeseries?process=battery1,battery2&topic=energy.storage.state&attrs=batteryState.chargePercentage&format=csv Response epoch;timestamp;energy.storage.state:battery1.batteryState.chargePercentage;energy.storage.state:battery2.batteryState.chargePercentage 1;2020-06-03T13:00:00Z;90;40 1;2020-06-03T13:30:00Z;88;42 2;2020-06-03T14:00:00Z;87;45 2;2020-06-03T14:30:00Z;91;48","title":"Log API"},{"location":"core_log-api/#log-api","text":"Once you have run a simulation, you can access the messages published by your components from LogReader with the log API.","title":"Log API"},{"location":"core_log-api/#quick-start","text":"To verify that a simulation has been executed, you can retrieve simulation information. Type this address into your web browser: http://localhost:8080/simulations This assumes that you run the simulation platform locally This will return the information of all simulation runs this far From the response, you can verify that a simulation has occurred by looking at StartTime and EndTime strings. These should have a time value that matches the time you executed the simulation. The above used a direct call to the get simulations API. Alternatively you can use the built-in user interface which can create the API calls for you. So to perform the above operation with the user interface with your browser go to address: http://localhost:8080/ Then under the \"Get metadata for all simulations\" heading press the \"send query\" button. This opens a new browser tab that uses the address from the first example and thus shows the same information.","title":"Quick start"},{"location":"core_log-api/#api-overview","text":"LogReader implements the HTTP based API described below. LogReader also offers a simple web browser based interface for the API available from the application root path for example http://localhost:8080/ . The API offers the following features: Get list of simulations there are messages for. Get information about a single simulation by its id. Get messages for a simulation. Messages can be filtered in various ways such as topic and source process. Get invalid messages published during a simulation run. Create a json or csv time series from attribute values in messages. This documentation assumes that the reader is familiar with the general messaging concepts of the simulation platform such as epochs and the various message attribute value blocks like TimeseriesBlock and QuantityBlock. The following notation is used to document request parameters and members of JSON objects in response and request bodies: name (data type, parameter type, required): description Term Description for the term name parameter or JSON member name data type Data type for the value such as string, integer or ISO datetime parameter type Only for request parameters: either path (if the parameter is in the URL path) or query (if the parameter is part of the URL query parameters) required Indicates that the parameter or JSON member is required. If this keyword is not present, the parameter or member is optional. This is not used with response JSON where all members can be assumed to be present. description Explanation for the purpose of the parameter or JSON member. The API is available from the application root path. So for example if LogReader is running on localhost port 8080 (as is the default) the URL to get all simulations would be http://localhost:8080/simulations . The examples for each API endpoint use localhost port 8080 in example request URLs. Note that the message structures and topics used in the examples may not always match the actual topics and structures defined for the platform. The examples are based on test data included with LogReader which can be imported to the LogReader database. This allows trying out the API. See the LogReader readme for instructions how to use the test data.","title":"API overview"},{"location":"core_log-api/#get-simulations","text":"method: GET path: /simulations Returns a list of simulation runs the message database has messages for.","title":"Get simulations"},{"location":"core_log-api/#request-parameters","text":"fromDate (ISO datetime, query): Return simulation runs which have started on or after the given date. toDate (ISO datetime, query): Return simulation runs that have been started before the given date.","title":"Request parameters"},{"location":"core_log-api/#response","text":"List of simulation runs with the following information available about every run. SimulationId (string): The id of the simulation. Name (string): A human friendly name for the simulation. Description (string): A longer description of the simulation run meant for humans. StartTime (ISO datetime): The real world start time of the simulation run. EndTime (ISO datetime): The real world end time of the simulation run. Epochs (integer): Number of epochs in the simulation run. Processes (array of strings): List of names of processes participating in the simulation run.","title":"Response"},{"location":"core_log-api/#example","text":"Get list of simulations executed on or after 3th of June 2020 at 10:00.","title":"Example"},{"location":"core_log-api/#request","text":"http://localhost:8080/simulations?fromDate=2020-06-03T10:00:00Z","title":"Request"},{"location":"core_log-api/#response_1","text":"[ { \"Description\": \"This is a test simulation without example messages.\", \"EndTime\": \"2020-06-03T10:05:52.345000Z\", \"Epochs\": 40, \"Name\": \"test simulation 2\", \"Processes\": [ \"simulationManager\", \"weatherDivinity\", \"solarPlant1\", \"battery1\", \"battery2\" ], \"SimulationId\": \"2020-06-03T10:01:52.345Z\", \"StartTime\": \"2020-06-03T10:01:52.345000Z\" }, { \"Description\": \"This is a test simulation without example messages.\", \"EndTime\": \"2020-06-03T04:15:52.345000Z\", \"Epochs\": 100, \"Name\": \"test simulation 2\", \"Processes\": [ \"simulationManager\", \"weatherDivinity\", \"solarPlant1\", \"battery1\" ], \"SimulationId\": \"2020-06-04T04:01:52.345Z\", \"StartTime\": \"2020-06-04T04:01:52.345000Z\" } ]","title":"Response"},{"location":"core_log-api/#get-simulation","text":"method: GET path: /simulations/{simulationId} Returns general information about the given simulation run.","title":"Get simulation"},{"location":"core_log-api/#request-parameters_1","text":"simulationId (string, path, required): The id of a simulation run.","title":"Request parameters"},{"location":"core_log-api/#response_2","text":"Information about the given simulation run with the same contents as in each get simulations response item.","title":"Response"},{"location":"core_log-api/#example_1","text":"Get information about simulation with id 2020-06-03T04:01:52.345Z.","title":"Example"},{"location":"core_log-api/#request_1","text":"http://localhost:8080/simulations/2020-06-03T04:01:52.345Z","title":"Request"},{"location":"core_log-api/#response_3","text":"{ \"Description\": \"This is a test simulation with some example messages.\", \"EndTime\": \"2020-06-03T04:11:52.345000Z\", \"Epochs\": 50, \"Name\": \"test simulation 1\", \"Processes\": [ \"simulationManager\", \"weatherDivinity\", \"solarPlant1\", \"battery1\", \"battery2\", \"battery3\" ], \"SimulationId\": \"2020-06-03T04:01:52.345Z\", \"StartTime\": \"2020-06-03T04:01:52.345000Z\" }","title":"Response"},{"location":"core_log-api/#get-messages-for-simulation-run","text":"method: GET path: /simulations/{simulationId}/messages Returns messages from the given simulation run. Without parameters returns all messages. Parameters allow filtering in various ways.","title":"Get messages for simulation run"},{"location":"core_log-api/#request-parameters_2","text":"simulationId (string, path, required): Id of the simulation run messages are fetched from. startEpoch (integer, query): Return messages published on or after the given epoch. Not applicable if epoch, fromSimDate or toSimDate are used. endEpoch (integer, query): Return messages published on or before the given epoch. Not applicable if the epoch, fromSimDate or toSimDate are used. epoch (integer, query): return messages published during the given epoch. Not applicable if fromSimDate, toSimDate endEpoch or startEpoch are used. fromSimDate (ISO datetime, query): Return messages starting from the epoch that includes the given date. Not applicable if startEpoch, epoch or endEpoch are used. toSimDate (ISO datetime, query): Return messages published before or on the epoch that includes the given date. Not applicable if startEpoch, epoch or endEpoch are used. process (string, query): Return messages that have been published by the given processes i.e. messages whose source is the given process. Value is a comma separated list of process ids. topic (string, query): Return messages published to the given topic. Supports the same notation that is used when subscribing to the topics i.e. the same wildcard mechanism including the * and # characters. onlyWarnings : (boolean, query): If true, only messages that include warnings are returned. If false, messages with and without warnings are both returned. False is the default behaviour if this parameter is not used.","title":"Request parameters"},{"location":"core_log-api/#response_4","text":"List of messages as they have been saved into the database including the message metadata. The messages will be sorted in ascending order by timestamp.","title":"Response"},{"location":"core_log-api/#example_2","text":"Get messages that process solarPlant1 has published to topic energy.production.solar on or before epoch 2 for simulation with id 2020-06-03T04:01:52.345Z.","title":"Example"},{"location":"core_log-api/#request_2","text":"http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/messages?process=solarPlant1&topic=energy.production.solar&endEpoch=2","title":"Request"},{"location":"core_log-api/#response_5","text":"[ { \"EpochNumber\": 1, \"MessageId\": \"solarPlant1-1\", \"ReactivePower\": { \"UnitOfMeasure\": \"kV.A{r}\", \"Value\": 0.2 }, \"RealPower\": { \"UnitOfMeasure\": \"kW\", \"Value\": 5 }, \"SimulationId\": \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\": \"solarPlant1\", \"Timestamp\": \"2020-06-03T04:01:56Z\", \"Topic\": \"energy.production.solar\", \"Type\": \"ControlState\", \"bus\": \"bus1\" }, { \"EpochNumber\": 2, \"MessageId\": \"solarPlant1-2\", \"ReactivePower\": { \"UnitOfMeasure\": \"kV.A{r}\", \"Value\": 0.5 }, \"RealPower\": { \"UnitOfMeasure\": \"kW\", \"Value\": 8 }, \"SimulationId\": \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\": \"solarPlant1\", \"Timestamp\": \"2020-06-03T04:02:56Z\", \"Topic\": \"energy.production.solar\", \"Type\": \"ControlState\", \"bus\": \"bus1\" } ]","title":"Response"},{"location":"core_log-api/#get-invalid-messages-for-simulation-run","text":"method: GET path: /simulations/{simulationId}/messages/invalid Returns invalid messages from the given simulation run. This is intended for debugging simulation issues. A normal simulation run should not contain invalid messages.","title":"Get invalid messages for simulation run"},{"location":"core_log-api/#request-parameters_3","text":"simulationId (string, path, required): Id of the simulation run messages are fetched from. topic (string, query): Return invalid messages published to the given topic. Supports the same notation that is used when subscribing to the topics i.e. the same wildcard mechanism including the * and # characters.","title":"Request parameters"},{"location":"core_log-api/#response_6","text":"List of invalid messages. The messages will be sorted in ascending order by timestamp. The following attributes can be available for each message: Timestamp : Timestamp from the message if the message had a valid timestamp. Otherwise, this is a timestamp added when the message was stored to the database. Topic : The topic the message was published to. InvalidMessage : The message itself if it was valid JSON. InvalidJsonMessage : Message as a string if the message could not be parsed as JSON.","title":"Response"},{"location":"core_log-api/#example_3","text":"Get all invalid messages for simulation with id 2020-06-03T04:01:52.345Z.","title":"Example"},{"location":"core_log-api/#request_3","text":"http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/messages/invalid","title":"Request"},{"location":"core_log-api/#response_7","text":"[ { \"Timestamp\": \"2020-06-03T04:01:53Z\", \"Topic\": \"Epoch\", \"InvalidMessage\": { \"EndTime\": \"2020-06-03T14:00:00Z\", \"EpochNumber\": 1, \"MessageId\": \"SimulationManager-2\", \"SourceProcessId\": \"SimulationManager\", \"StartTime\": \"2020-06-03T13:00:00Z\", \"Timestamp\": \"2020-06-03T04:01:53Z\", \"Type\": \"Epoch\" } }, { \"Timestamp\": \"2020-06-03T04:01:54Z\", \"Topic\": \"Status.Ready\", \"InvalidJsonMessage\": \"Ready\" } ] NOTE: The first message is considered invalid since it is missing the SimulationId attribute. The second message is invalid since it is just a text string containing the word Ready.","title":"Response"},{"location":"core_log-api/#get-simple-timeseries-for-simulation","text":"method: GET path: /simulations/{simulationId}/timeseries Returns timeseries data constructed from values of given attributes of messages that meet the given time, topic and process based filtering conditions.","title":"Get simple timeseries for simulation"},{"location":"core_log-api/#request-parameters_4","text":"Same parameters as in get simulation messages are used except onlyWarnings . In addition, the following parameters are used: attrs (string, query, required) Comma separated list of names of message attributes whose values are suitable for time series and which are then included to the timeseries response. It is possible to refer deeper into the message structure using the dot notation, for example foo.bar. format (string, query): Determines the response format. Possible values are csv and json . If this parameter is not used, json is used as the default value. The following kinds of message attribute values are suitable for time series and can be referred to in the attrs query parameter: Plain number, string or boolean values. QuantityBlocks in which case the Value part of the QuantityBlock is added to the created time series. TimeseriesBlock . If only the attribute containing a time series block is referred to, all attributes in the time series are included. It is also possible to refer to a particular attribute inside the time series block to only include it to the time series to be created.","title":"Request parameters"},{"location":"core_log-api/#json-response","text":"A JSON object with the following members: TimeIndex (array of timeIndex objects): List of timeIndex objects that indicate the timestamp for the data. For example, if a timeIndex object is the fifth item in the timeindex list then it has the time for the fifth value in each attribute values list. If there is no value for an attribute for a corresponding timeIndex value, the value will be null. {topic} (topicData object): For each topic there is timeseries data a member named after the topic. The value is a topicData object. timeIndex object timestamp (ISO datetime): Indicates the simulation time for the corresponding data. epoch (integer): Indicates the epoch for the message the corresponding data is from. topicData object {processName} (attributeValues object): For each process the timeseries has values for in the given topic a member where processName is replaced with the id of the process. The value is then attributeValues object. attributeValues object {attr} : For each message attribute a member where attr is replaced with the attribute name. The value is then list of attribute values from the messages or another attributeValues object if the actual values are deeper in the message structure.","title":"JSON Response"},{"location":"core_log-api/#csv-response","text":"CSV data with the following column titles and column value data types epoch (integer): The epoch number for the message the data in the row is from. timestamp (iso datetime): Simulation timestamp for the data in the row. {topic}:{processName}.{attr} : For each topic, process and message attribute the timeseries contains data for, there is a column for it with a title consisting of the topic, process and attribute names. Attribute can consist of multiple parts separated by a period. If there is no data for the row at a certain time then the column has an empty cell.","title":"CSV response"},{"location":"core_log-api/#example-1","text":"Create a timeseries in the JSON format containing the real power and reactive power QuantityBlock values from messages that process solarPlant1 has published to topic energy.production.solar on or before epoch 2 for simulation with id 2020-06-03T04:01:52.345Z. The messages which are the source for this time series are shown in the example response at section Get messages for simulation .","title":"Example 1"},{"location":"core_log-api/#request_4","text":"http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/timeseries?process=solarPlant1&topic=energy.production.solar&endEpoch=2&attrs=RealPower,ReactivePower","title":"Request"},{"location":"core_log-api/#response_8","text":"{ \"TimeIndex\": [ { \"epoch\": 1, \"timestamp\": \"2020-06-03T13:00:00Z\" }, { \"epoch\": 2, \"timestamp\": \"2020-06-03T14:00:00Z\" } ], \"energy.production.solar\": { \"solarPlant1\": { \"ReactivePower\": [ 0.2, 0.5 ], \"RealPower\": [ 5, 8 ] } } }","title":"Response"},{"location":"core_log-api/#example-2","text":"Same as example 1 except the time series should be in the CSV format.","title":"Example 2"},{"location":"core_log-api/#request_5","text":"http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/timeseries?process=solarPlant1&topic=energy.production.solar&endEpoch=2&attrs=RealPower,ReactivePower&format=csv","title":"Request"},{"location":"core_log-api/#response_9","text":"epoch;timestamp;energy.production.solar:solarPlant1.RealPower;energy.production.solar:solarPlant1.ReactivePower 1;2020-06-03T13:00:00Z;5.0;0.2 2;2020-06-03T14:00:00Z;8.0;0.5","title":"Response"},{"location":"core_log-api/#example-3","text":"Create a time series in JSON format containing the chargePercentage values from the batteryState timeseries block from messages published to the energy.storage.state topic by processes battery1 and battery2 for simulation with id 2020-06-03T04:01:52.345Z. The published messages look like the following: { \"EpochNumber\": 1, \"MessageId\": \"battery1-1\", \"SimulationId\": \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\": \"battery1\", \"Timestamp\": \"2020-06-03T04:01:56Z\", \"Topic\": \"energy.storage.state\", \"Type\": \"Result\", \"batteryState\": { \"Series\": { \"capacity\": { \"UnitOfMeasure\": \"kWh\", \"Values\": [ 300, 280 ] }, \"chargePercentage\": { \"UnitOfMeasure\": \"%\", \"Values\": [ 90, 88 ] } }, \"TimeIndex\": [ \"2020-06-03T13:00:00Z\", \"2020-06-03T13:30:00Z\" ] } }","title":"Example 3"},{"location":"core_log-api/#request_6","text":"http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/timeseries?process=battery1,battery2&topic=energy.storage.state&attrs=batteryState.chargePercentage","title":"Request"},{"location":"core_log-api/#response_10","text":"{ \"TimeIndex\": [ { \"epoch\": 1, \"timestamp\": \"2020-06-03T13:00:00Z\" }, { \"epoch\": 1, \"timestamp\": \"2020-06-03T13:30:00Z\" }, { \"epoch\": 2, \"timestamp\": \"2020-06-03T14:00:00Z\" }, { \"epoch\": 2, \"timestamp\": \"2020-06-03T14:30:00Z\" } ], \"energy.storage.state\": { \"battery1\": { \"batteryState\": { \"chargePercentage\": [ 90, 88, 87, 91 ] } }, \"battery2\": { \"batteryState\": { \"chargePercentage\": [ 40, 42, 45, 48 ] } } } }","title":"Response"},{"location":"core_log-api/#example-4","text":"Same as example 3 except timeseries is created in CSV format.","title":"Example 4"},{"location":"core_log-api/#request_7","text":"http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/timeseries?process=battery1,battery2&topic=energy.storage.state&attrs=batteryState.chargePercentage&format=csv","title":"Request"},{"location":"core_log-api/#response_11","text":"epoch;timestamp;energy.storage.state:battery1.batteryState.chargePercentage;energy.storage.state:battery2.batteryState.chargePercentage 1;2020-06-03T13:00:00Z;90;40 1;2020-06-03T13:30:00Z;88;42 2;2020-06-03T14:00:00Z;87;45 2;2020-06-03T14:30:00Z;91;48","title":"Response"},{"location":"core_logging-system/","text":"Logging system The logging system stores each message in each simulation run to enable viewing the content later. This enables the analysis of results and debugging of problems. Requirements The identified requirements include: Store messages as such (i.e., JSON) along with the necessary metadata Metadata topic timestamp simulation ID warning cause (if any) eno (epoch ID) (message) source others? Query for and view messages based on metadata Data export In JSON In CSV Data types Time series that contain time series Time series that contain single values Collect a time series from a set of JSON docs E.g., \"I want field X.Y.Z from all messages sent to topic A during simulation run B\" Should there be a feature to either include timestamps or leave them out? Presumably, the spacing of values in time series is constant anyway, and so is the submission frequency of messages from a particular process","title":"Logging system"},{"location":"core_logging-system/#logging-system","text":"The logging system stores each message in each simulation run to enable viewing the content later. This enables the analysis of results and debugging of problems.","title":"Logging system"},{"location":"core_logging-system/#requirements","text":"The identified requirements include: Store messages as such (i.e., JSON) along with the necessary metadata Metadata topic timestamp simulation ID warning cause (if any) eno (epoch ID) (message) source others? Query for and view messages based on metadata Data export In JSON In CSV Data types Time series that contain time series Time series that contain single values Collect a time series from a set of JSON docs E.g., \"I want field X.Y.Z from all messages sent to topic A during simulation run B\" Should there be a feature to either include timestamps or leave them out? Presumably, the spacing of values in time series is constant anyway, and so is the submission frequency of messages from a particular process","title":"Requirements"},{"location":"core_logwriter/","text":"LogWriter Description LogWriter is a simulation component and it is part of the Logging System . It is used to log all the messages in a simulation run and thus an instance of LogWriter is part of every simulation run. Functionalities Listen to the message bus and catch all messages in the given exchange. Keep track of the running simulations using the given exchange and collect some metadata for each simulation. Collected metadata include at least the names of the participating processes and the timestamps for the first and the last message send during the simulation. Separate valid simulation platform messages from invalid messages that are not in JSON format or are missing one of the base attributes. Write all the simulation messages to a database. Received valid messages are stored in simulation-specific collections. Received invalid messages are stored in separate simulation-specific collections for debugging purposes. Writes the gathered simulation metadata to a database. Technical details LogWriter is written in Python (3.7.9) and the code repository is found at: https://github.com/simcesplatform/logwriter LogWriter connects to RabbitMQ message bus. Both local and remote message bus servers are supported. The used database is MongoDB with version 4.2.7 used during development. LogWriter has support for HTTPS connections for the database. LogWriter requires either admin or write access to the used database. One LogWriter instance will only listen to messages from one RabbitMQ exchange. Workflow Receive the message bus and database connection parameters upon startup. Open the connection to the message bus and start a message listener for all topics in the given exchange. Open the database connection. For each message received from the message bus: Write the message to the database. Each simulation will have their own collection of messages in the database. The collection is created when the first message for the simulation is received. The collection name for the simulation messages is \"simulation_ \". Possibly update the simulation metadata. The metadata documents are only updated after SimState or Epoch messages. Each simulation will have one metadata document in the database. The metadata documents are all collected under the same collection (called \"simulations\") in the database. If the message was SimState message indicating that the simulation is stopped, stop the LogWriter instance. Note, that originally LogWriter was made to support multiple simulations but due to specification changes, each simulation run in the SimCES platform will use a separate exchange. Thus, a separate instance of LogWriter is needed for each simulation run. Due to this LogWriter will stop once it has received the message indicating that the simulation has stopped, i.e. SimState message with the value \"stopped\", and all the received messages have been written to the database. When writing the messages to the database LogWriter uses a buffer to reduce the number of times the database is accessed. All received messages are first added to the buffer and they are only written to the database once the buffer is cleared. The message buffer will be cleared: when the latest received message was either a SimState or an Epoch message. when the maximum number of messages, by default 20, in the buffer is reached. The maximum number of messages in the buffer is configurable by the input parameter MessageBufferMaxDocumentCount . when at least 10 seconds have gone after a message was added to the buffer without the buffer having been cleared. The number of seconds is configurable by the input parameter MessageBufferMaxInterval . Input parameters Parameter name Datatype Example Default value MessageBufferMaxDocumentCount Integer (> 0) 10 20 MessageBufferMaxInterval Float (> 0) 5.0 10.0 Accessing the messages The simulation messages and data contained within them can be accessed using the LogReader part of the Logging System with the Read/Export API . To speed up the queries fetching data from the simulation messages stored in the database, LogWriter adds some indexes to both the metadata document collection as well as to the simulation specific message collections.","title":"LogWriter"},{"location":"core_logwriter/#logwriter","text":"","title":"LogWriter"},{"location":"core_logwriter/#description","text":"LogWriter is a simulation component and it is part of the Logging System . It is used to log all the messages in a simulation run and thus an instance of LogWriter is part of every simulation run.","title":"Description"},{"location":"core_logwriter/#functionalities","text":"Listen to the message bus and catch all messages in the given exchange. Keep track of the running simulations using the given exchange and collect some metadata for each simulation. Collected metadata include at least the names of the participating processes and the timestamps for the first and the last message send during the simulation. Separate valid simulation platform messages from invalid messages that are not in JSON format or are missing one of the base attributes. Write all the simulation messages to a database. Received valid messages are stored in simulation-specific collections. Received invalid messages are stored in separate simulation-specific collections for debugging purposes. Writes the gathered simulation metadata to a database.","title":"Functionalities"},{"location":"core_logwriter/#technical-details","text":"LogWriter is written in Python (3.7.9) and the code repository is found at: https://github.com/simcesplatform/logwriter LogWriter connects to RabbitMQ message bus. Both local and remote message bus servers are supported. The used database is MongoDB with version 4.2.7 used during development. LogWriter has support for HTTPS connections for the database. LogWriter requires either admin or write access to the used database. One LogWriter instance will only listen to messages from one RabbitMQ exchange.","title":"Technical details"},{"location":"core_logwriter/#workflow","text":"Receive the message bus and database connection parameters upon startup. Open the connection to the message bus and start a message listener for all topics in the given exchange. Open the database connection. For each message received from the message bus: Write the message to the database. Each simulation will have their own collection of messages in the database. The collection is created when the first message for the simulation is received. The collection name for the simulation messages is \"simulation_ \". Possibly update the simulation metadata. The metadata documents are only updated after SimState or Epoch messages. Each simulation will have one metadata document in the database. The metadata documents are all collected under the same collection (called \"simulations\") in the database. If the message was SimState message indicating that the simulation is stopped, stop the LogWriter instance. Note, that originally LogWriter was made to support multiple simulations but due to specification changes, each simulation run in the SimCES platform will use a separate exchange. Thus, a separate instance of LogWriter is needed for each simulation run. Due to this LogWriter will stop once it has received the message indicating that the simulation has stopped, i.e. SimState message with the value \"stopped\", and all the received messages have been written to the database. When writing the messages to the database LogWriter uses a buffer to reduce the number of times the database is accessed. All received messages are first added to the buffer and they are only written to the database once the buffer is cleared. The message buffer will be cleared: when the latest received message was either a SimState or an Epoch message. when the maximum number of messages, by default 20, in the buffer is reached. The maximum number of messages in the buffer is configurable by the input parameter MessageBufferMaxDocumentCount . when at least 10 seconds have gone after a message was added to the buffer without the buffer having been cleared. The number of seconds is configurable by the input parameter MessageBufferMaxInterval .","title":"Workflow"},{"location":"core_logwriter/#input-parameters","text":"Parameter name Datatype Example Default value MessageBufferMaxDocumentCount Integer (> 0) 10 20 MessageBufferMaxInterval Float (> 0) 5.0 10.0","title":"Input parameters"},{"location":"core_logwriter/#accessing-the-messages","text":"The simulation messages and data contained within them can be accessed using the LogReader part of the Logging System with the Read/Export API . To speed up the queries fetching data from the simulation messages stored in the database, LogWriter adds some indexes to both the metadata document collection as well as to the simulation specific message collections.","title":"Accessing the messages"},{"location":"core_msg-abstractmessage/","text":"AbstractMessage message This page specifies the common fields of all messages. This structure is not meaningful as a standalone message, so it is analogous to an abstract base class in object-oriented programming. JSON structure \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", Fields and multiplicity Field Type Multiplicity Explanation Type String 1 (REQUIRED) Name of the message type. This field facilitates the processing of incoming messages and possibly debugging as well. Timestamp ISO 8601; see (1) 1 (REQUIRED) The time when the message was generated SimulationId String 1 (REQUIRED) The unique identifier of the simulation run SourceProcessId String 1 (REQUIRED) The name of the process that sent the message. This MUST be unique within the simulation run. MessageId String 1 (REQUIRED) The unique ID of the message within the simulation run. This is the name of the process + a running ID. (1): Date and time MUST be included, accuracy MUST be 1 ms, time zone MUST be UTC","title":"Message - AbstractMessage"},{"location":"core_msg-abstractmessage/#abstractmessage-message","text":"This page specifies the common fields of all messages. This structure is not meaningful as a standalone message, so it is analogous to an abstract base class in object-oriented programming.","title":"AbstractMessage message"},{"location":"core_msg-abstractmessage/#json-structure","text":"\"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\",","title":"JSON structure"},{"location":"core_msg-abstractmessage/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation Type String 1 (REQUIRED) Name of the message type. This field facilitates the processing of incoming messages and possibly debugging as well. Timestamp ISO 8601; see (1) 1 (REQUIRED) The time when the message was generated SimulationId String 1 (REQUIRED) The unique identifier of the simulation run SourceProcessId String 1 (REQUIRED) The name of the process that sent the message. This MUST be unique within the simulation run. MessageId String 1 (REQUIRED) The unique ID of the message within the simulation run. This is the name of the process + a running ID. (1): Date and time MUST be included, accuracy MUST be 1 ms, time zone MUST be UTC","title":"Fields and multiplicity"},{"location":"core_msg-abstractresult/","text":"AbstractResult message This page specifies the common base of all messages that represent a value calculated, measured or generated in a process. This structure is not meaningful as a standalone message, so it is analogous to an abstract base class in object-oriented programming. JSON structure (Fields of AbstractMessage must appear too!) \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], Fields and multiplicity Field Type Multiplicity Explanation (All fields from AbstractMessage ) Fields from the \"abstract base class\" EpochNumber UInt 1 (REQUIRED) Indicates the running ID of the epoch IterationStatus String 0..1; see (1) Indicates the status of iteration, either \"intermediate\" or \"final\" LastUpdatedInEpoch UInt 0..1 (OPTIONAL) Indicates the epoch number when this information was last updated; see (2) TriggeringMessageIds Array of strings 1..* (at least one REQUIRED) The ID of messages that were involved in triggering the calculation of this result Warnings Array of strings * (OPTIONAL) Indicates any warnings that occurred while resolving the Result; see (4) (1): This field is REQUIRED if the component participates in iteration. Otherwise, this field SHOULD be omitted. (2): If this field is not present, the recipient SHOULD consider that the information was updated in the current epoch. (3) This MUST include the triggering message that was received last This SHOULD include Epoch message if it is among triggering messages As long as the obligatory messages are there, the designer of each process can consider which additional messages to include. This field can be irrelevant in the Epoch message. (Alternatively, Epoch could include the Result received last.) (4): See the explanation of causes below. The process SHOULD omit the entire array if no warnings are relevant. Warning causes Each warning MUST specify a cause. The cause MUST either belong to base causes or be a user-defined cause. Base causes The following specifies the base causes. Each base cause has two parts, (1) \"warning\" followed by period as the separator and (2) a descriptive set of words separated with hyphens. warning.convergence The calculation failed to converge, or the control has not completely finished. The outcome is either is a default value or calculated with some secondary logic. warning.input Input is somehow invalid. warning.input-range One or more inputs are out of range. warning.input-unreliable Input is unreliable, because the data source (e.g., another process) has indicated a warning. warning.internal There is something wrong with the internal functionality of the process. warning.other Other reason; the processes SHOULD NOT use this in the output. Open issues Should there be more information about the warnings, e.g., a more elaborate description for humans to read?","title":"Message - AbstractResult"},{"location":"core_msg-abstractresult/#abstractresult-message","text":"This page specifies the common base of all messages that represent a value calculated, measured or generated in a process. This structure is not meaningful as a standalone message, so it is analogous to an abstract base class in object-oriented programming.","title":"AbstractResult message"},{"location":"core_msg-abstractresult/#json-structure","text":"(Fields of AbstractMessage must appear too!) \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ],","title":"JSON structure"},{"location":"core_msg-abstractresult/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation (All fields from AbstractMessage ) Fields from the \"abstract base class\" EpochNumber UInt 1 (REQUIRED) Indicates the running ID of the epoch IterationStatus String 0..1; see (1) Indicates the status of iteration, either \"intermediate\" or \"final\" LastUpdatedInEpoch UInt 0..1 (OPTIONAL) Indicates the epoch number when this information was last updated; see (2) TriggeringMessageIds Array of strings 1..* (at least one REQUIRED) The ID of messages that were involved in triggering the calculation of this result Warnings Array of strings * (OPTIONAL) Indicates any warnings that occurred while resolving the Result; see (4) (1): This field is REQUIRED if the component participates in iteration. Otherwise, this field SHOULD be omitted. (2): If this field is not present, the recipient SHOULD consider that the information was updated in the current epoch. (3) This MUST include the triggering message that was received last This SHOULD include Epoch message if it is among triggering messages As long as the obligatory messages are there, the designer of each process can consider which additional messages to include. This field can be irrelevant in the Epoch message. (Alternatively, Epoch could include the Result received last.) (4): See the explanation of causes below. The process SHOULD omit the entire array if no warnings are relevant.","title":"Fields and multiplicity"},{"location":"core_msg-abstractresult/#warning-causes","text":"Each warning MUST specify a cause. The cause MUST either belong to base causes or be a user-defined cause.","title":"Warning causes"},{"location":"core_msg-abstractresult/#base-causes","text":"The following specifies the base causes. Each base cause has two parts, (1) \"warning\" followed by period as the separator and (2) a descriptive set of words separated with hyphens.","title":"Base causes"},{"location":"core_msg-abstractresult/#warningconvergence","text":"The calculation failed to converge, or the control has not completely finished. The outcome is either is a default value or calculated with some secondary logic.","title":"warning.convergence"},{"location":"core_msg-abstractresult/#warninginput","text":"Input is somehow invalid.","title":"warning.input"},{"location":"core_msg-abstractresult/#warninginput-range","text":"One or more inputs are out of range.","title":"warning.input-range"},{"location":"core_msg-abstractresult/#warninginput-unreliable","text":"Input is unreliable, because the data source (e.g., another process) has indicated a warning.","title":"warning.input-unreliable"},{"location":"core_msg-abstractresult/#warninginternal","text":"There is something wrong with the internal functionality of the process.","title":"warning.internal"},{"location":"core_msg-abstractresult/#warningother","text":"Other reason; the processes SHOULD NOT use this in the output.","title":"warning.other"},{"location":"core_msg-abstractresult/#open-issues","text":"Should there be more information about the warnings, e.g., a more elaborate description for humans to read?","title":"Open issues"},{"location":"core_msg-epoch/","text":"Epoch message This page specifies the \"Epoch\" message. JSON structure { (Fields of AbstractMessage and AbstractResult must appear too!) \"StartTime\" : \"2020-06-03T13:00:00Z\", \"EndTime\" : \"2020-06-03T14:00:00Z\" } Fields and multiplicity Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" StartTime ISO 8601 (Date and time, UTC zone) 1 (REQUIRED) Simulated start time of the epoch EndTime ISO 8601 (Date and time, UTC zone) 1 (REQUIRED) Simulated end time of the epoch","title":"Message - Epoch"},{"location":"core_msg-epoch/#epoch-message","text":"This page specifies the \"Epoch\" message.","title":"Epoch message"},{"location":"core_msg-epoch/#json-structure","text":"{ (Fields of AbstractMessage and AbstractResult must appear too!) \"StartTime\" : \"2020-06-03T13:00:00Z\", \"EndTime\" : \"2020-06-03T14:00:00Z\" }","title":"JSON structure"},{"location":"core_msg-epoch/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" StartTime ISO 8601 (Date and time, UTC zone) 1 (REQUIRED) Simulated start time of the epoch EndTime ISO 8601 (Date and time, UTC zone) 1 (REQUIRED) Simulated end time of the epoch","title":"Fields and multiplicity"},{"location":"core_msg-simstate/","text":"SimState message This message notifies about starting and ending a simulation run. JSON structure { (Fields of AbstractMessage and AbstractResult must appear too!) \"SimulationState\" : \"running\", \"Name\" : \"Name of the simulation\", \"Description\" : \"Longer description about the simulation\" } Fields and multiplicity Field Type Multiplicity Explanation (All fields from AbstractMessage ) Fields from the \"abstract base class\" SimulationState String 1 (REQUIRED) Simulation state, either \"running\" or \"stopped\" Name String 0..1 (OPTIONAL) A human-friendly name for the simulation Description String 0..1 (OPTIONAL) A longer description of the simulation run meant for humans","title":"Message - SimState"},{"location":"core_msg-simstate/#simstate-message","text":"This message notifies about starting and ending a simulation run.","title":"SimState message"},{"location":"core_msg-simstate/#json-structure","text":"{ (Fields of AbstractMessage and AbstractResult must appear too!) \"SimulationState\" : \"running\", \"Name\" : \"Name of the simulation\", \"Description\" : \"Longer description about the simulation\" }","title":"JSON structure"},{"location":"core_msg-simstate/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation (All fields from AbstractMessage ) Fields from the \"abstract base class\" SimulationState String 1 (REQUIRED) Simulation state, either \"running\" or \"stopped\" Name String 0..1 (OPTIONAL) A human-friendly name for the simulation Description String 0..1 (OPTIONAL) A longer description of the simulation run meant for humans","title":"Fields and multiplicity"},{"location":"core_msg-start/","text":"Start message This message notifies components about the startup of a simulation run, delivering simulation-run-specific parameters. JSON structure { \"Type\" : \"Start\", \"Timestamp\" : \"2020-08-31T04:04:21.045Z\", \"SimulationId\" : \"set-simulation-id-here\", \"SimulationSpecificExchange\" : \"set-exchange-name-here\", \"SimulationName\" : \"set-name-here\", \"SimulationDescription\" : \"set-description-here\", \"ProcessParameters\" : { \"SimulationManager\": // There is only one Simulation Manager for each simulation run { \"ManagerName\": \"Manager\", \"InitialStartTime\": \"2020-06-28T00:00:00.000Z\", \"EpochLength\": 3600, \"MaxEpochCount\": 24, \"Components\": [ \"Load1\", \"Load2\", \"Generator\", \"GridA\" ], \"EpochTimerInterval\": 120.0, // optional \"MaxEpochResendCount\": 5 // optional }, \"LogWriter\": // There is only one Log Writer for each simulation run { \"MessageBufferMaxDocumentCount\": 10, // optional, default is 20 \"MessageBufferMaxInterval\": 5.0 // optional, default is 10.0 }, \"Dummy\": // Include this if relevant { \"DummyA\": // The identifier for the dummy component { \"MinSleepTime\": 1.0, // optional, default is 2.0 \"MaxSleepTime\": 2.5, // optional, default is 15.0 \"WarningChance\": 0.0, // optional, default is 0.0 \"SendMissChance\": 0.0, // optional, default is 0.0 \"ReceiveMissChance\": 0.0, // optional, default is 0.0 \"ErrorChance\": 0.0, // optional, default is 0.0 } }, \"StaticTimeSeriesResource\": // Example parameters for a component { \"LoadA\": // The identifier for the resource { \"ResourceType\": \"Load\", \"ResourceStateFile\": \"load.csv\" }, \"GeneratorA\": { \"ResourceType\": \"Generator\", \"ResourceStateFile\": \"generator.csv\" } } } } Fields and multiplicity Field Type Multiplicity Explanation Type String 1 (REQUIRED) The name of the message type. For Start message this MUST be equal to \"Start\". Timestamp ISO 8601; see (1) 1 (REQUIRED) The time when the message was generated SimulationId String 1 (REQUIRED) The unique identifier of the simulation run, first published in this message (i.e., specified by the sender). SimulationSpecificExchange String 1 (REQUIRED) The name of the simulation-specific Exchange that will be the channel to communicate simulation-run-specific messages SimulationName String 0..1 (OPTIONAL) A human-readable name to help in identifying the simulation run SimulationDescription String 0..1 (OPTIONAL) A human-readable description to help in identifying the simulation run ProcessParameters Object that contains other objects 0..1 (OPTIONAL) Specifies any process-specific parameters; see (2) (1) Date and time included Accuracy 1 ms UTC zone (2): REQUIRED if there are any process-specific parameters to deliver. For each object, the name is a string that matches to the identifier of the process referred to. The value is a structure defined in \"process parameter blocks\" section. Process parameter blocks This section explains the process parameter blocks used by platform core. This excludes any domain-specific blocks. Note: the Platform Manager passes these parameters directly to the Simulation Manager instance through environmental variables. They are included as part of the Start message to make the used parameters visible to the other components as well as to the Logging System. Simulation Manager block Field Type Multiplicity Explanation ManagerName String 1 (REQUIRED) The identifier, i.e. the SourceProcessId, for the Simulation Manager instance. InitialStartTime ISO 8601; see (a) 1 (REQUIRED) The start time for the first epoch as ISO 8601 formatted datetime string. EpochLength Integer (> 0) 1 (REQUIRED) The epoch length in seconds. MaxEpochCount Integer (> 0) 1 (REQUIRED) The maximum number of epochs in the simulation run. Components Array of strings 1..* (at least one REQUIRED) An array of the names of the components participating in the simulation. The names MUST correspond to the identifiers (i.e. the SourceProcessId) used by the components. EpochTimerInterval Float 0..1 (OPTIONAL) The time interval in seconds until Simulation Manager resends an Epoch message if some component has not responded with Status message. The default value is 120 seconds. MaxEpochResendCount Integer 0..1 (OPTIONAL) The maximum number of Epoch message resends Simulation Manager can try. The default value is 5 resends. (a) Date and time included Accuracy 1 ms Time zone information MUST be included Log Writer block Field Type Multiplicity Explanation MessageBufferMaxDocumentCount Integer (> 0) 1 (OPTIONAL) The maximum number of messages the buffer in Log Writer can hold before the messages are written to the database and the buffer is cleared. The default value is 20. MessageBufferMaxInterval Float 1 (OPTIONAL) The maximum time interval in seconds before the message buffer in Log Writer is cleared and the messages written to the database. The default value is 10 seconds. Dummy Component block Field Type Multiplicity Explanation MinSleepTime Float 1 (OPTIONAL) The minimum time in seconds the Dummy component waits after receiving an Epoch message before sending the Status message. The default value is 2 seconds. MaxSleepTime Float 1 (OPTIONAL) The maximum time in seconds the Dummy component waits after receiving an Epoch message before sending the Status message. The default value is 15 seconds. WarningChance Float 1 (OPTIONAL) The probability that a warning is included in the Status message sent to the Simulation Manager. 1 means that a warning is always included and 0 means that a warning is never included. The default value is 0. SendMissChance Float 1 (OPTIONAL) The probability that the Dummy component does not send the Status message after processing the epoch to the simulation manager. 1 means that the Status messages are never sent and 0 means that they are always sent. The default value is 0. ReceiveMissChance Float 1 (OPTIONAL) The probability that the Dummy component ignores a received Epoch message. 1 means that the Epoch messages are always ignored and 0 means that they are never ignored. The default value is 0. ErrorChance Float 1 (OPTIONAL) The probability that the Dummy component sends an error message after a received Epoch message. 1 means that an error message is always sent and 0 means that an error message is never included. The default value is 0.","title":"Message - Start"},{"location":"core_msg-start/#start-message","text":"This message notifies components about the startup of a simulation run, delivering simulation-run-specific parameters.","title":"Start message"},{"location":"core_msg-start/#json-structure","text":"{ \"Type\" : \"Start\", \"Timestamp\" : \"2020-08-31T04:04:21.045Z\", \"SimulationId\" : \"set-simulation-id-here\", \"SimulationSpecificExchange\" : \"set-exchange-name-here\", \"SimulationName\" : \"set-name-here\", \"SimulationDescription\" : \"set-description-here\", \"ProcessParameters\" : { \"SimulationManager\": // There is only one Simulation Manager for each simulation run { \"ManagerName\": \"Manager\", \"InitialStartTime\": \"2020-06-28T00:00:00.000Z\", \"EpochLength\": 3600, \"MaxEpochCount\": 24, \"Components\": [ \"Load1\", \"Load2\", \"Generator\", \"GridA\" ], \"EpochTimerInterval\": 120.0, // optional \"MaxEpochResendCount\": 5 // optional }, \"LogWriter\": // There is only one Log Writer for each simulation run { \"MessageBufferMaxDocumentCount\": 10, // optional, default is 20 \"MessageBufferMaxInterval\": 5.0 // optional, default is 10.0 }, \"Dummy\": // Include this if relevant { \"DummyA\": // The identifier for the dummy component { \"MinSleepTime\": 1.0, // optional, default is 2.0 \"MaxSleepTime\": 2.5, // optional, default is 15.0 \"WarningChance\": 0.0, // optional, default is 0.0 \"SendMissChance\": 0.0, // optional, default is 0.0 \"ReceiveMissChance\": 0.0, // optional, default is 0.0 \"ErrorChance\": 0.0, // optional, default is 0.0 } }, \"StaticTimeSeriesResource\": // Example parameters for a component { \"LoadA\": // The identifier for the resource { \"ResourceType\": \"Load\", \"ResourceStateFile\": \"load.csv\" }, \"GeneratorA\": { \"ResourceType\": \"Generator\", \"ResourceStateFile\": \"generator.csv\" } } } }","title":"JSON structure"},{"location":"core_msg-start/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation Type String 1 (REQUIRED) The name of the message type. For Start message this MUST be equal to \"Start\". Timestamp ISO 8601; see (1) 1 (REQUIRED) The time when the message was generated SimulationId String 1 (REQUIRED) The unique identifier of the simulation run, first published in this message (i.e., specified by the sender). SimulationSpecificExchange String 1 (REQUIRED) The name of the simulation-specific Exchange that will be the channel to communicate simulation-run-specific messages SimulationName String 0..1 (OPTIONAL) A human-readable name to help in identifying the simulation run SimulationDescription String 0..1 (OPTIONAL) A human-readable description to help in identifying the simulation run ProcessParameters Object that contains other objects 0..1 (OPTIONAL) Specifies any process-specific parameters; see (2) (1) Date and time included Accuracy 1 ms UTC zone (2): REQUIRED if there are any process-specific parameters to deliver. For each object, the name is a string that matches to the identifier of the process referred to. The value is a structure defined in \"process parameter blocks\" section.","title":"Fields and multiplicity"},{"location":"core_msg-start/#process-parameter-blocks","text":"This section explains the process parameter blocks used by platform core. This excludes any domain-specific blocks. Note: the Platform Manager passes these parameters directly to the Simulation Manager instance through environmental variables. They are included as part of the Start message to make the used parameters visible to the other components as well as to the Logging System.","title":"Process parameter blocks"},{"location":"core_msg-start/#simulation-manager-block","text":"Field Type Multiplicity Explanation ManagerName String 1 (REQUIRED) The identifier, i.e. the SourceProcessId, for the Simulation Manager instance. InitialStartTime ISO 8601; see (a) 1 (REQUIRED) The start time for the first epoch as ISO 8601 formatted datetime string. EpochLength Integer (> 0) 1 (REQUIRED) The epoch length in seconds. MaxEpochCount Integer (> 0) 1 (REQUIRED) The maximum number of epochs in the simulation run. Components Array of strings 1..* (at least one REQUIRED) An array of the names of the components participating in the simulation. The names MUST correspond to the identifiers (i.e. the SourceProcessId) used by the components. EpochTimerInterval Float 0..1 (OPTIONAL) The time interval in seconds until Simulation Manager resends an Epoch message if some component has not responded with Status message. The default value is 120 seconds. MaxEpochResendCount Integer 0..1 (OPTIONAL) The maximum number of Epoch message resends Simulation Manager can try. The default value is 5 resends. (a) Date and time included Accuracy 1 ms Time zone information MUST be included","title":"Simulation Manager block"},{"location":"core_msg-start/#log-writer-block","text":"Field Type Multiplicity Explanation MessageBufferMaxDocumentCount Integer (> 0) 1 (OPTIONAL) The maximum number of messages the buffer in Log Writer can hold before the messages are written to the database and the buffer is cleared. The default value is 20. MessageBufferMaxInterval Float 1 (OPTIONAL) The maximum time interval in seconds before the message buffer in Log Writer is cleared and the messages written to the database. The default value is 10 seconds.","title":"Log Writer block"},{"location":"core_msg-start/#dummy-component-block","text":"Field Type Multiplicity Explanation MinSleepTime Float 1 (OPTIONAL) The minimum time in seconds the Dummy component waits after receiving an Epoch message before sending the Status message. The default value is 2 seconds. MaxSleepTime Float 1 (OPTIONAL) The maximum time in seconds the Dummy component waits after receiving an Epoch message before sending the Status message. The default value is 15 seconds. WarningChance Float 1 (OPTIONAL) The probability that a warning is included in the Status message sent to the Simulation Manager. 1 means that a warning is always included and 0 means that a warning is never included. The default value is 0. SendMissChance Float 1 (OPTIONAL) The probability that the Dummy component does not send the Status message after processing the epoch to the simulation manager. 1 means that the Status messages are never sent and 0 means that they are always sent. The default value is 0. ReceiveMissChance Float 1 (OPTIONAL) The probability that the Dummy component ignores a received Epoch message. 1 means that the Epoch messages are always ignored and 0 means that they are never ignored. The default value is 0. ErrorChance Float 1 (OPTIONAL) The probability that the Dummy component sends an error message after a received Epoch message. 1 means that an error message is always sent and 0 means that an error message is never included. The default value is 0.","title":"Dummy Component block"},{"location":"core_msg-status/","text":"Status message JSON structure Ready message { (Fields of AbstractMessage and AbstractResult must appear too!) \"Value\" : \"ready\" } Error message { (Fields of AbstractMessage and AbstractResult must appear too!) \"Value\" : \"error\", \"Description\" : \"Cannot calculate: expected pea soup because it is Thursday\" } Fields and multiplicity Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" Value String 1 (REQUIRED) The status value being reported. This MUST be one of the following: \"ready\" or \"error\". Description String 0..1 (OPTIONAL) Status description; see (1) (1) If Value is \"ready\", this field SHOULD be omitted. If Value is \"error\", this field SHOULD contain a description what went wrong.","title":"Message - Status"},{"location":"core_msg-status/#status-message","text":"","title":"Status message"},{"location":"core_msg-status/#json-structure","text":"","title":"JSON structure"},{"location":"core_msg-status/#ready-message","text":"{ (Fields of AbstractMessage and AbstractResult must appear too!) \"Value\" : \"ready\" }","title":"Ready message"},{"location":"core_msg-status/#error-message","text":"{ (Fields of AbstractMessage and AbstractResult must appear too!) \"Value\" : \"error\", \"Description\" : \"Cannot calculate: expected pea soup because it is Thursday\" }","title":"Error message"},{"location":"core_msg-status/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" Value String 1 (REQUIRED) The status value being reported. This MUST be one of the following: \"ready\" or \"error\". Description String 0..1 (OPTIONAL) Status description; see (1) (1) If Value is \"ready\", this field SHOULD be omitted. If Value is \"error\", this field SHOULD contain a description what went wrong.","title":"Fields and multiplicity"},{"location":"core_msg/","text":"Message structures (core) This page gathers all message structures of the platform core. Type inheritance To save the re-use of specifications and software, the message structures apply inheritance similar to object-oriented programming. This is illustrated in the following figure: AbstractMessage is the base class of all messages All messages MUST inherit fields from this The direct descendants are: SimState AbstractResult AbstractResult represents the result (i.e., output) of a process All messages that carry a result MUST inherit the fields of AbstractResult The direct descendants are at least: Epoch Status All actual result messages Re-usable blocks Certain structures are generic and re-usable in multiple message structures. These are explained in the following table. Structure Description Quantity array block Contains an array of quantity values with a unit of measure. Quantity block Contains a quantity value with a unit of measure. Time series block Contains one or more time series.","title":"Message structures (core)"},{"location":"core_msg/#message-structures-core","text":"This page gathers all message structures of the platform core.","title":"Message structures (core)"},{"location":"core_msg/#type-inheritance","text":"To save the re-use of specifications and software, the message structures apply inheritance similar to object-oriented programming. This is illustrated in the following figure: AbstractMessage is the base class of all messages All messages MUST inherit fields from this The direct descendants are: SimState AbstractResult AbstractResult represents the result (i.e., output) of a process All messages that carry a result MUST inherit the fields of AbstractResult The direct descendants are at least: Epoch Status All actual result messages","title":"Type inheritance"},{"location":"core_msg/#re-usable-blocks","text":"Certain structures are generic and re-usable in multiple message structures. These are explained in the following table. Structure Description Quantity array block Contains an array of quantity values with a unit of measure. Quantity block Contains a quantity value with a unit of measure. Time series block Contains one or more time series.","title":"Re-usable blocks"},{"location":"core_msgtype/","text":"Message type names (core) This page specifies the message type names to appear in messages. I.e., these values should appear in the \"Type\" field of each message. Message Type name (case sensitive) Epoch Epoch SimState SimState Start Start Status Status","title":"Message type names (core)"},{"location":"core_msgtype/#message-type-names-core","text":"This page specifies the message type names to appear in messages. I.e., these values should appear in the \"Type\" field of each message. Message Type name (case sensitive) Epoch Epoch SimState SimState Start Start Status Status","title":"Message type names (core)"},{"location":"core_platform-settings/","text":"Configuring platform settings There are two collections of settings: General platform level settings that affect the background components like Log Reader and require running the installation script to take an effect Simulation run specific settings that affect the future simulation runs and can be changed without running the installation script General platform level settings The default settings for the platform are fine for local testing. If there is a need to connect to remote resources like a remote RabbitMQ message bus so that externally managed components that have not been locally deployed can participate in the simulations, some platform level settings must be modified. There are 6 different files that define the settings for the core platform. They are all listed in the table below with the details given in the subsections. Only the the parameters that might require changing are described here. The default files contain comments for all settings. For any changes to these files to have an effect, the platform core setup script must be run, see the step 6 at page Installation . Configuration file Description background/env/components_mongodb.env The MongoDB connection settings used by Log Reader and the instance of Log Writer that is listening to the management exchange . background/env/components_logwriter.env Additional settings for the instance of Log Writer that is listening to the management exchange . Includes the RabbitMQ connection settings, logging level settings and other Log Writer specific settings. background/env/rabbitmq.env Settings for the locally deployed RabbitMQ message bus instance. background/env/mongodb.env Settings for the locally deployed MongoDB database instance. background/env/mongo_express.env Settings for the locally deployed Mongo Express instance that can be used to access the MongoDB and the messages from the simulations directly. background/docker-compose-background.yml The Docker Compose file that is used to deploy all the core platform components. The locally used ports can be changed by modifying this file. background/env/components_mongodb.env MongoDB connection settings for Log Reader and the instance of of Log Writer that is listening to the management exchange : Variable name Default Description MONGODB_HOST simces_mongodb The host name for MongoDB. Can also be Docker container name for a container in the same Docker network as the Platform Manager. MONGODB_PORT 27017 The port number for MongoDB. MONGODB_USERNAME The username for MongoDB. If this is empty, no access control is assumed to be in use. MONGODB_PASSWORD The password for MongoDB. MONGODB_ADMIN true Whether the account given in MONGODB_USERNAME has root access or not. Ignored if MONGODB_USERNAME is empty. (true/false) MONGODB_TLS false Whether the connection to MongoDB is secured or not (true/false) MONGODB_TLS_ALLOW_INVALID_CERTIFICATES false Whether to allow invalid security certificates. Ignored if MONGO_TLS is false. (true/false) The default file can be found at: background/env/components_mongodb.env background/env/components_logwriter.env Settings for the instance of Log Writer that is listening to the management exchange . Includes the RabbitMQ connection settings, logging level settings and other Log Writer specific settings. Variable name Default Description SIMULATION_LOG_LEVEL 20 The logging level for which the logging messages are included in the output of the components. 30 to include only warnings and errors, 20 to include also info messages, and 10 to include the debug messages as well. RABBITMQ_HOST simces_rabbitmq The host name for the RabbitMQ message bus. Can also be Docker container name for a container in the same Docker network as the Platform Manager. RABBITMQ_PORT 5672 The port number for the RabbitMQ message bus. RABBITMQ_LOGIN The username for the RabbitMQ message bus. If this is empty, the default username, guest . is used. RABBITMQ_PASSWORD The password for the RabbitMQ message bus. If this is empty, the default password, guest . is used. RABBITMQ_SSL false Whether the connection to the RabbitMQ message bus is secured or not (true/false) RABBITMQ_SSL_VERSION PROTOCOL_TLS The security protocol used in the RabbitMQ message bus connection. Only considered if RABBITMQ_SSL is true. The default file can be found at: background/env/components_logwriter.env background/env/rabbitmq.env Settings for the locally deployed RabbitMQ message bus instance. Variable name Default Description RABBITMQ_DEFAULT_USER The username for the local RabbitMQ instance. If this is empty, the default username, guest . is used. RABBITMQ_DEFAULT_PASS The password for the local RabbitMQ instance. If this is empty, the default password, guest . is used. The default file can be found at: background/env/rabbitmq.env background/env/mongodb.env Variable name Default Description MONGO_INITDB_ROOT_USERNAME The username for root access to the local MongoDB instance. If this is empty, no access control is used. MONGO_INITDB_ROOT_PASSWORD The password for root access to the local MongoDB instance The default file can be found at: background/env/mongodb.env background/env/mongo_express.env The settings for Mongo Express. Variable name Default Description ME_CONFIG_MONGODB_SERVER simces_mongodb The host name for MongoDB. Can also be Docker container name for a container in the same Docker network as the Platform Manager. ME_CONFIG_MONGODB_PORT 27017 The port number for MongoDB. ME_CONFIG_MONGODB_ENABLE_ADMIN true Whether admin access is allowed though the Mongo Express interface (true/false) ME_CONFIG_MONGODB_ADMINUSERNAME The admin username for MongoDB. If this is empty and ME_CONFIG_MONGODB_ENABLE_ADMIN is true, no access control is assumed to be in use. ME_CONFIG_MONGODB_ADMINPASSWORD The admin password for MongoDB. ME_CONFIG_MONGODB_AUTH_DATABASE logs if ME_CONFIG_MONGODB_ENABLE_ADMIN is false, the database that is used to authenticate the MongoDB user ME_CONFIG_MONGODB_AUTH_USERNAME The username for non-admin user in MongoDB. ME_CONFIG_MONGODB_AUTH_PASSWORD The password for non-admin user in MongoDB. ME_CONFIG_MONGODB_SSL false Whether the connection to MongoDB is secured or not (true/false) ME_CONFIG_BASICAUTH_USERNAME The username asked by the Mongo Express web interface ME_CONFIG_BASICAUTH_PASSWORD The password asked by the Mongo Express web interface The default file can be found at: background/env/mongo_express.env background/docker-compose-background.yml Some local ports are used by the platform. The default ports are listed in the table below: Component Default port(s) Log Reader 8080 Mongo Express 8081 RabbitMQ 5672 and 15672 The used port numbers can be changed by modifying the Docker Compose file by changing the number in the relevant section. For example to change the locally deployed Log Reader to use port 8555 instead of the default 8080, the Log Reader section of the file should be changed to the following: log_reader: image: ghcr.io/simcesplatform/logreader container_name: simces_log_reader restart: always depends_on: - mongodb env_file: - env/components_mongodb.env environment: - MONGODB_APPNAME=log_writer ports: - 8555:8080 # here a change from 8080:8080 to 8555:8080 networks: - mongodb_network The default file can be found at: background/docker-compose-background.yml Simulation run specific settings The simulation configuration YAML file is the main configuration for each simulation run. However, for the communication to work some environment settings must be configured properly. The environment variables are passed to Platform Manager when a new simulation run is started. They are given in 3 environment variable files: common.env (for some common settings), rabbitmq.env (for the connection details for RabbitMQ) and mongodb.env (for connection details for MongoDB). All of the common and RabbitMQ parameters are passed to the platform managed components when a new simulation run is started. In addition, the simulation run specific Log Writer instance also receives the MongoDB settings. Some of the parameters are described here. For the parameters not described here there are descriptive comments in the files themselves. common.env Common settings for all simulation components: Variable name Default Description SIMULATION_LOG_LEVEL 20 The logging level for which the logging messages are included in the output of the components. 30 to include only warnings and errors, 20 to include also info messages, and 10 to include the debug messages as well. The default file can be found at: common.env rabbitmq.env RabbitMQ connection settings for a new simulation run: Variable name Default Description RABBITMQ_HOST simces_rabbitmq The host name for the RabbitMQ message bus. Can also be Docker container name for a container in the same Docker network as the Platform Manager. RABBITMQ_PORT 5672 The port number for the RabbitMQ message bus. RABBITMQ_LOGIN The username for the RabbitMQ message bus. If this is empty, the default username, guest . is used. RABBITMQ_PASSWORD The password for the RabbitMQ message bus. If this is empty, the default password, guest . is used. RABBITMQ_SSL false Whether the connection to the RabbitMQ message bus is secured or not (true/false) RABBITMQ_SSL_VERSION PROTOCOL_TLS The security protocol used in the RabbitMQ message bus connection. Only considered if RABBITMQ_SSL is true. The default file can be found at: rabbitmq.env mongodb.env MongoDB connection settings for a new simulation run: Variable name Default Description MONGODB_HOST simces_mongodb The host name for MongoDB. Can also be Docker container name for a container in the same Docker network as the Platform Manager. MONGODB_PORT 27017 The port number for MongoDB. MONGODB_USERNAME The username for MongoDB. If this is empty, no access control is assumed to be in use. MONGODB_PASSWORD The password for MongoDB. MONGODB_ADMIN true Whether the account given in MONGODB_USERNAME has root access or not. Ignored if MONGODB_USERNAME is empty. (true/false) MONGODB_TLS false Whether the connection to MongoDB is secured or not (true/false) MONGODB_TLS_ALLOW_INVALID_CERTIFICATES false Whether to allow invalid security certificates. Ignored if MONGO_TLS is false. (true/false) The default file can be found at: mongodb.env","title":"Configuring settings"},{"location":"core_platform-settings/#configuring-platform-settings","text":"There are two collections of settings: General platform level settings that affect the background components like Log Reader and require running the installation script to take an effect Simulation run specific settings that affect the future simulation runs and can be changed without running the installation script","title":"Configuring platform settings"},{"location":"core_platform-settings/#general-platform-level-settings","text":"The default settings for the platform are fine for local testing. If there is a need to connect to remote resources like a remote RabbitMQ message bus so that externally managed components that have not been locally deployed can participate in the simulations, some platform level settings must be modified. There are 6 different files that define the settings for the core platform. They are all listed in the table below with the details given in the subsections. Only the the parameters that might require changing are described here. The default files contain comments for all settings. For any changes to these files to have an effect, the platform core setup script must be run, see the step 6 at page Installation . Configuration file Description background/env/components_mongodb.env The MongoDB connection settings used by Log Reader and the instance of Log Writer that is listening to the management exchange . background/env/components_logwriter.env Additional settings for the instance of Log Writer that is listening to the management exchange . Includes the RabbitMQ connection settings, logging level settings and other Log Writer specific settings. background/env/rabbitmq.env Settings for the locally deployed RabbitMQ message bus instance. background/env/mongodb.env Settings for the locally deployed MongoDB database instance. background/env/mongo_express.env Settings for the locally deployed Mongo Express instance that can be used to access the MongoDB and the messages from the simulations directly. background/docker-compose-background.yml The Docker Compose file that is used to deploy all the core platform components. The locally used ports can be changed by modifying this file.","title":"General platform level settings"},{"location":"core_platform-settings/#backgroundenvcomponents_mongodbenv","text":"MongoDB connection settings for Log Reader and the instance of of Log Writer that is listening to the management exchange : Variable name Default Description MONGODB_HOST simces_mongodb The host name for MongoDB. Can also be Docker container name for a container in the same Docker network as the Platform Manager. MONGODB_PORT 27017 The port number for MongoDB. MONGODB_USERNAME The username for MongoDB. If this is empty, no access control is assumed to be in use. MONGODB_PASSWORD The password for MongoDB. MONGODB_ADMIN true Whether the account given in MONGODB_USERNAME has root access or not. Ignored if MONGODB_USERNAME is empty. (true/false) MONGODB_TLS false Whether the connection to MongoDB is secured or not (true/false) MONGODB_TLS_ALLOW_INVALID_CERTIFICATES false Whether to allow invalid security certificates. Ignored if MONGO_TLS is false. (true/false) The default file can be found at: background/env/components_mongodb.env","title":"background/env/components_mongodb.env"},{"location":"core_platform-settings/#backgroundenvcomponents_logwriterenv","text":"Settings for the instance of Log Writer that is listening to the management exchange . Includes the RabbitMQ connection settings, logging level settings and other Log Writer specific settings. Variable name Default Description SIMULATION_LOG_LEVEL 20 The logging level for which the logging messages are included in the output of the components. 30 to include only warnings and errors, 20 to include also info messages, and 10 to include the debug messages as well. RABBITMQ_HOST simces_rabbitmq The host name for the RabbitMQ message bus. Can also be Docker container name for a container in the same Docker network as the Platform Manager. RABBITMQ_PORT 5672 The port number for the RabbitMQ message bus. RABBITMQ_LOGIN The username for the RabbitMQ message bus. If this is empty, the default username, guest . is used. RABBITMQ_PASSWORD The password for the RabbitMQ message bus. If this is empty, the default password, guest . is used. RABBITMQ_SSL false Whether the connection to the RabbitMQ message bus is secured or not (true/false) RABBITMQ_SSL_VERSION PROTOCOL_TLS The security protocol used in the RabbitMQ message bus connection. Only considered if RABBITMQ_SSL is true. The default file can be found at: background/env/components_logwriter.env","title":"background/env/components_logwriter.env"},{"location":"core_platform-settings/#backgroundenvrabbitmqenv","text":"Settings for the locally deployed RabbitMQ message bus instance. Variable name Default Description RABBITMQ_DEFAULT_USER The username for the local RabbitMQ instance. If this is empty, the default username, guest . is used. RABBITMQ_DEFAULT_PASS The password for the local RabbitMQ instance. If this is empty, the default password, guest . is used. The default file can be found at: background/env/rabbitmq.env","title":"background/env/rabbitmq.env"},{"location":"core_platform-settings/#backgroundenvmongodbenv","text":"Variable name Default Description MONGO_INITDB_ROOT_USERNAME The username for root access to the local MongoDB instance. If this is empty, no access control is used. MONGO_INITDB_ROOT_PASSWORD The password for root access to the local MongoDB instance The default file can be found at: background/env/mongodb.env","title":"background/env/mongodb.env"},{"location":"core_platform-settings/#backgroundenvmongo_expressenv","text":"The settings for Mongo Express. Variable name Default Description ME_CONFIG_MONGODB_SERVER simces_mongodb The host name for MongoDB. Can also be Docker container name for a container in the same Docker network as the Platform Manager. ME_CONFIG_MONGODB_PORT 27017 The port number for MongoDB. ME_CONFIG_MONGODB_ENABLE_ADMIN true Whether admin access is allowed though the Mongo Express interface (true/false) ME_CONFIG_MONGODB_ADMINUSERNAME The admin username for MongoDB. If this is empty and ME_CONFIG_MONGODB_ENABLE_ADMIN is true, no access control is assumed to be in use. ME_CONFIG_MONGODB_ADMINPASSWORD The admin password for MongoDB. ME_CONFIG_MONGODB_AUTH_DATABASE logs if ME_CONFIG_MONGODB_ENABLE_ADMIN is false, the database that is used to authenticate the MongoDB user ME_CONFIG_MONGODB_AUTH_USERNAME The username for non-admin user in MongoDB. ME_CONFIG_MONGODB_AUTH_PASSWORD The password for non-admin user in MongoDB. ME_CONFIG_MONGODB_SSL false Whether the connection to MongoDB is secured or not (true/false) ME_CONFIG_BASICAUTH_USERNAME The username asked by the Mongo Express web interface ME_CONFIG_BASICAUTH_PASSWORD The password asked by the Mongo Express web interface The default file can be found at: background/env/mongo_express.env","title":"background/env/mongo_express.env"},{"location":"core_platform-settings/#backgrounddocker-compose-backgroundyml","text":"Some local ports are used by the platform. The default ports are listed in the table below: Component Default port(s) Log Reader 8080 Mongo Express 8081 RabbitMQ 5672 and 15672 The used port numbers can be changed by modifying the Docker Compose file by changing the number in the relevant section. For example to change the locally deployed Log Reader to use port 8555 instead of the default 8080, the Log Reader section of the file should be changed to the following: log_reader: image: ghcr.io/simcesplatform/logreader container_name: simces_log_reader restart: always depends_on: - mongodb env_file: - env/components_mongodb.env environment: - MONGODB_APPNAME=log_writer ports: - 8555:8080 # here a change from 8080:8080 to 8555:8080 networks: - mongodb_network The default file can be found at: background/docker-compose-background.yml","title":"background/docker-compose-background.yml"},{"location":"core_platform-settings/#simulation-run-specific-settings","text":"The simulation configuration YAML file is the main configuration for each simulation run. However, for the communication to work some environment settings must be configured properly. The environment variables are passed to Platform Manager when a new simulation run is started. They are given in 3 environment variable files: common.env (for some common settings), rabbitmq.env (for the connection details for RabbitMQ) and mongodb.env (for connection details for MongoDB). All of the common and RabbitMQ parameters are passed to the platform managed components when a new simulation run is started. In addition, the simulation run specific Log Writer instance also receives the MongoDB settings. Some of the parameters are described here. For the parameters not described here there are descriptive comments in the files themselves.","title":"Simulation run specific settings"},{"location":"core_platform-settings/#commonenv","text":"Common settings for all simulation components: Variable name Default Description SIMULATION_LOG_LEVEL 20 The logging level for which the logging messages are included in the output of the components. 30 to include only warnings and errors, 20 to include also info messages, and 10 to include the debug messages as well. The default file can be found at: common.env","title":"common.env"},{"location":"core_platform-settings/#rabbitmqenv","text":"RabbitMQ connection settings for a new simulation run: Variable name Default Description RABBITMQ_HOST simces_rabbitmq The host name for the RabbitMQ message bus. Can also be Docker container name for a container in the same Docker network as the Platform Manager. RABBITMQ_PORT 5672 The port number for the RabbitMQ message bus. RABBITMQ_LOGIN The username for the RabbitMQ message bus. If this is empty, the default username, guest . is used. RABBITMQ_PASSWORD The password for the RabbitMQ message bus. If this is empty, the default password, guest . is used. RABBITMQ_SSL false Whether the connection to the RabbitMQ message bus is secured or not (true/false) RABBITMQ_SSL_VERSION PROTOCOL_TLS The security protocol used in the RabbitMQ message bus connection. Only considered if RABBITMQ_SSL is true. The default file can be found at: rabbitmq.env","title":"rabbitmq.env"},{"location":"core_platform-settings/#mongodbenv","text":"MongoDB connection settings for a new simulation run: Variable name Default Description MONGODB_HOST simces_mongodb The host name for MongoDB. Can also be Docker container name for a container in the same Docker network as the Platform Manager. MONGODB_PORT 27017 The port number for MongoDB. MONGODB_USERNAME The username for MongoDB. If this is empty, no access control is assumed to be in use. MONGODB_PASSWORD The password for MongoDB. MONGODB_ADMIN true Whether the account given in MONGODB_USERNAME has root access or not. Ignored if MONGODB_USERNAME is empty. (true/false) MONGODB_TLS false Whether the connection to MongoDB is secured or not (true/false) MONGODB_TLS_ALLOW_INVALID_CERTIFICATES false Whether to allow invalid security certificates. Ignored if MONGO_TLS is false. (true/false) The default file can be found at: mongodb.env","title":"mongodb.env"},{"location":"core_platformmanager/","text":"Platform Manager Component that is used to start new simulation runs in the SimCES simulation platform. It generates and starts the Docker containers for the platform managed components in the new simulation run and publishes the simulation parameters using Start message via Management exchange . Functionalities Parses the component manifest files to determine the available component types for a new simulation. Parses the simulation configuration file to determine the parameters for the new simulation. Creates the Docker containers for the required platform managed components for the new simulation. Starts the created Docker containers. Sends the Start message via Management exchange for the new simulation. Technical details Platform Manager is written in Python (3.7.9) and the code repository is found at: https://github.com/simcesplatform/platform-manager Platform Manages connects to the Docker Engine of the host machine. All Docker containers created for simulations are created to Docker Engine of the host machine. Platform Manager connects to RabbitMQ message bus. Both local and remote message bus servers are supported. Platform Manager forwards the RabbitMQ and MongoDB connection details to those platform managed components that need them using environmental variables. One instance of Platform Manager can only start one simulation run. I.e., Platform Manager is given the simulation configuration at the startup and after finishing the simulation start procedures Platform Manager closes itself. Workflow The workflow of a simulation is explained in page Simulation Lifecycle . Required before running Platform Manager to start a new simulation run: Docker installed and available for the Platform Manager A running Log Writer instance listening to the Management Exchange Only required for logging the Start messages All required component manifest files available for the Platform Manager All required static files available for simulations All required Docker images available for the Platform Manager Connection parameters for RabbitMQ and MongoDB given in the configuration files for the Platform Manager It is advisable to start the Platform Manager using the provided start simulation script which can be used to easily provide the Platform Manager with the wanted simulation configuration. Workflow of the Platform Manager instance once it has been started: Parse the available component manifest files. Parse the simulation configuration file. Create new Docker containers for the platform managed simulation components: Log writer instance for the simulation specific exchange Platform managed components specified in the simulation configuration file Simulation Manager for the simulation run Start the created Docker containers. Send a Start message for the new simulation run via the Management exchange. Close the Platform Manager instance. Environment variables The parameters for the Platform Manager are given in three environment variable files: common.env , rabbitmq.env and mongodb.env . The description for the parameters is given at the Simulation run specific settings section of Configuring platform settings page.","title":"Platform Manager"},{"location":"core_platformmanager/#platform-manager","text":"Component that is used to start new simulation runs in the SimCES simulation platform. It generates and starts the Docker containers for the platform managed components in the new simulation run and publishes the simulation parameters using Start message via Management exchange .","title":"Platform Manager"},{"location":"core_platformmanager/#functionalities","text":"Parses the component manifest files to determine the available component types for a new simulation. Parses the simulation configuration file to determine the parameters for the new simulation. Creates the Docker containers for the required platform managed components for the new simulation. Starts the created Docker containers. Sends the Start message via Management exchange for the new simulation.","title":"Functionalities"},{"location":"core_platformmanager/#technical-details","text":"Platform Manager is written in Python (3.7.9) and the code repository is found at: https://github.com/simcesplatform/platform-manager Platform Manages connects to the Docker Engine of the host machine. All Docker containers created for simulations are created to Docker Engine of the host machine. Platform Manager connects to RabbitMQ message bus. Both local and remote message bus servers are supported. Platform Manager forwards the RabbitMQ and MongoDB connection details to those platform managed components that need them using environmental variables. One instance of Platform Manager can only start one simulation run. I.e., Platform Manager is given the simulation configuration at the startup and after finishing the simulation start procedures Platform Manager closes itself.","title":"Technical details"},{"location":"core_platformmanager/#workflow","text":"The workflow of a simulation is explained in page Simulation Lifecycle . Required before running Platform Manager to start a new simulation run: Docker installed and available for the Platform Manager A running Log Writer instance listening to the Management Exchange Only required for logging the Start messages All required component manifest files available for the Platform Manager All required static files available for simulations All required Docker images available for the Platform Manager Connection parameters for RabbitMQ and MongoDB given in the configuration files for the Platform Manager It is advisable to start the Platform Manager using the provided start simulation script which can be used to easily provide the Platform Manager with the wanted simulation configuration. Workflow of the Platform Manager instance once it has been started: Parse the available component manifest files. Parse the simulation configuration file. Create new Docker containers for the platform managed simulation components: Log writer instance for the simulation specific exchange Platform managed components specified in the simulation configuration file Simulation Manager for the simulation run Start the created Docker containers. Send a Start message for the new simulation run via the Management exchange. Close the Platform Manager instance.","title":"Workflow"},{"location":"core_platformmanager/#environment-variables","text":"The parameters for the Platform Manager are given in three environment variable files: common.env , rabbitmq.env and mongodb.env . The description for the parameters is given at the Simulation run specific settings section of Configuring platform settings page.","title":"Environment variables"},{"location":"core_pseudocode/","text":"Pseudocode reference This page explains how to interpret the pseudocode that appears in some pages. Motivation The principles behind the pseudocode are: Be easily readable Express what is essential Leave freedom of expression, i.e., avoid strict rules What are the advantages? Pseudocode: is more compact than human language does not tie the algorithm to any programming language contains fewer details than source code and therefore: pseudocode is faster to write it's easier to see the overall picture from pseudocode Comments // This is a comment Variables and strings // Declaring a string variable: my_var = \"Example string\" // Concatenation happens as follows. // This will result in \"Example string is nice\" my_var_longer = my_var + \" is nice\" Calculation (calc) // \"calc result\" indicates that the component generates a result to be published. // Often, this includes calculation (such as simulation) // but the component may as well supply a constant value. calc result Messaging (publ, recv) // The component receives a message with some input to calculation. // This does not specify where the input comes from. recv input // Use the input to calculate a result. calc result // Publish the result. // This does not specify the topic to which the result is published. publ result Often, pseudocode does not specify to which topic to publish. This is to avoid redundancy with another page or location that specifies the exact topic. However, if there is a need to specify the topic explicitly, you can say: topic = \"TopicX\" publ result to topic // Alternatively: publ result to \"TopicX\" If conditions (if, else) // Indentation indicates which lines belong to which code block (if and else). if x // This line is executed if condition \"x\" matches else if y // This line is executed if condition \"y\" matches else // This line is executed if none of the earlier conditions matches // This line is executed after the if-else block Looping (loop, break) loop // This line is executed as long as \"break loop\" has not occurred. // Indentation indicates which lines are within the loop. // The loop breaks conditionally. // If there are nested loops, break only affects the innermost loop. if x break loop Wait for events // Wait for one of events to occur first wait for one of recv x // This line is executed if \"recv x\" occurs first recv y // This line is executed if \"recv y\" occurs first recv z // Because there is no indented line after the event \"recv z\", // this causes the execution to jump here. // Still, even the other events will eventually lead here. Quitting (quit) // To quit execution, say: quit Functions Functions are defined as follows: function my_function() // This is some code within the function. // The indentation indicates which lines belong to the function. The function above is called as follows: my_function()","title":"Pseudocode reference"},{"location":"core_pseudocode/#pseudocode-reference","text":"This page explains how to interpret the pseudocode that appears in some pages.","title":"Pseudocode reference"},{"location":"core_pseudocode/#motivation","text":"The principles behind the pseudocode are: Be easily readable Express what is essential Leave freedom of expression, i.e., avoid strict rules What are the advantages? Pseudocode: is more compact than human language does not tie the algorithm to any programming language contains fewer details than source code and therefore: pseudocode is faster to write it's easier to see the overall picture from pseudocode","title":"Motivation"},{"location":"core_pseudocode/#comments","text":"// This is a comment","title":"Comments"},{"location":"core_pseudocode/#variables-and-strings","text":"// Declaring a string variable: my_var = \"Example string\" // Concatenation happens as follows. // This will result in \"Example string is nice\" my_var_longer = my_var + \" is nice\"","title":"Variables and strings"},{"location":"core_pseudocode/#calculation-calc","text":"// \"calc result\" indicates that the component generates a result to be published. // Often, this includes calculation (such as simulation) // but the component may as well supply a constant value. calc result","title":"Calculation (calc)"},{"location":"core_pseudocode/#messaging-publ-recv","text":"// The component receives a message with some input to calculation. // This does not specify where the input comes from. recv input // Use the input to calculate a result. calc result // Publish the result. // This does not specify the topic to which the result is published. publ result Often, pseudocode does not specify to which topic to publish. This is to avoid redundancy with another page or location that specifies the exact topic. However, if there is a need to specify the topic explicitly, you can say: topic = \"TopicX\" publ result to topic // Alternatively: publ result to \"TopicX\"","title":"Messaging (publ, recv)"},{"location":"core_pseudocode/#if-conditions-if-else","text":"// Indentation indicates which lines belong to which code block (if and else). if x // This line is executed if condition \"x\" matches else if y // This line is executed if condition \"y\" matches else // This line is executed if none of the earlier conditions matches // This line is executed after the if-else block","title":"If conditions (if, else)"},{"location":"core_pseudocode/#looping-loop-break","text":"loop // This line is executed as long as \"break loop\" has not occurred. // Indentation indicates which lines are within the loop. // The loop breaks conditionally. // If there are nested loops, break only affects the innermost loop. if x break loop","title":"Looping (loop, break)"},{"location":"core_pseudocode/#wait-for-events","text":"// Wait for one of events to occur first wait for one of recv x // This line is executed if \"recv x\" occurs first recv y // This line is executed if \"recv y\" occurs first recv z // Because there is no indented line after the event \"recv z\", // this causes the execution to jump here. // Still, even the other events will eventually lead here.","title":"Wait for events"},{"location":"core_pseudocode/#quitting-quit","text":"// To quit execution, say: quit","title":"Quitting (quit)"},{"location":"core_pseudocode/#functions","text":"Functions are defined as follows: function my_function() // This is some code within the function. // The indentation indicates which lines belong to the function. The function above is called as follows: my_function()","title":"Functions"},{"location":"core_rabbitmq-reliability/","text":"Reliable messaging in RabbitMQ This page presents RabbitMQ mechanisms to increase the reliability of messaging. This is a summary from https://www.rabbitmq.com/confirms.html . The content has been gathered selectively. Reliable messaging needed in simulations? AMQP connections are based on TCP (Transmission Control Protocol), which guarantees reliability as long as the connection remains open. TCP is considered reliable enough for this platform without any additional mechanims. If the connection dies in a node, the simulation fails anyway and this is detected as soon as notifications about finishing cease appearing. Therefore, it is suggested to use automatic acks in RabbitMQ to reduce the burden of software development. Still, nothing prevents a single developer from enabling additional mechanisms for reliability. Confirmations from consumers Automatic confirmations \"In automatic acknowledgement mode, a message is considered to be successfully delivered immediately after it is sent.\" That is, the broker will not retry if the consumer dies after a message is delivered from a queue to a consumer. However, we still have an underlying TCP connection, which is supposedly reliable as long as it remains open. Manual confirmations If a consumer applies this mode, it MUST acknowledge all deliveries after reception. The mode is more secure compared to automatic acks, but the consumer might still crash after ack. Confirm types ack \"used for positive acknowledgements\" reject \"used for negative acknowledgements\" Signals the broker that \"delivery wasn't processed but still should be deleted\". nack \"used for negative acknowledgements\" This is a RabbitMQ extension to the AMQP protocol. Acks can be batched to reduce traffic. However, because \"reject\" does not support this, nack was introduced in RabbitMQ. Requeue Reject and nack have an option to ask the broker to requeue a non-delivered message. This is controlled with the \"requeue\" field. Channel prefetch The \"basic.qos\" method enables setting the maximum number of messages that the broker can send to a consumer before receiving a confirmation for the first. This protects the consumers from receiving too many messages at once. Confirmations to publishers RabbitMQ implements an extension to AMQP to enable \"publisher confirms\". Although TCP is a reliable protocol, there is a risk that a dead connection is detected only after various minutes (see https://www.rabbitmq.com/heartbeats.html ). Standard AMQP provides a mechanism called transactions, but this reduces throughput.","title":"Reliable messaging in RabbitMQ"},{"location":"core_rabbitmq-reliability/#reliable-messaging-in-rabbitmq","text":"This page presents RabbitMQ mechanisms to increase the reliability of messaging. This is a summary from https://www.rabbitmq.com/confirms.html . The content has been gathered selectively.","title":"Reliable messaging in RabbitMQ"},{"location":"core_rabbitmq-reliability/#reliable-messaging-needed-in-simulations","text":"AMQP connections are based on TCP (Transmission Control Protocol), which guarantees reliability as long as the connection remains open. TCP is considered reliable enough for this platform without any additional mechanims. If the connection dies in a node, the simulation fails anyway and this is detected as soon as notifications about finishing cease appearing. Therefore, it is suggested to use automatic acks in RabbitMQ to reduce the burden of software development. Still, nothing prevents a single developer from enabling additional mechanisms for reliability.","title":"Reliable messaging needed in simulations?"},{"location":"core_rabbitmq-reliability/#confirmations-from-consumers","text":"","title":"Confirmations from consumers"},{"location":"core_rabbitmq-reliability/#automatic-confirmations","text":"\"In automatic acknowledgement mode, a message is considered to be successfully delivered immediately after it is sent.\" That is, the broker will not retry if the consumer dies after a message is delivered from a queue to a consumer. However, we still have an underlying TCP connection, which is supposedly reliable as long as it remains open.","title":"Automatic confirmations"},{"location":"core_rabbitmq-reliability/#manual-confirmations","text":"If a consumer applies this mode, it MUST acknowledge all deliveries after reception. The mode is more secure compared to automatic acks, but the consumer might still crash after ack.","title":"Manual confirmations"},{"location":"core_rabbitmq-reliability/#confirm-types","text":"","title":"Confirm types"},{"location":"core_rabbitmq-reliability/#ack","text":"\"used for positive acknowledgements\"","title":"ack"},{"location":"core_rabbitmq-reliability/#reject","text":"\"used for negative acknowledgements\" Signals the broker that \"delivery wasn't processed but still should be deleted\".","title":"reject"},{"location":"core_rabbitmq-reliability/#nack","text":"\"used for negative acknowledgements\" This is a RabbitMQ extension to the AMQP protocol. Acks can be batched to reduce traffic. However, because \"reject\" does not support this, nack was introduced in RabbitMQ.","title":"nack"},{"location":"core_rabbitmq-reliability/#requeue","text":"Reject and nack have an option to ask the broker to requeue a non-delivered message. This is controlled with the \"requeue\" field.","title":"Requeue"},{"location":"core_rabbitmq-reliability/#channel-prefetch","text":"The \"basic.qos\" method enables setting the maximum number of messages that the broker can send to a consumer before receiving a confirmation for the first. This protects the consumers from receiving too many messages at once.","title":"Channel prefetch"},{"location":"core_rabbitmq-reliability/#confirmations-to-publishers","text":"RabbitMQ implements an extension to AMQP to enable \"publisher confirms\". Although TCP is a reliable protocol, there is a risk that a dead connection is detected only after various minutes (see https://www.rabbitmq.com/heartbeats.html ). Standard AMQP provides a mechanism called transactions, but this reduces throughput.","title":"Confirmations to publishers"},{"location":"core_run-first/","text":"Running the first test simulation To test that the core platform has been installed properly, a simple test simulation configuration has been provided. This configuration involves 3 Dummy components in addition to the Simulation Manager and Log Writer instances that are always included in every simulation run. (Optional) Configuring the platform settings The default parameters are fine for testing the platform installation. By default the local RabbitMQ message bus and the local MongoDB that were started during the installation process are used. The descriptions for the configurable settings can be found from Configuring platform settings . (Optional) Setting up the simulation configuration file The simulation run specific parameters are given in a separate configuration file that uses YAML format. For the first test run, a ready-made configuration file, simulation_configuration_test.yml has been made. The configuration file defines the simulation metadata: the name and description for the simulation run as well as the start time for the first epoch, epoch length and the maximum number of epochs in the simulation run the components participating in the simulation run and their individual parameters For the first test simulation, the configuration file can be left as it is. Starting the first simulation run To start the first test simulation, use Bash compatible terminal (Git Bash in Windows) to navigate to the platform folder and use the command source start_simulation.sh simulation_configuration_test.yml If everything worked properly, you should see something like: simces_platform_manager | 2021-10-12T12:50:00.515 --- INFO --- Starting the Docker containers for simulation: 'Test simulation' with id: 2021-10-12T12:50:00.514Z simces_platform_manager | 2021-10-12T12:50:00.878 --- INFO --- Starting container: Sim00_log_writer simces_platform_manager | 2021-10-12T12:50:01.376 --- INFO --- Starting container: Sim00_slow_dummy simces_platform_manager | 2021-10-12T12:50:01.815 --- INFO --- Starting container: Sim00_fast_dummy_1 simces_platform_manager | 2021-10-12T12:50:02.240 --- INFO --- Starting container: Sim00_fast_dummy_2 simces_platform_manager | 2021-10-12T12:50:02.671 --- INFO --- Starting container: Sim00_SimulationManager simces_platform_manager | 2021-10-12T12:50:03.095 --- INFO --- Start message for simulation 'Test simulation' sent to management exchange. simces_platform_manager | 2021-10-12T12:50:03.095 --- INFO --- Simulation 'Test simulation' started successfully using id: 2021-10-12T12:50:00.514Z simces_platform_manager | 2021-10-12T12:50:03.095 --- INFO --- Follow the simulation by using the command: simces_platform_manager | source follow_simulation.sh 00 simces_platform_manager | 2021-10-12T12:50:03.095 --- INFO --- Alternatively, the simulation manager logs can by viewed by: simces_platform_manager | docker logs --follow Sim00_SimulationManager simces_platform_manager | 2021-10-12T12:50:03.095 --- INFO --- Platform manager has finished starting the simulation and will now stop. simces_platform_manager | 2021-10-12T12:50:03.095 --- INFO --- The simulation will continue to run on the background. simces_platform_manager | 2021-10-12T12:50:03.095 --- INFO --- Stopping the platform manager. simces_platform_manager exited with code 0 See the Following a running simulation page on more details about following the output from the running simulation. The Log Reader , by default at http://localhost:8080 can also be used to view the messages. http://localhost:8080/simulations/<simulation_id> should show the metadata for the test simulation http://localhost:8080/simulations/<simulation_id>/messages should show all the messages for the test simulation in the order of their arrival http://localhost:8080/simulations/<simulation_id>/messages?topic=Start should show only the start message for the test simulation In the above, replace <simulation_id> with the id given by the Platform manager. In the earlier output, the simulation id would be 2021-10-12T12:50:00.514Z . See the Log Reader API documentation page for more details about the using the API.","title":"Run first test simulation"},{"location":"core_run-first/#running-the-first-test-simulation","text":"To test that the core platform has been installed properly, a simple test simulation configuration has been provided. This configuration involves 3 Dummy components in addition to the Simulation Manager and Log Writer instances that are always included in every simulation run.","title":"Running the first test simulation"},{"location":"core_run-first/#optional-configuring-the-platform-settings","text":"The default parameters are fine for testing the platform installation. By default the local RabbitMQ message bus and the local MongoDB that were started during the installation process are used. The descriptions for the configurable settings can be found from Configuring platform settings .","title":"(Optional) Configuring the platform settings"},{"location":"core_run-first/#optional-setting-up-the-simulation-configuration-file","text":"The simulation run specific parameters are given in a separate configuration file that uses YAML format. For the first test run, a ready-made configuration file, simulation_configuration_test.yml has been made. The configuration file defines the simulation metadata: the name and description for the simulation run as well as the start time for the first epoch, epoch length and the maximum number of epochs in the simulation run the components participating in the simulation run and their individual parameters For the first test simulation, the configuration file can be left as it is.","title":"(Optional) Setting up the simulation configuration file"},{"location":"core_run-first/#starting-the-first-simulation-run","text":"To start the first test simulation, use Bash compatible terminal (Git Bash in Windows) to navigate to the platform folder and use the command source start_simulation.sh simulation_configuration_test.yml If everything worked properly, you should see something like: simces_platform_manager | 2021-10-12T12:50:00.515 --- INFO --- Starting the Docker containers for simulation: 'Test simulation' with id: 2021-10-12T12:50:00.514Z simces_platform_manager | 2021-10-12T12:50:00.878 --- INFO --- Starting container: Sim00_log_writer simces_platform_manager | 2021-10-12T12:50:01.376 --- INFO --- Starting container: Sim00_slow_dummy simces_platform_manager | 2021-10-12T12:50:01.815 --- INFO --- Starting container: Sim00_fast_dummy_1 simces_platform_manager | 2021-10-12T12:50:02.240 --- INFO --- Starting container: Sim00_fast_dummy_2 simces_platform_manager | 2021-10-12T12:50:02.671 --- INFO --- Starting container: Sim00_SimulationManager simces_platform_manager | 2021-10-12T12:50:03.095 --- INFO --- Start message for simulation 'Test simulation' sent to management exchange. simces_platform_manager | 2021-10-12T12:50:03.095 --- INFO --- Simulation 'Test simulation' started successfully using id: 2021-10-12T12:50:00.514Z simces_platform_manager | 2021-10-12T12:50:03.095 --- INFO --- Follow the simulation by using the command: simces_platform_manager | source follow_simulation.sh 00 simces_platform_manager | 2021-10-12T12:50:03.095 --- INFO --- Alternatively, the simulation manager logs can by viewed by: simces_platform_manager | docker logs --follow Sim00_SimulationManager simces_platform_manager | 2021-10-12T12:50:03.095 --- INFO --- Platform manager has finished starting the simulation and will now stop. simces_platform_manager | 2021-10-12T12:50:03.095 --- INFO --- The simulation will continue to run on the background. simces_platform_manager | 2021-10-12T12:50:03.095 --- INFO --- Stopping the platform manager. simces_platform_manager exited with code 0 See the Following a running simulation page on more details about following the output from the running simulation. The Log Reader , by default at http://localhost:8080 can also be used to view the messages. http://localhost:8080/simulations/<simulation_id> should show the metadata for the test simulation http://localhost:8080/simulations/<simulation_id>/messages should show all the messages for the test simulation in the order of their arrival http://localhost:8080/simulations/<simulation_id>/messages?topic=Start should show only the start message for the test simulation In the above, replace <simulation_id> with the id given by the Platform manager. In the earlier output, the simulation id would be 2021-10-12T12:50:00.514Z . See the Log Reader API documentation page for more details about the using the API.","title":"Starting the first simulation run"},{"location":"core_run-preparations/","text":"Preparations for a simulation All file and folder names are given as relative to the platform installation folder, i.e. the folder where the file fetch_platform_files.sh is located at. There are a couple steps before a simulation run using user developed components can be be started using the platform: All the components have to be installed. ( Installing a new component ) With externally managed components this involves installing and starting the components manually. With platform managed components, this involves fetching the Docker image for the component. All the components have to be registered to the platform. ( Registering new component type to the platform ) by providing a component manifest file for the component. For platform managed components any input files (for example, CSV files) have to be made available to the platform. ( Making input files available for the platform ) After the component installation and registration has been done, a new simulation configuration file can be created and then used to start a new simulation run. See page Starting a general simulation for instructions regarding starting a simulation. Installing a new component Externally managed components Any externally managed component should contain its own installation instructions on the documentation page of the component. Platform managed components A component managed by the platform should have an available Docker image that can be used to include the component in simulation runs. This Docker image must be available to the platform when a new simulation run that includes this component is started. To fetch the Docker image for the component follow the procedure: Modify the file docker_images_domain.txt so that it contains the Docker image name for the component in question. Note, that the file must be saved using Unix line endings (LF) To change the file from Windows line endings (CR LF) to Unix line endings with Notepad++: Edit -> EOL Conversion -> Unix (LF) Or using Bash compatible terminal: dos2unix docker_images_domain.txt Once the component registration and the input files have also been setup, follow the instructions at ( Finalize component installation ) to finalize the component installation. Downloading component source code The full source should not be needed when installing components, at least not with the platform managed components, but the following is included here if it is required. The general form of the command to fetch the source code using Git is: git clone --recursive https://github.com/simcesplatform/<component_name>.git or if the code is in a private GitLab repository (with an insecure SSL certificate at the host): git -c http.sslVerify=false clone --recursive <full_address_to_the_repository>.git Registering component type to the platform Before platform can be used to start a new simulation that includes a new domain component, the new component type has to be registered to the platform. The registering is done to allow the platform to know whether the new component is an externally managed or platform managed component and in the latter case to also know which Docker image to use when deploying the platform managed component. The registration process also allows the user to mark some input parameters as required so that the platform does not start a new simulation run in vain if essential information is missing from the simulation configuration. The components are registered for the platform by providing it with component manifest files for all the required component types. Each component should provide a component manifest file with the component source code. To register all the required component types to the platform follow the procedure: Modify the Git server file so that it contains the code repository name for the component in question in the Repositories listing. See the section Git server file format about the details of the used attributes and the syntax for the file. Use the file components/github_server_domain.yml if the repositories are available at GitHub Use the file components/gitlab_server_domain.yml if the repositories are in the GitLab server used in the development of the platform. Note, when using private repositories which require access tokens, remember to add the required tokens to file access_tokens.env . It is also possible to create completely new Git server file under the folder components . All files under the folder are gone through when fetching the manifest files. Alternatively, it is also possible to manually copy the component manifest file to the folder manifests . All YAML files under that folder are taken to account when the platform is started. There also exists a script that can be used to copy locally existing manifest files to the manifests folder. To use it, first edit the file local_manifest_files.txt to include the paths to the local manifest files and then run: source fetch_local_manifests.sh local_manifest_files.txt Once the component installation as well as the input files have been setup, follow the instructions at ( Finalize component installation ) to finalize the component installation. Git server file format The server file is in YAML format and supports the following attributes: Type (required) can be either \" GitLab \" or \" GitHub \" depending on the remote Git server type Repositories (required) a list of repository names from which a component manifest should be fetched each repository can contain the following attributes: File (optional) the filename for the component manifest file, must have an extension of \" .yml \" or \" .yaml \" the default filename is \" component_manifest.yml \" Branch (optional) the branch or tag of the repository that should be used when fetching the manifest file the default branch is \" master \" Host (optional) the host server address only taken account for GitLab servers, for GitHub server, \" https://github.com \", is used the default value for GitLab server is \" https://gitlab.com \" Certificate (optional) whether the host server has a proper SSL certificate can be either true or false , the default value is true AccessToken (optional) An access token to be used when fetching files from a private repository If given in the form \" ${ENV_VARIABLE} \" the value of the environmental variable ENV_VARIABLE is used as the access token. The platform loads the environment variables from file access_tokens.env when fetching the manifest files. The given access token must provide at least read access to the given repositories If no access token is given, all repositories are assumed to be public Example Git server file The following server file would be used to fetch manifest files from 4 GitLab repositories hosted at https://gitlab.address.com . Using the default branch, file \" component_manifest.yml \" from \" procemplus/my_component1 \" and \" procemplus/my_component2 \" and file \" my_manifest.yml \" from \" procemplus/my_component3 \". Using the branch \" my_branch \", file \" my_folder/my_manifest.yml \" from \" username/my_component4 \". The access to the repositories is provided by environment variable GITLAB_ACCESS_TOKEN which is read from file access_tokens.env . Repositories: - procemplus/my_component1 - procemplus/my_component2 - procemplus/my_component3: File: my_manifest.yml - username/my_component4: File: my_folder/my_manifest.yml Branch: my_branch Type: GitLab Host: https://gitlab.address.com Certificate: false AccessToken: ${GITLAB_ACCESS_TOKEN} Making input files available for the platform Any input file that is used by a platform managed component during a simulation run, needs to be made available for the platform. Example for an input file is the CSV file that is used as input for the Static Time Series Resource components in the Energy Community demo simulation . Any input files that are used by externally managed components are not required to be accessible by the platform. To make a input file available for the platform: Copy the input file to the resources folder. The files can be either directly at the resources folder (like the input files for EC demo scenario) or inside a subfolder. Once the component installation and registration have also been setup, follow the instructions at ( Finalize component installation ) to finalize the component installation. Note, that due to the limitation of the current platform implementation, all the files included in the resources folder will be made available for all the platform managed components. Also, to avoid errors, any file that is currently being used in a running simulation should not be modified while the simulation is still running. Finalize component installation The component can be installed and registered to the platform by running the following installation script. This script will also make any prepared input files available to the platform. source platform_domain_setup.sh A successful run of the script should show no error messages in the output. See the Example output section for possible script output when no errors are present. Note, that for externally managed components, the script above can only register the component manifests to the platform. The manual installation and starting procedure for the components is still required in addition to running the script. Example output Fetching the domain Docker images from Docker registry Reading 'docker_images_domain.txt' for Docker image names Pulling Docker image: ghcr.io/simcesplatform/static-time-series-resource:latest latest: Pulling from simcesplatform/static-time-series-resource Digest: sha256:844b269933eb9272bed896d83e9ace4d0b4ad9311507a3027c12a874f3c7087c Status: Image is up to date for ghcr.io/simcesplatform/static-time-series-resource:latest ghcr.io/simcesplatform/static-time-series-resource:latest Fetching the component manifests. Creating simces_manifest_fetcher ... done Attaching to simces_manifest_fetcher simces_manifest_fetcher | 2021-10-14T08:04:48.932 --- INFO --- Fetching file 'component_manifest.yml' from GitHub repository simcesplatform/static-time-series-resource simces_manifest_fetcher | 2021-10-14T08:04:49.217 --- INFO --- Fetching file 'component_manifest_manager.yml' from GitHub repository simcesplatform/simulation-manager simces_manifest_fetcher | 2021-10-14T08:04:49.417 --- INFO --- Fetching file 'component_manifest_dummy.yml' from GitHub repository simcesplatform/simulation-manager simces_manifest_fetcher | 2021-10-14T08:04:49.629 --- INFO --- Fetching file 'component_manifest.yml' from GitHub repository simcesplatform/logwriter simces_manifest_fetcher | 2021-10-14T08:04:49.820 --- INFO --- Fetching file 'component_manifest_manager.yml' from GitHub repository simcesplatform/simulation-manager simces_manifest_fetcher | 2021-10-14T08:04:49.847 --- INFO --- Fetching file 'component_manifest_dummy.yml' from GitHub repository simcesplatform/simulation-manager simces_manifest_fetcher | 2021-10-14T08:04:49.865 --- INFO --- Fetching file 'component_manifest.yml' from GitHub repository simcesplatform/logwriter simces_manifest_fetcher exited with code 0 Going to remove simces_manifest_fetcher Removing simces_manifest_fetcher ... done Copying the contents of 'resources' to Docker volume 'simces_simulation_resources' to folder '/resources' Copying file resources/Load2.csv Copying file resources/Load1.csv Copying file resources/Load4.csv Copying file resources/PV_large.csv Copying file resources/Load3.csv Copying file resources/PV_small.csv Copying file resources/EV.csv","title":"Simulation run preparations"},{"location":"core_run-preparations/#preparations-for-a-simulation","text":"All file and folder names are given as relative to the platform installation folder, i.e. the folder where the file fetch_platform_files.sh is located at. There are a couple steps before a simulation run using user developed components can be be started using the platform: All the components have to be installed. ( Installing a new component ) With externally managed components this involves installing and starting the components manually. With platform managed components, this involves fetching the Docker image for the component. All the components have to be registered to the platform. ( Registering new component type to the platform ) by providing a component manifest file for the component. For platform managed components any input files (for example, CSV files) have to be made available to the platform. ( Making input files available for the platform ) After the component installation and registration has been done, a new simulation configuration file can be created and then used to start a new simulation run. See page Starting a general simulation for instructions regarding starting a simulation.","title":"Preparations for a simulation"},{"location":"core_run-preparations/#installing-a-new-component","text":"","title":"Installing a new component"},{"location":"core_run-preparations/#externally-managed-components","text":"Any externally managed component should contain its own installation instructions on the documentation page of the component.","title":"Externally managed components"},{"location":"core_run-preparations/#platform-managed-components","text":"A component managed by the platform should have an available Docker image that can be used to include the component in simulation runs. This Docker image must be available to the platform when a new simulation run that includes this component is started. To fetch the Docker image for the component follow the procedure: Modify the file docker_images_domain.txt so that it contains the Docker image name for the component in question. Note, that the file must be saved using Unix line endings (LF) To change the file from Windows line endings (CR LF) to Unix line endings with Notepad++: Edit -> EOL Conversion -> Unix (LF) Or using Bash compatible terminal: dos2unix docker_images_domain.txt Once the component registration and the input files have also been setup, follow the instructions at ( Finalize component installation ) to finalize the component installation.","title":"Platform managed components"},{"location":"core_run-preparations/#downloading-component-source-code","text":"The full source should not be needed when installing components, at least not with the platform managed components, but the following is included here if it is required. The general form of the command to fetch the source code using Git is: git clone --recursive https://github.com/simcesplatform/<component_name>.git or if the code is in a private GitLab repository (with an insecure SSL certificate at the host): git -c http.sslVerify=false clone --recursive <full_address_to_the_repository>.git","title":"Downloading component source code"},{"location":"core_run-preparations/#registering-component-type-to-the-platform","text":"Before platform can be used to start a new simulation that includes a new domain component, the new component type has to be registered to the platform. The registering is done to allow the platform to know whether the new component is an externally managed or platform managed component and in the latter case to also know which Docker image to use when deploying the platform managed component. The registration process also allows the user to mark some input parameters as required so that the platform does not start a new simulation run in vain if essential information is missing from the simulation configuration. The components are registered for the platform by providing it with component manifest files for all the required component types. Each component should provide a component manifest file with the component source code. To register all the required component types to the platform follow the procedure: Modify the Git server file so that it contains the code repository name for the component in question in the Repositories listing. See the section Git server file format about the details of the used attributes and the syntax for the file. Use the file components/github_server_domain.yml if the repositories are available at GitHub Use the file components/gitlab_server_domain.yml if the repositories are in the GitLab server used in the development of the platform. Note, when using private repositories which require access tokens, remember to add the required tokens to file access_tokens.env . It is also possible to create completely new Git server file under the folder components . All files under the folder are gone through when fetching the manifest files. Alternatively, it is also possible to manually copy the component manifest file to the folder manifests . All YAML files under that folder are taken to account when the platform is started. There also exists a script that can be used to copy locally existing manifest files to the manifests folder. To use it, first edit the file local_manifest_files.txt to include the paths to the local manifest files and then run: source fetch_local_manifests.sh local_manifest_files.txt Once the component installation as well as the input files have been setup, follow the instructions at ( Finalize component installation ) to finalize the component installation.","title":"Registering component type to the platform"},{"location":"core_run-preparations/#git-server-file-format","text":"The server file is in YAML format and supports the following attributes: Type (required) can be either \" GitLab \" or \" GitHub \" depending on the remote Git server type Repositories (required) a list of repository names from which a component manifest should be fetched each repository can contain the following attributes: File (optional) the filename for the component manifest file, must have an extension of \" .yml \" or \" .yaml \" the default filename is \" component_manifest.yml \" Branch (optional) the branch or tag of the repository that should be used when fetching the manifest file the default branch is \" master \" Host (optional) the host server address only taken account for GitLab servers, for GitHub server, \" https://github.com \", is used the default value for GitLab server is \" https://gitlab.com \" Certificate (optional) whether the host server has a proper SSL certificate can be either true or false , the default value is true AccessToken (optional) An access token to be used when fetching files from a private repository If given in the form \" ${ENV_VARIABLE} \" the value of the environmental variable ENV_VARIABLE is used as the access token. The platform loads the environment variables from file access_tokens.env when fetching the manifest files. The given access token must provide at least read access to the given repositories If no access token is given, all repositories are assumed to be public","title":"Git server file format"},{"location":"core_run-preparations/#example-git-server-file","text":"The following server file would be used to fetch manifest files from 4 GitLab repositories hosted at https://gitlab.address.com . Using the default branch, file \" component_manifest.yml \" from \" procemplus/my_component1 \" and \" procemplus/my_component2 \" and file \" my_manifest.yml \" from \" procemplus/my_component3 \". Using the branch \" my_branch \", file \" my_folder/my_manifest.yml \" from \" username/my_component4 \". The access to the repositories is provided by environment variable GITLAB_ACCESS_TOKEN which is read from file access_tokens.env . Repositories: - procemplus/my_component1 - procemplus/my_component2 - procemplus/my_component3: File: my_manifest.yml - username/my_component4: File: my_folder/my_manifest.yml Branch: my_branch Type: GitLab Host: https://gitlab.address.com Certificate: false AccessToken: ${GITLAB_ACCESS_TOKEN}","title":"Example Git server file"},{"location":"core_run-preparations/#making-input-files-available-for-the-platform","text":"Any input file that is used by a platform managed component during a simulation run, needs to be made available for the platform. Example for an input file is the CSV file that is used as input for the Static Time Series Resource components in the Energy Community demo simulation . Any input files that are used by externally managed components are not required to be accessible by the platform. To make a input file available for the platform: Copy the input file to the resources folder. The files can be either directly at the resources folder (like the input files for EC demo scenario) or inside a subfolder. Once the component installation and registration have also been setup, follow the instructions at ( Finalize component installation ) to finalize the component installation. Note, that due to the limitation of the current platform implementation, all the files included in the resources folder will be made available for all the platform managed components. Also, to avoid errors, any file that is currently being used in a running simulation should not be modified while the simulation is still running.","title":"Making input files available for the platform"},{"location":"core_run-preparations/#finalize-component-installation","text":"The component can be installed and registered to the platform by running the following installation script. This script will also make any prepared input files available to the platform. source platform_domain_setup.sh A successful run of the script should show no error messages in the output. See the Example output section for possible script output when no errors are present. Note, that for externally managed components, the script above can only register the component manifests to the platform. The manual installation and starting procedure for the components is still required in addition to running the script.","title":"Finalize component installation"},{"location":"core_run-preparations/#example-output","text":"Fetching the domain Docker images from Docker registry Reading 'docker_images_domain.txt' for Docker image names Pulling Docker image: ghcr.io/simcesplatform/static-time-series-resource:latest latest: Pulling from simcesplatform/static-time-series-resource Digest: sha256:844b269933eb9272bed896d83e9ace4d0b4ad9311507a3027c12a874f3c7087c Status: Image is up to date for ghcr.io/simcesplatform/static-time-series-resource:latest ghcr.io/simcesplatform/static-time-series-resource:latest Fetching the component manifests. Creating simces_manifest_fetcher ... done Attaching to simces_manifest_fetcher simces_manifest_fetcher | 2021-10-14T08:04:48.932 --- INFO --- Fetching file 'component_manifest.yml' from GitHub repository simcesplatform/static-time-series-resource simces_manifest_fetcher | 2021-10-14T08:04:49.217 --- INFO --- Fetching file 'component_manifest_manager.yml' from GitHub repository simcesplatform/simulation-manager simces_manifest_fetcher | 2021-10-14T08:04:49.417 --- INFO --- Fetching file 'component_manifest_dummy.yml' from GitHub repository simcesplatform/simulation-manager simces_manifest_fetcher | 2021-10-14T08:04:49.629 --- INFO --- Fetching file 'component_manifest.yml' from GitHub repository simcesplatform/logwriter simces_manifest_fetcher | 2021-10-14T08:04:49.820 --- INFO --- Fetching file 'component_manifest_manager.yml' from GitHub repository simcesplatform/simulation-manager simces_manifest_fetcher | 2021-10-14T08:04:49.847 --- INFO --- Fetching file 'component_manifest_dummy.yml' from GitHub repository simcesplatform/simulation-manager simces_manifest_fetcher | 2021-10-14T08:04:49.865 --- INFO --- Fetching file 'component_manifest.yml' from GitHub repository simcesplatform/logwriter simces_manifest_fetcher exited with code 0 Going to remove simces_manifest_fetcher Removing simces_manifest_fetcher ... done Copying the contents of 'resources' to Docker volume 'simces_simulation_resources' to folder '/resources' Copying file resources/Load2.csv Copying file resources/Load1.csv Copying file resources/Load4.csv Copying file resources/PV_large.csv Copying file resources/Load3.csv Copying file resources/PV_small.csv Copying file resources/EV.csv","title":"Example output"},{"location":"core_run/","text":"Running a simulation Once you have installed the platform (see Installation ), use the following instructions to start a simulation run. All the files mentioned in these instructions are part of the installation and can be found in the installation folder, i.e. in the platform folder if the platform installation instruction were followed. Current version of simulation platform can only start one simulation run at a time. I.e., the simulations are started by running Platform Manager which is given the simulation run configuration at the startup and after finishing the simulation start procedures Platform Manager closes itself. Testing the platform Installation To test the platform installation, see the page Running first test simulation To test the platform with the Energy Community demo scenario, see the page Running EC scenario demo simulation Configuring platform settings Configuring platform settings Starting a simulation Preparations for a general simulation Starting a general simulation Accessing the results from a simulation run Following a running simulation Stopping a simulation Stopping a running simulation","title":"Overview"},{"location":"core_run/#running-a-simulation","text":"Once you have installed the platform (see Installation ), use the following instructions to start a simulation run. All the files mentioned in these instructions are part of the installation and can be found in the installation folder, i.e. in the platform folder if the platform installation instruction were followed. Current version of simulation platform can only start one simulation run at a time. I.e., the simulations are started by running Platform Manager which is given the simulation run configuration at the startup and after finishing the simulation start procedures Platform Manager closes itself.","title":"Running a simulation"},{"location":"core_run/#testing-the-platform-installation","text":"To test the platform installation, see the page Running first test simulation To test the platform with the Energy Community demo scenario, see the page Running EC scenario demo simulation","title":"Testing the platform Installation"},{"location":"core_run/#configuring-platform-settings","text":"Configuring platform settings","title":"Configuring platform settings"},{"location":"core_run/#starting-a-simulation","text":"Preparations for a general simulation Starting a general simulation","title":"Starting a simulation"},{"location":"core_run/#accessing-the-results-from-a-simulation-run","text":"Following a running simulation","title":"Accessing the results from a simulation run"},{"location":"core_run/#stopping-a-simulation","text":"Stopping a running simulation","title":"Stopping a simulation"},{"location":"core_sim-tools/","text":"Simulation Tools package To reduce redundant development work, the package Simulation Tools implements re-usable software modules. The package has been implemented in Python. For example, Simulation Tools includes following features: Classes for reading and creating messages, such as Epoch and Status Classes for creating domain-specific messages from AbstractMessage and AbstractResult Classes for processing re-usable message blocks, such as QuantityBlock and TimeSeriesBlock Network client class for communication with RabbitMQ message bus An abstract base class with the common functionality of simulation components: AbstractSimulationComponent Class for processing datetime values in ISO 8601 Class for logging (locally within the component) Timer class To access the software and view its detailed documentation, visit https://github.com/simcesplatform/simulation-tools","title":"Simulation Tools package"},{"location":"core_sim-tools/#simulation-tools-package","text":"To reduce redundant development work, the package Simulation Tools implements re-usable software modules. The package has been implemented in Python. For example, Simulation Tools includes following features: Classes for reading and creating messages, such as Epoch and Status Classes for creating domain-specific messages from AbstractMessage and AbstractResult Classes for processing re-usable message blocks, such as QuantityBlock and TimeSeriesBlock Network client class for communication with RabbitMQ message bus An abstract base class with the common functionality of simulation components: AbstractSimulationComponent Class for processing datetime values in ISO 8601 Class for logging (locally within the component) Timer class To access the software and view its detailed documentation, visit https://github.com/simcesplatform/simulation-tools","title":"Simulation Tools package"},{"location":"core_simulationmanager/","text":"Simulation Manager Simulation Manager is the main component in any simulation run on the SimCES simulation platform. It handles starting and stopping the simulation run as well as starting a new epoch in the simulation run once all participating components have reported that they are ready for a new epoch. Functionalities The Simulation Manager has two responsibilities: the Manager part is responsible for starting and stopping the simulation run and the Omega part is responsible for starting new epochs within the simulation run. Signals other processes about starting and stopping a simulation round (Manager part). This signaling occurs via SimState message . Simulation is ended after reaching the maximum number of epochs or by the simulation manager receiving an error message (see Status message ). Manages time within a simulation by sending epoch messages (Omega part) (see Time and synchronization and Epoch message ). New epoch messages are only sent once all participating components have finished calculations for the epoch. The components signal the Simulation manager that they are finished for the ongoing epoch by using \"ready\" messages (see Status message ). Technical details Simulation Manager is written in Python (3.7.9) and the code repository is found at: https://github.com/simcesplatform/simulation-manager Simulation Manager connects to RabbitMQ message bus. Both local and remote message bus servers are supported. Workflow Simulation is started. Simulation Manager receives a list of the component names as a parameter during the startup. Simulation Manager sends SimState message \"running\" to start the simulation. The SimState message is sent after a shortly after the Simulation Manager has started. The delay is hardcoded to 10 seconds. The other simulation components respond with a ready message to indicate that they are available. The used epoch number for this starting status message is 0. Once all the simulation components have responded with a \"ready\" message, Simulation Manager sends an Epoch message for a new epoch. The epoch number for the first epoch is 1. If Simulation Manager does not receive a \"ready\" message from all the components within a certain time limit, Simulation Manager resends the Epoch message for the running epoch. The resend can be turned off by a parameter (by setting MaxEpochResendCount to 0) and the time limit can also be changed by a parameter (with EpochTimerInterval ). The default value for the resend timer is 2 minutes with a maximum of 5 resends. The time limit is increased with each resend, i.e. the first resend Epoch message is sent 2 minutes after the original message, the second resend Epoch message is sent 2+2=4 minutes after the first resend, the third resend Epoch message is sent 6 minutes after the second resend, ... If the maximum number of resends is reached, SimulationManager will stop the simulation by sending SimState message \"stopped\". These resends require that the simulation components recognize that a received Epoch message might not be for a new epoch. The Epoch messages sent by Simulation Manager contain a list of triggering message ids that can be used by the simulation components. In the case of an Epoch message for a new epoch, the triggering message list will contain \"ready\" Status message ids for the previous epoch in the order the messages were received. In the case of a resend Epoch message, the triggering message list will contain those \"ready\" message ids that have been received by Simulation Manager for the running epoch. The simulation components receive the epoch message and do whatever they need to do within the epoch and send a \"ready\" message when they are finished with the epoch 1. Repeat steps 5 and 6 for with a growing epoch number in each epoch. I.e. epoch numbers being 2, 3, 4, ... Once maximum number epochs are finished or Simulation Manager receives an Error message , Simulation Manager sends a SimState message \"stopped\". Simulation is stopped. Simulation Manager closes itself after sending the last SimState message . Environment variables When using the SimCES platform, the Platform Manager will sends all the requires variables to the Simulation Manager according to the configuration of the simulation run. Variable name Datatype Corresponding Start message attribute Description SIMULATION_ID ISO 8601; see (a) SimulationId The id for the simulation run. It is expected to correspond to the current time given in UTC time zone. SIMULATION_MANAGER_NAME String ManagerName (b) The identifier, i.e. the SourceProcessId, for the Simulation Manager instance. SIMULATION_COMPONENTS String Components (b) A comma-separated string of the names of the components participating in the simulation. The names MUST correspond to the identifiers (i.e. the SourceProcessId) used by the components. SIMULATION_NAME String SimulationName The name of the simulation run. SIMULATION_DESCRIPTION String SimulationDescription The description of the simulation run. SIMULATION_EPOCH_LENGTH Integer (> 0) EpochLength (b) The epoch length in seconds. SIMULATION_INITIAL_START_TIME ISO 8601; see (a) InitialStartTime (b) The start time for the first epoch as ISO 8601 formatted datetime string. SIMULATION_MAX_EPOCHS Integer (> 0) MaxEpochCount (b) The maximum number of epochs in the simulation run. SIMULATION_EPOCH_TIMER_INTERVAL Float (> 0) EpochTimerInterval (b) The time interval in seconds until Simulation Manager resends an Epoch message if some component has not responded with Status message. SIMULATION_MAX_EPOCH_RESENDS Integer (>= 0) MaxEpochResendCount (b) The maximum number of Epoch message resends Simulation Manager can try for each epoch. (a) Date and time included Accuracy 1 ms Time zone information MUST be included (b) In the Simulation Manager block of the Start message In addition to those variables given above, Simulation Manager also needs the environment variables that relate to connecting to the RabbitMQ message bus.","title":"Simulation Manager"},{"location":"core_simulationmanager/#simulation-manager","text":"Simulation Manager is the main component in any simulation run on the SimCES simulation platform. It handles starting and stopping the simulation run as well as starting a new epoch in the simulation run once all participating components have reported that they are ready for a new epoch.","title":"Simulation Manager"},{"location":"core_simulationmanager/#functionalities","text":"The Simulation Manager has two responsibilities: the Manager part is responsible for starting and stopping the simulation run and the Omega part is responsible for starting new epochs within the simulation run. Signals other processes about starting and stopping a simulation round (Manager part). This signaling occurs via SimState message . Simulation is ended after reaching the maximum number of epochs or by the simulation manager receiving an error message (see Status message ). Manages time within a simulation by sending epoch messages (Omega part) (see Time and synchronization and Epoch message ). New epoch messages are only sent once all participating components have finished calculations for the epoch. The components signal the Simulation manager that they are finished for the ongoing epoch by using \"ready\" messages (see Status message ).","title":"Functionalities"},{"location":"core_simulationmanager/#technical-details","text":"Simulation Manager is written in Python (3.7.9) and the code repository is found at: https://github.com/simcesplatform/simulation-manager Simulation Manager connects to RabbitMQ message bus. Both local and remote message bus servers are supported.","title":"Technical details"},{"location":"core_simulationmanager/#workflow","text":"Simulation is started. Simulation Manager receives a list of the component names as a parameter during the startup. Simulation Manager sends SimState message \"running\" to start the simulation. The SimState message is sent after a shortly after the Simulation Manager has started. The delay is hardcoded to 10 seconds. The other simulation components respond with a ready message to indicate that they are available. The used epoch number for this starting status message is 0. Once all the simulation components have responded with a \"ready\" message, Simulation Manager sends an Epoch message for a new epoch. The epoch number for the first epoch is 1. If Simulation Manager does not receive a \"ready\" message from all the components within a certain time limit, Simulation Manager resends the Epoch message for the running epoch. The resend can be turned off by a parameter (by setting MaxEpochResendCount to 0) and the time limit can also be changed by a parameter (with EpochTimerInterval ). The default value for the resend timer is 2 minutes with a maximum of 5 resends. The time limit is increased with each resend, i.e. the first resend Epoch message is sent 2 minutes after the original message, the second resend Epoch message is sent 2+2=4 minutes after the first resend, the third resend Epoch message is sent 6 minutes after the second resend, ... If the maximum number of resends is reached, SimulationManager will stop the simulation by sending SimState message \"stopped\". These resends require that the simulation components recognize that a received Epoch message might not be for a new epoch. The Epoch messages sent by Simulation Manager contain a list of triggering message ids that can be used by the simulation components. In the case of an Epoch message for a new epoch, the triggering message list will contain \"ready\" Status message ids for the previous epoch in the order the messages were received. In the case of a resend Epoch message, the triggering message list will contain those \"ready\" message ids that have been received by Simulation Manager for the running epoch. The simulation components receive the epoch message and do whatever they need to do within the epoch and send a \"ready\" message when they are finished with the epoch 1. Repeat steps 5 and 6 for with a growing epoch number in each epoch. I.e. epoch numbers being 2, 3, 4, ... Once maximum number epochs are finished or Simulation Manager receives an Error message , Simulation Manager sends a SimState message \"stopped\". Simulation is stopped. Simulation Manager closes itself after sending the last SimState message .","title":"Workflow"},{"location":"core_simulationmanager/#environment-variables","text":"When using the SimCES platform, the Platform Manager will sends all the requires variables to the Simulation Manager according to the configuration of the simulation run. Variable name Datatype Corresponding Start message attribute Description SIMULATION_ID ISO 8601; see (a) SimulationId The id for the simulation run. It is expected to correspond to the current time given in UTC time zone. SIMULATION_MANAGER_NAME String ManagerName (b) The identifier, i.e. the SourceProcessId, for the Simulation Manager instance. SIMULATION_COMPONENTS String Components (b) A comma-separated string of the names of the components participating in the simulation. The names MUST correspond to the identifiers (i.e. the SourceProcessId) used by the components. SIMULATION_NAME String SimulationName The name of the simulation run. SIMULATION_DESCRIPTION String SimulationDescription The description of the simulation run. SIMULATION_EPOCH_LENGTH Integer (> 0) EpochLength (b) The epoch length in seconds. SIMULATION_INITIAL_START_TIME ISO 8601; see (a) InitialStartTime (b) The start time for the first epoch as ISO 8601 formatted datetime string. SIMULATION_MAX_EPOCHS Integer (> 0) MaxEpochCount (b) The maximum number of epochs in the simulation run. SIMULATION_EPOCH_TIMER_INTERVAL Float (> 0) EpochTimerInterval (b) The time interval in seconds until Simulation Manager resends an Epoch message if some component has not responded with Status message. SIMULATION_MAX_EPOCH_RESENDS Integer (>= 0) MaxEpochResendCount (b) The maximum number of Epoch message resends Simulation Manager can try for each epoch. (a) Date and time included Accuracy 1 ms Time zone information MUST be included (b) In the Simulation Manager block of the Start message In addition to those variables given above, Simulation Manager also needs the environment variables that relate to connecting to the RabbitMQ message bus.","title":"Environment variables"},{"location":"core_soa/","text":"Service-oriented architecture The simulation platform aims at facilitating the design and maintenance of components, so each developer SHOULD follow the principles of Service-oriented Architecture (SOA). SOA aims to realize a world where the pieces of systems are abstract services with few dependencies. In some cases, SOA can increase the work required to design an individual component, but this is compensated with easier maintenance and scalability during the lifecycle of the system. SOA has a number of principles that the developers should follow. The following apply in the simulation platform. Loose coupling \"ensure that the service contract is not tightly coupled to the service consumers and to the underlying service logic and implementation\" https://en.wikipedia.org/wiki/Service_loose_coupling_principle -> Do not let product- or runtime-specific features be visible in interfaces! Abstraction \"information published in a service contract is limited to what is required to effectively utilize the service\" https://en.wikipedia.org/wiki/Service_abstraction Reusability \"to create services that can be reused across a business\" https://en.wikipedia.org/wiki/Service_reusability_principle Composability \"can be reused in multiple solutions that are themselves made up of composed services\" https://en.wikipedia.org/wiki/Service_composability_principle Autonomy \"to provide services with improved independence from their execution environments\" https://en.wikipedia.org/wiki/Service_autonomy_principle -> Do not let product- or runtime-specific features be visible in interfaces! Standized service contract \"service contracts within a service inventory (enterprise or domain) adhere to the same set of design standards\" https://en.wikipedia.org/wiki/Standardized_service_contract","title":"Service-oriented architecture"},{"location":"core_soa/#service-oriented-architecture","text":"The simulation platform aims at facilitating the design and maintenance of components, so each developer SHOULD follow the principles of Service-oriented Architecture (SOA). SOA aims to realize a world where the pieces of systems are abstract services with few dependencies. In some cases, SOA can increase the work required to design an individual component, but this is compensated with easier maintenance and scalability during the lifecycle of the system. SOA has a number of principles that the developers should follow. The following apply in the simulation platform.","title":"Service-oriented architecture"},{"location":"core_soa/#loose-coupling","text":"\"ensure that the service contract is not tightly coupled to the service consumers and to the underlying service logic and implementation\" https://en.wikipedia.org/wiki/Service_loose_coupling_principle -> Do not let product- or runtime-specific features be visible in interfaces!","title":"Loose coupling"},{"location":"core_soa/#abstraction","text":"\"information published in a service contract is limited to what is required to effectively utilize the service\" https://en.wikipedia.org/wiki/Service_abstraction","title":"Abstraction"},{"location":"core_soa/#reusability","text":"\"to create services that can be reused across a business\" https://en.wikipedia.org/wiki/Service_reusability_principle","title":"Reusability"},{"location":"core_soa/#composability","text":"\"can be reused in multiple solutions that are themselves made up of composed services\" https://en.wikipedia.org/wiki/Service_composability_principle","title":"Composability"},{"location":"core_soa/#autonomy","text":"\"to provide services with improved independence from their execution environments\" https://en.wikipedia.org/wiki/Service_autonomy_principle -> Do not let product- or runtime-specific features be visible in interfaces!","title":"Autonomy"},{"location":"core_soa/#standized-service-contract","text":"\"service contracts within a service inventory (enterprise or domain) adhere to the same set of design standards\" https://en.wikipedia.org/wiki/Standardized_service_contract","title":"Standized service contract"},{"location":"core_start-simulation/","text":"Starting a general simulation To start a new simulation run: Specify the simulation by creating a configuration file. ( Specifying the simulation configuration file ) Use the start script to start the simulation. ( Starting a new simulation run ) Specifying the simulation configuration file The simulation configuration file specifies parameters for the core platform components, for example the epoch length, and defines all the components and their parameters that will participate in the simulation. The configuration file uses YAML format and has two sections: Simulation for specifying the core platform parameters and Components for specifying the participating components and their parameters. The component section has a close relation to the Start message . YAML uses Python style indentation to indicate nesting and it is advisable to be consistent in the use of the indentation. All the examples given here use indentation with 4 white spaces. Example configuration file with an explanation for the specified simulation is found at the section Example simulation configuration file . Configuration file template and additional specification is found at the section Simulation configuration file specification . Example simulation configuration file Example simulation configuration file for a simulation where a Grid component has been added to the EC scenario can be found at simulation_configuration_grid.yml : Simulation: Name: \"Energy community with Grid demo\" Description: \"This scenario includes a grid simulation with OpenDSS.\" InitialStartTime: \"2020-06-25T00:00:00.000+03:00\" EpochLength: 3600 MaxEpochCount: 24 # Optional settings for the Simulation Manager ManagerName: \"Manager\" EpochTimerInterval: 20 MaxEpochResendCount: 2 # Optional settings for the Log Writer MessageBufferMaxDocumentCount: 10 MessageBufferMaxInterval: 5.0 Components: # these are the names of the component implementations (defined in the supported components JSON file) # duplication_count is reserved keyword and cannot be used as a parameter for a component instance Grid: # The externally managed Grid component type Grid: # The name of the Grid instance in the simulation run ModelName: \"EC_Network\" # The grid model name that will be sent as a part of the Start message Symmetrical: false Dummy: # The platform managed Dummy component to slow down the simulation dummy: # The base name for the Dummy components duplication_count: 2 # Create 2 components, named dummy_1 and dummy_2, with otherwise identical parameters MinSleepTime: 1 MaxSleepTime: 5 StaticTimeSeriesResource: # The platform managed Static Time Series Resource component load1: # The name of this StaticTimeSeriesResource instance in the simulation run ResourceType: \"Load\" # corresponds to RESOURCE_TYPE environment variable ResourceStateFile: \"/resources/Load1.csv\" # corresponds to RESOURCE_STATE_FILE environment variable load2: ResourceType: \"Load\" ResourceStateFile: \"/resources/Load2.csv\" load3: ResourceType: \"Load\" ResourceStateFile: \"/resources/Load3.csv\" load4: ResourceType: \"Load\" ResourceStateFile: \"/resources/Load4.csv\" ev: ResourceType: \"Load\" ResourceStateFile: \"/resources/EV.csv\" pv_small: ResourceType: \"Generator\" ResourceStateFile: \"/resources/PV_small.csv\" pv_large: ResourceType: \"Generator\" ResourceStateFile: \"/resources/PV_large.csv\" Note that, while string values can be in most cases be given without double quotes in YAML files, they are consistently used in the above example to avoid any possible edge cases where the strings without quotes might be interpreted as something other than a single string value. A breakdown of parameters set in the example configuration using the knowledge of the default values from Start message and component manifest files for the participating components is given below. A more detailed explanation on what each parameter means for the used components can be found on the Start message page. The required overall parameters The simulation name is set to \" Energy community with Grid demo \" The description for the simulation is set to \" This scenario includes a grid simulation with OpenDSS. \" The start time for the first epoch in set to \" 2020-06-25T00:00:00.000+03:00 \" or to \" 2020-06-24T21:00:00.000Z \" in UTC time The duration of each epoch is set to 3600 seconds, i.e. 1 hour Maximum number of epochs is set to 24 , i.e. the simulation will last 24 hours or 1 day The optional overall parameters The Simulation Manager name in the simulation is set to \" Manager \", the default name would be \" SimulationManager \" The time duration until Simulation Manager tries to resend the epoch message is set to 20 seconds, the default duration would be 120 seconds The maximum number of epoch resends the Simulation Manager is allowed to try before ending the simulation is set to 2 epoch resends, the default would be 5 epoch resends The maximum number of messages the buffer in Log Writer can have is set to 10 messages, the default would be 20 messages The maximum time interval until the message buffer in Log Writer is cleared is set to 5 seconds, the default would be 10 seconds The simulation will have one Grid component participating that is externally managed The name of the Grid component is set to \" Grid \" The ModelName parameter for the Grid is set to \" EC_Network \" The Symmetrical parameter for the Grid is set to the boolean value false The optional parameter MaxControlCount for the Grid will be set to the default value 15 The optional parameter ModelVoltageBand for the Grid will be set to the default value 0.15 The simulation will have two Dummy components that are platform managed Using the duplicate_count attribute there will be 2 Dummy components with identical parameters created. The component names will be in the format <basename>_<number> , i.e. \" dummy_1 \" and \" dummy_2 \" since the base name is set to \" dummy \" The MinSleepTime parameter for the Dummy components is set to 1 The MaxSleepTime parameter for the Dummy components is set to 5 All the other parameters for the Dummy components, i.e. WarningChance , SendMissChance , ReceiveMissChance and ErrorChance , are set to the their default value of 0.0 The simulation will have 7 Static Time Series Resource components that are platform managed The resource components representing loads are named \" load1 \" \" load2 \" \" load3 \" \" load4 \" and \" ev \" The ResourceType parameter is set to \" Load \" in all load components The ResourceStateFile parameter is set to the filename where the resource component will find it after it has been deployed, for example the filename for the \" load1 \" component is set to \" /resources/Load1.csv \" Note, that the filename given here refer to the filenames inside the Docker containers and thus they all include \" /resources \" at the beginning, as will the case when they are made available according to the section Making input files available for the platform . The resource components representing generators are named \" pv_small \" and \" pv_large \" The ResourceType parameter is set to \" Generator \" in both generator components The ResourceStateFile parameter is set to the filename where the resource component will find it after it has been deployed, for example the filename for the \" pv_small \" component is set to \" /resources/PV_small.csv \" Simulation configuration file specification The YAML configuration for a simulation run uses the following format: Simulation: # Parameters for the core components Components: # Definitions for all the participating components and their parameters File simulation_configuration_template.yml contains a template that can be used as a base for defining new simulations. The template file contains comments that explain the structure of the file. The definitions for the participating components have a correspondence to the process parameters blocks in the Start message An example Start message that corresponds to the template configuration is given in instructions/start_message_template.json . Starting a new simulation run To start a new simulation run, use Bash compatible terminal to navigate to the installation folder and use the command source start_simulation.sh <configuration_file> where <configuration_file> is the filename containing the YAML configuration for the simulation run.","title":"Starting a simulation"},{"location":"core_start-simulation/#starting-a-general-simulation","text":"To start a new simulation run: Specify the simulation by creating a configuration file. ( Specifying the simulation configuration file ) Use the start script to start the simulation. ( Starting a new simulation run )","title":"Starting a general simulation"},{"location":"core_start-simulation/#specifying-the-simulation-configuration-file","text":"The simulation configuration file specifies parameters for the core platform components, for example the epoch length, and defines all the components and their parameters that will participate in the simulation. The configuration file uses YAML format and has two sections: Simulation for specifying the core platform parameters and Components for specifying the participating components and their parameters. The component section has a close relation to the Start message . YAML uses Python style indentation to indicate nesting and it is advisable to be consistent in the use of the indentation. All the examples given here use indentation with 4 white spaces. Example configuration file with an explanation for the specified simulation is found at the section Example simulation configuration file . Configuration file template and additional specification is found at the section Simulation configuration file specification .","title":"Specifying the simulation configuration file"},{"location":"core_start-simulation/#example-simulation-configuration-file","text":"Example simulation configuration file for a simulation where a Grid component has been added to the EC scenario can be found at simulation_configuration_grid.yml : Simulation: Name: \"Energy community with Grid demo\" Description: \"This scenario includes a grid simulation with OpenDSS.\" InitialStartTime: \"2020-06-25T00:00:00.000+03:00\" EpochLength: 3600 MaxEpochCount: 24 # Optional settings for the Simulation Manager ManagerName: \"Manager\" EpochTimerInterval: 20 MaxEpochResendCount: 2 # Optional settings for the Log Writer MessageBufferMaxDocumentCount: 10 MessageBufferMaxInterval: 5.0 Components: # these are the names of the component implementations (defined in the supported components JSON file) # duplication_count is reserved keyword and cannot be used as a parameter for a component instance Grid: # The externally managed Grid component type Grid: # The name of the Grid instance in the simulation run ModelName: \"EC_Network\" # The grid model name that will be sent as a part of the Start message Symmetrical: false Dummy: # The platform managed Dummy component to slow down the simulation dummy: # The base name for the Dummy components duplication_count: 2 # Create 2 components, named dummy_1 and dummy_2, with otherwise identical parameters MinSleepTime: 1 MaxSleepTime: 5 StaticTimeSeriesResource: # The platform managed Static Time Series Resource component load1: # The name of this StaticTimeSeriesResource instance in the simulation run ResourceType: \"Load\" # corresponds to RESOURCE_TYPE environment variable ResourceStateFile: \"/resources/Load1.csv\" # corresponds to RESOURCE_STATE_FILE environment variable load2: ResourceType: \"Load\" ResourceStateFile: \"/resources/Load2.csv\" load3: ResourceType: \"Load\" ResourceStateFile: \"/resources/Load3.csv\" load4: ResourceType: \"Load\" ResourceStateFile: \"/resources/Load4.csv\" ev: ResourceType: \"Load\" ResourceStateFile: \"/resources/EV.csv\" pv_small: ResourceType: \"Generator\" ResourceStateFile: \"/resources/PV_small.csv\" pv_large: ResourceType: \"Generator\" ResourceStateFile: \"/resources/PV_large.csv\" Note that, while string values can be in most cases be given without double quotes in YAML files, they are consistently used in the above example to avoid any possible edge cases where the strings without quotes might be interpreted as something other than a single string value. A breakdown of parameters set in the example configuration using the knowledge of the default values from Start message and component manifest files for the participating components is given below. A more detailed explanation on what each parameter means for the used components can be found on the Start message page. The required overall parameters The simulation name is set to \" Energy community with Grid demo \" The description for the simulation is set to \" This scenario includes a grid simulation with OpenDSS. \" The start time for the first epoch in set to \" 2020-06-25T00:00:00.000+03:00 \" or to \" 2020-06-24T21:00:00.000Z \" in UTC time The duration of each epoch is set to 3600 seconds, i.e. 1 hour Maximum number of epochs is set to 24 , i.e. the simulation will last 24 hours or 1 day The optional overall parameters The Simulation Manager name in the simulation is set to \" Manager \", the default name would be \" SimulationManager \" The time duration until Simulation Manager tries to resend the epoch message is set to 20 seconds, the default duration would be 120 seconds The maximum number of epoch resends the Simulation Manager is allowed to try before ending the simulation is set to 2 epoch resends, the default would be 5 epoch resends The maximum number of messages the buffer in Log Writer can have is set to 10 messages, the default would be 20 messages The maximum time interval until the message buffer in Log Writer is cleared is set to 5 seconds, the default would be 10 seconds The simulation will have one Grid component participating that is externally managed The name of the Grid component is set to \" Grid \" The ModelName parameter for the Grid is set to \" EC_Network \" The Symmetrical parameter for the Grid is set to the boolean value false The optional parameter MaxControlCount for the Grid will be set to the default value 15 The optional parameter ModelVoltageBand for the Grid will be set to the default value 0.15 The simulation will have two Dummy components that are platform managed Using the duplicate_count attribute there will be 2 Dummy components with identical parameters created. The component names will be in the format <basename>_<number> , i.e. \" dummy_1 \" and \" dummy_2 \" since the base name is set to \" dummy \" The MinSleepTime parameter for the Dummy components is set to 1 The MaxSleepTime parameter for the Dummy components is set to 5 All the other parameters for the Dummy components, i.e. WarningChance , SendMissChance , ReceiveMissChance and ErrorChance , are set to the their default value of 0.0 The simulation will have 7 Static Time Series Resource components that are platform managed The resource components representing loads are named \" load1 \" \" load2 \" \" load3 \" \" load4 \" and \" ev \" The ResourceType parameter is set to \" Load \" in all load components The ResourceStateFile parameter is set to the filename where the resource component will find it after it has been deployed, for example the filename for the \" load1 \" component is set to \" /resources/Load1.csv \" Note, that the filename given here refer to the filenames inside the Docker containers and thus they all include \" /resources \" at the beginning, as will the case when they are made available according to the section Making input files available for the platform . The resource components representing generators are named \" pv_small \" and \" pv_large \" The ResourceType parameter is set to \" Generator \" in both generator components The ResourceStateFile parameter is set to the filename where the resource component will find it after it has been deployed, for example the filename for the \" pv_small \" component is set to \" /resources/PV_small.csv \"","title":"Example simulation configuration file"},{"location":"core_start-simulation/#simulation-configuration-file-specification","text":"The YAML configuration for a simulation run uses the following format: Simulation: # Parameters for the core components Components: # Definitions for all the participating components and their parameters File simulation_configuration_template.yml contains a template that can be used as a base for defining new simulations. The template file contains comments that explain the structure of the file. The definitions for the participating components have a correspondence to the process parameters blocks in the Start message An example Start message that corresponds to the template configuration is given in instructions/start_message_template.json .","title":"Simulation configuration file specification"},{"location":"core_start-simulation/#starting-a-new-simulation-run","text":"To start a new simulation run, use Bash compatible terminal to navigate to the installation folder and use the command source start_simulation.sh <configuration_file> where <configuration_file> is the filename containing the YAML configuration for the simulation run.","title":"Starting a new simulation run"},{"location":"core_stop-simulation/","text":"Stopping a running simulation After a successful simulation all the components that participated in the simulation should be closed automatically. However, if there were some errors during the simulation run, some components might be left running indefinitely unless they are manually stopped. To stop a running simulation by closing all the platform managed containers, using Bash compatible terminal navigate to the installation folder, by default this is platform , and use the command: source stop_simulation.sh <id_number> where <id_number> is given by the simulation platform after the simulation was started. You can use command docker ps --filter name=Sim --format \"{{.Names}}\" to see all the currently running containers started by the simulation platform. Note, that this will only stop the platform managed components and does not affect the externally managed components in any way.","title":"Stop simulation"},{"location":"core_stop-simulation/#stopping-a-running-simulation","text":"After a successful simulation all the components that participated in the simulation should be closed automatically. However, if there were some errors during the simulation run, some components might be left running indefinitely unless they are manually stopped. To stop a running simulation by closing all the platform managed containers, using Bash compatible terminal navigate to the installation folder, by default this is platform , and use the command: source stop_simulation.sh <id_number> where <id_number> is given by the simulation platform after the simulation was started. You can use command docker ps --filter name=Sim --format \"{{.Names}}\" to see all the currently running containers started by the simulation platform. Note, that this will only stop the platform managed components and does not affect the externally managed components in any way.","title":"Stopping a running simulation"},{"location":"core_time/","text":"Time and synchronization with epochs The simulator components are distributed but should still simulate together, which necessitates a mechanism to synchronize time. This is implemented with epochs . An epoch represents a period of simulated time, e.g., today between 12:00 and 12:15 p.m. The length of epoch can be varied depending on the desired resolution of simulation. As epochs always represent simulated time, the duration is different in real time. This depends mainly on how fast the slowest component can simulate. For all epochs it holds that (\"Eno\" is the ordinal number of the epoch): epoch.StartTime < epoch.EndTime epoch'.Eno = epoch.Eno + 1 => epoch'.StartTime = epoch.EndTime In simulation, the first epoch has Eno = 1 Within epoch, epoch.StartTime is included, whereas epoch.EndTime is excluded To start an epoch, the platform publishes an epoch message. Once the components receive this, they have a permission to start calculating their result for the current epoch. Some components can additionally require data from other components during the epoch, which affects when the calculation can occur. Once a component has published its result, it publishes a \"ready\" message to inform the platform that it has nothing more to do during the epoch. Once the platform has received a ready message from all components, the next epoch can start. This means that the simulation runs with best effort and one component is always the bottleneck. The following figure illustrates how an epoch message is delivered to components. There are components C1-C4. As the platform publishes an epoch message, this is delivered to all components to signal what time period is to be simulated. The following figure illustrates how components communicate their results and readiness once an epoch has started. Each component publishes a result (res1-res4) and reports it has finished by publishing a ready message (rd1-rd4). However, certain components need the result of another component to calculate their result. In the figure, C3 can only proceed once it has the result of C1 and C2, and C4 needs the result of C2 and C3, respectively. That is, some components in this example execute sequentially. In the figures above, the messages are published as follows: Platform publishes an epoch message and delivers this to C1, C2, C3 and C4 The following workflows occur in parallel: C1 Publish res1 Publish rd1 C2 Publish res2 Publish rd2 C3 Wait until res1 and res2 have been received Publish res3 Publish rd3 C4 Wait until res2 and res3 have been received Publish rd4","title":"Time and synchronization with epochs"},{"location":"core_time/#time-and-synchronization-with-epochs","text":"The simulator components are distributed but should still simulate together, which necessitates a mechanism to synchronize time. This is implemented with epochs . An epoch represents a period of simulated time, e.g., today between 12:00 and 12:15 p.m. The length of epoch can be varied depending on the desired resolution of simulation. As epochs always represent simulated time, the duration is different in real time. This depends mainly on how fast the slowest component can simulate. For all epochs it holds that (\"Eno\" is the ordinal number of the epoch): epoch.StartTime < epoch.EndTime epoch'.Eno = epoch.Eno + 1 => epoch'.StartTime = epoch.EndTime In simulation, the first epoch has Eno = 1 Within epoch, epoch.StartTime is included, whereas epoch.EndTime is excluded To start an epoch, the platform publishes an epoch message. Once the components receive this, they have a permission to start calculating their result for the current epoch. Some components can additionally require data from other components during the epoch, which affects when the calculation can occur. Once a component has published its result, it publishes a \"ready\" message to inform the platform that it has nothing more to do during the epoch. Once the platform has received a ready message from all components, the next epoch can start. This means that the simulation runs with best effort and one component is always the bottleneck. The following figure illustrates how an epoch message is delivered to components. There are components C1-C4. As the platform publishes an epoch message, this is delivered to all components to signal what time period is to be simulated. The following figure illustrates how components communicate their results and readiness once an epoch has started. Each component publishes a result (res1-res4) and reports it has finished by publishing a ready message (rd1-rd4). However, certain components need the result of another component to calculate their result. In the figure, C3 can only proceed once it has the result of C1 and C2, and C4 needs the result of C2 and C3, respectively. That is, some components in this example execute sequentially. In the figures above, the messages are published as follows: Platform publishes an epoch message and delivers this to C1, C2, C3 and C4 The following workflows occur in parallel: C1 Publish res1 Publish rd1 C2 Publish res2 Publish rd2 C3 Wait until res1 and res2 have been received Publish res3 Publish rd3 C4 Wait until res2 and res3 have been received Publish rd4","title":"Time and synchronization with epochs"},{"location":"core_topics-queues-exchanges/","text":"Communication with topics, queues and exchanges The simulation platform communicates in a publish-subscribe fashion to realize loose coupling. This means that the components do not directly request anything from each other but rather announce which information they are interested in. Then, the platform delivers this information. Advantages: The sender/producer does not need to know which receivers/consumers gets the message. All interested consumers get it. The consumer does not need to know the sender - only the type of data. The consumer does not need to process the incoming immediately, the message can stay in the queue until the consumer has time to process it. This is sometimes called store-and-forward paradigm. Topics and queues Publish-subscribe communication is implemented with a message bus that routes messages with topics and message queues. A topic is a string that identifies a subject of interest. Any piece of software can publish to the topic, and any piece of software can subscribe to receive messages from the topic. To receive messages, each subscriber creates a message queue and associates this to one or more topics. The motivation of queues is to enable asynchronous message processing, as the recipient can delay message reception without blocking any other node. Each topic can have an arbitrary number of subscriber queues associated. If a topic has no subscribers, no one receives message from the topic. Respectively, if there are multiple subscribers, the message bus clones each message for each subscriber. The following figure illustrates message routing with topics and queues. The message bus manages the topics and queues. There is one topic called \"LivingRoom.Temperature.T1\", and subscribers Y and Z have created and associated a message queue. Whenever publisher X publishes to the topic, the message bus deliver this message to both queues. Subscribers Y and Z can receive messages from their queue when they have time. Meanwhile, any messages remain in the queue. Exchanges To implement the message bus, the simulation platform uses AMQP 0-9-1 as the protocol and RabbitMQ as the product. Topic-based communication is only one communication mode in AMQP 0-9-1, but the others are irrelevant here. In addition, please note that AMQP has multiple versions that are mutually incompatible. In AMQP 0-9-1, each topic resides in an exchange. Exchanges can realize a sandbox that isolates topics from each other. This is a useful mechanism, for example, when the intention is to run concurrent simulations in the same platform. The platform specifies two types of exchange: Simulation-specific exchange. The platform creates one for each simulation run, as this prevents any interference between simulation runs and enables even concurrent simulations. Management exchange. There is only one of these. The management exchange is there to enable communication with components even when no simulation is running. The details of these exchanges are explained in the pages Simulation-specific exchange and Management exchange . Hierarchical topic names and wildcards In AMQP 0-9-1, a topic name can be hierarchical. In this case, the hierarchy levels are separated by periods, such as \"LivingRoom.Temperature.T1\", \"LivingRoom.Temperature.T2\" and \"LivingRoom.Humidity.H1\" for a sensor system in a residence. When subscribing for an AMQP topic, you can use wildcards if appropriate. These are '*' for a single hierarchy level and '#' for any number of levels. The subscription can be, for example: \"LivingRoom.#\" for all sensors in the living room \"*.Temperature.#\" for all temperature sensors in the residence It is notable, however, that naming must be systematic to allow wildcards to work.","title":"Topics, queues and exchanges"},{"location":"core_topics-queues-exchanges/#communication-with-topics-queues-and-exchanges","text":"The simulation platform communicates in a publish-subscribe fashion to realize loose coupling. This means that the components do not directly request anything from each other but rather announce which information they are interested in. Then, the platform delivers this information. Advantages: The sender/producer does not need to know which receivers/consumers gets the message. All interested consumers get it. The consumer does not need to know the sender - only the type of data. The consumer does not need to process the incoming immediately, the message can stay in the queue until the consumer has time to process it. This is sometimes called store-and-forward paradigm.","title":"Communication with topics, queues and exchanges"},{"location":"core_topics-queues-exchanges/#topics-and-queues","text":"Publish-subscribe communication is implemented with a message bus that routes messages with topics and message queues. A topic is a string that identifies a subject of interest. Any piece of software can publish to the topic, and any piece of software can subscribe to receive messages from the topic. To receive messages, each subscriber creates a message queue and associates this to one or more topics. The motivation of queues is to enable asynchronous message processing, as the recipient can delay message reception without blocking any other node. Each topic can have an arbitrary number of subscriber queues associated. If a topic has no subscribers, no one receives message from the topic. Respectively, if there are multiple subscribers, the message bus clones each message for each subscriber. The following figure illustrates message routing with topics and queues. The message bus manages the topics and queues. There is one topic called \"LivingRoom.Temperature.T1\", and subscribers Y and Z have created and associated a message queue. Whenever publisher X publishes to the topic, the message bus deliver this message to both queues. Subscribers Y and Z can receive messages from their queue when they have time. Meanwhile, any messages remain in the queue.","title":"Topics and queues"},{"location":"core_topics-queues-exchanges/#exchanges","text":"To implement the message bus, the simulation platform uses AMQP 0-9-1 as the protocol and RabbitMQ as the product. Topic-based communication is only one communication mode in AMQP 0-9-1, but the others are irrelevant here. In addition, please note that AMQP has multiple versions that are mutually incompatible. In AMQP 0-9-1, each topic resides in an exchange. Exchanges can realize a sandbox that isolates topics from each other. This is a useful mechanism, for example, when the intention is to run concurrent simulations in the same platform. The platform specifies two types of exchange: Simulation-specific exchange. The platform creates one for each simulation run, as this prevents any interference between simulation runs and enables even concurrent simulations. Management exchange. There is only one of these. The management exchange is there to enable communication with components even when no simulation is running. The details of these exchanges are explained in the pages Simulation-specific exchange and Management exchange .","title":"Exchanges"},{"location":"core_topics-queues-exchanges/#hierarchical-topic-names-and-wildcards","text":"In AMQP 0-9-1, a topic name can be hierarchical. In this case, the hierarchy levels are separated by periods, such as \"LivingRoom.Temperature.T1\", \"LivingRoom.Temperature.T2\" and \"LivingRoom.Humidity.H1\" for a sensor system in a residence. When subscribing for an AMQP topic, you can use wildcards if appropriate. These are '*' for a single hierarchy level and '#' for any number of levels. The subscription can be, for example: \"LivingRoom.#\" for all sensors in the living room \"*.Temperature.#\" for all temperature sensors in the residence It is notable, however, that naming must be systematic to allow wildcards to work.","title":"Hierarchical topic names and wildcards"},{"location":"core_topics/","text":"Topics (core) The following table lists the topic names used by the core platform and which message type occurs in each topic. The table below is normative. This means that if any other page has a conflicting topic name, this table has the precedence. Topic name Message type Purpose (see 1) Exchange (see 2) Publisher(s) Subscriber(s) Motivation Epoch Epoch Reporting S Simulation Manager (All non-core components) Coordinating execution of epochs SimState SimState Reporting S Simulation Manager (All non-core components) Controlling execution of simulation Start Start Starting M Platform Manager (All externally managed non-core components) Signalling start of simulation; deliver parameters Status.Error Status Reporting S (Any non-core component) Simulation Manager Error reporting Status.Ready Status Reporting S (Any non-core component) Simulation Manager (+ any non-core component that requires the information about other components readiness) Reporting readiness to start next epoch (1) Purposes: Starting: starting a simulation run (once for each simulation run) Reporting: communication of data during simulation (multiple times during a simulation run) (2) Exchanges: M: Management Exchange S: Simulation-specific Exchange","title":"Topics (core)"},{"location":"core_topics/#topics-core","text":"The following table lists the topic names used by the core platform and which message type occurs in each topic. The table below is normative. This means that if any other page has a conflicting topic name, this table has the precedence. Topic name Message type Purpose (see 1) Exchange (see 2) Publisher(s) Subscriber(s) Motivation Epoch Epoch Reporting S Simulation Manager (All non-core components) Coordinating execution of epochs SimState SimState Reporting S Simulation Manager (All non-core components) Controlling execution of simulation Start Start Starting M Platform Manager (All externally managed non-core components) Signalling start of simulation; deliver parameters Status.Error Status Reporting S (Any non-core component) Simulation Manager Error reporting Status.Ready Status Reporting S (Any non-core component) Simulation Manager (+ any non-core component that requires the information about other components readiness) Reporting readiness to start next epoch (1) Purposes: Starting: starting a simulation run (once for each simulation run) Reporting: communication of data during simulation (multiple times during a simulation run) (2) Exchanges: M: Management Exchange S: Simulation-specific Exchange","title":"Topics (core)"},{"location":"core_ucum/","text":"Units of measure (UCUM) What is UCUM and why? There are multiple ways to specify a unit of measure in a software-interpretable message, which can cause incompatibility. It is not always clear what a particular symbol means. For example, \"C\" could refer to \"Celsius\" or \"Coulomb\", and a human being could come up multiple ways to express Celsius values, such as: \"C\", \"deg_C\", \"DegC\", \"Cel\" or \"Celsius\". Even if a human reader understood the meaning, this often does not apply to software. In principle, this challenge applies to any unit of measure. This is what The Unified Code for Units of Measure (UCUM) is for. UCUM is introduced as follows (from https://ucum.org/trac ): The Unified Code for Units of Measure (UCUM) is a code system intended to include all units of measures being contemporarily used in international science, engineering, and business. The purpose is to facilitate unambiguous electronic communication of quantities together with their units. The focus is on electronic communication, as opposed to communication between humans. The Unified Code for Units of Measures -- has already been adopted by some standard organizations such as DICOM, HL7 and has been referenced as best practice by the Open Geospatial Consortium in their Web Map Service (WMS) and Geography Markup Language (GML) implementation specifications. UCUM is not the first specification to encode units of measure. However, UCUM is the best solution known to exist. The advantages include: openly available at no cost coverage (in principle, you can express any unit of measure in the world) human-readability and intuitiveness (in contrast to some specifications that use numeric identifiers, such as UNECE: http://tfig.unece.org/contents/recommendation-20.htm) A web service that can be used to check whether an expression is a valid UCUM unit: https://ucum.nlm.nih.gov/ucum-lhc/demo.html UCUM in SimCES All fields that express a unit of measure SHOULD comply with the case-sensitive UCUM format (see https://ucum.org/ucum.html ). In the tables of UCUM specification, these are defined in the column \"c/s\". Units possibly beneficial in simulation UCUM is not limited to these units, but these can be beneficial. Category Name UCUM presentation Comment General per unit {pu} The unit is effectively \"1\", which is the default unit. However, curly braces enclose an annotation that elaborates what the value means. Current ampere A Energy megawatt hour MW.h Percentage Percentage % Power (apparent) kilovolt ampere kV.A Power (reactive) kilovolt ampere (reactive) kV.A{r} Power (real) megawatt MW Price per megawatt hour {EUR}/(MW.h) Currencies are not supported in UCUM. Therefore, \"EUR\" is merely an annotation here (i.e., in curly brackets) and means \"1\". \"EUR\" is a currency code standardized in ISO 4217. Temperature celsius Cel Voltage kilovolt kV Unit rules Basic UCUM writes many of the typical units as we would think. E.g.:, meter: \"m\", second: \"s\", Joule: \"J\". However, some unit can cause ambiquity and therefore have another definition. E.g.: Celsius: \"Cel\", pH: \"[pH]\". Prefixes Prefixes are supported. E.g.: tera: \"T\", mega: \"M\", kilo: \"k\". More prefixes: see \u00a727 \"prefixes\" at https://ucum.org/ucum.html#para-27 . Square brackets At https://ucum.org/ucum.html#para-14 : \u00a714 square brackets. Square brackets enclose suffixes of unit symbols that change the meaning of a unit stem. For example: UCUM c/s presentation Meaning mm[Hg] millimeter Mercury column [ppm] Parts per million Curly braces At https://ucum.org/ucum.html#para-12 : \u00a712 curly braces. Curly braces may be used to enclose annotations that are often written in place of units or behind units but that do not have a proper meaning of a unit and do not change the meaning of a unit. For example one can write \u201c%{vol}\u201d, \u201ckg{total}\u201d, or \u201c{RBC}\u201d (for \u201cred blood cells\u201d) as pseudo-units. However, these annotations do not have any effect on the semantics, which is why these example expressions are equivalent to \u201c%\u201d, \u201ckg\u201d, and \u201c1\u201d respectively.","title":"Units of measure (UCUM)"},{"location":"core_ucum/#units-of-measure-ucum","text":"","title":"Units of measure (UCUM)"},{"location":"core_ucum/#what-is-ucum-and-why","text":"There are multiple ways to specify a unit of measure in a software-interpretable message, which can cause incompatibility. It is not always clear what a particular symbol means. For example, \"C\" could refer to \"Celsius\" or \"Coulomb\", and a human being could come up multiple ways to express Celsius values, such as: \"C\", \"deg_C\", \"DegC\", \"Cel\" or \"Celsius\". Even if a human reader understood the meaning, this often does not apply to software. In principle, this challenge applies to any unit of measure. This is what The Unified Code for Units of Measure (UCUM) is for. UCUM is introduced as follows (from https://ucum.org/trac ): The Unified Code for Units of Measure (UCUM) is a code system intended to include all units of measures being contemporarily used in international science, engineering, and business. The purpose is to facilitate unambiguous electronic communication of quantities together with their units. The focus is on electronic communication, as opposed to communication between humans. The Unified Code for Units of Measures -- has already been adopted by some standard organizations such as DICOM, HL7 and has been referenced as best practice by the Open Geospatial Consortium in their Web Map Service (WMS) and Geography Markup Language (GML) implementation specifications. UCUM is not the first specification to encode units of measure. However, UCUM is the best solution known to exist. The advantages include: openly available at no cost coverage (in principle, you can express any unit of measure in the world) human-readability and intuitiveness (in contrast to some specifications that use numeric identifiers, such as UNECE: http://tfig.unece.org/contents/recommendation-20.htm) A web service that can be used to check whether an expression is a valid UCUM unit: https://ucum.nlm.nih.gov/ucum-lhc/demo.html","title":"What is UCUM and why?"},{"location":"core_ucum/#ucum-in-simces","text":"All fields that express a unit of measure SHOULD comply with the case-sensitive UCUM format (see https://ucum.org/ucum.html ). In the tables of UCUM specification, these are defined in the column \"c/s\".","title":"UCUM in SimCES"},{"location":"core_ucum/#units-possibly-beneficial-in-simulation","text":"UCUM is not limited to these units, but these can be beneficial. Category Name UCUM presentation Comment General per unit {pu} The unit is effectively \"1\", which is the default unit. However, curly braces enclose an annotation that elaborates what the value means. Current ampere A Energy megawatt hour MW.h Percentage Percentage % Power (apparent) kilovolt ampere kV.A Power (reactive) kilovolt ampere (reactive) kV.A{r} Power (real) megawatt MW Price per megawatt hour {EUR}/(MW.h) Currencies are not supported in UCUM. Therefore, \"EUR\" is merely an annotation here (i.e., in curly brackets) and means \"1\". \"EUR\" is a currency code standardized in ISO 4217. Temperature celsius Cel Voltage kilovolt kV","title":"Units possibly beneficial in simulation"},{"location":"core_ucum/#unit-rules","text":"","title":"Unit rules"},{"location":"core_ucum/#basic","text":"UCUM writes many of the typical units as we would think. E.g.:, meter: \"m\", second: \"s\", Joule: \"J\". However, some unit can cause ambiquity and therefore have another definition. E.g.: Celsius: \"Cel\", pH: \"[pH]\".","title":"Basic"},{"location":"core_ucum/#prefixes","text":"Prefixes are supported. E.g.: tera: \"T\", mega: \"M\", kilo: \"k\". More prefixes: see \u00a727 \"prefixes\" at https://ucum.org/ucum.html#para-27 .","title":"Prefixes"},{"location":"core_ucum/#square-brackets","text":"At https://ucum.org/ucum.html#para-14 : \u00a714 square brackets. Square brackets enclose suffixes of unit symbols that change the meaning of a unit stem. For example: UCUM c/s presentation Meaning mm[Hg] millimeter Mercury column [ppm] Parts per million","title":"Square brackets"},{"location":"core_ucum/#curly-braces","text":"At https://ucum.org/ucum.html#para-12 : \u00a712 curly braces. Curly braces may be used to enclose annotations that are often written in place of units or behind units but that do not have a proper meaning of a unit and do not change the meaning of a unit. For example one can write \u201c%{vol}\u201d, \u201ckg{total}\u201d, or \u201c{RBC}\u201d (for \u201cred blood cells\u201d) as pseudo-units. However, these annotations do not have any effect on the semantics, which is why these example expressions are equivalent to \u201c%\u201d, \u201ckg\u201d, and \u201c1\u201d respectively.","title":"Curly braces"},{"location":"core_workflow-sim/","text":"Workflow of component in simulation This page explains the workflow a component is expected to follow during a simulation run, excluding the start and end of a simulation run. How to read this page Some sections in this page use pseudocode. For reference, see Pseudocode reference . Each pseudocode block is explained in text. The pseudocode is always the primary specification. That is, if the pseudocode conflicts with the text, the pseudocode has preference because the text is merely elaborative. The following apply in all pseudocode blocks of this page. Item in pseudocode Meaning publ error Publish a Status message that indicates an error to \"Status.Error\" publ ready Publish a Status message that indicates readiness to \"Status.Ready\" topic recv epoch From \"Epoch\" topic, receive an Epoch message recv input Receive input for calculation. This does not specify the topic the input comes from. recv running From \"SimState\" topic, receive a SimState message with state \"running\" recv stop From \"SimState\" topic, receive a SimState message with state \"stopped\" Handling simulation state and epochs recv running publ ready first_epoch = true loop wait for one of recv stop quit recv epoch // Include this if block only when implementing an initialization workflow if first_epoch first_epoch = false // Reach this block only once // Run initialization workflow run_initialization_workflow() // Run calculation workflow run_calculation_workflow() The workflow start with the reception of the state message \"running\". Then, the component announces it is ready to start by publishing \"ready\". Once all components have announced they are ready, the platform starts the actual epochs of simulation. In each epoch, the component first awaits an epoch message. However, if the platform instructs the component to stop during this wait, the component will quit. In epoch 1, the component MAY start with an initialization workflow. This means that the component communicates some parameters with other components. Regardless if an initialization workflow took place or not, the component continues to the calculation workflow. Next, the component awaits another epoch to begin. Initialization workflow Initialization workflow is an OPTIONAL step in epoch 1. In this workflow, the component communicates some information with other components before starting the calculation workflow. The component developer decides the following about the initialization workflow depending on the needs: What information is communicated How many components are involved Which messages are published Which components receive the published messages Whether each component should only receive, only publish or both receive and publish messages If the component implements an initialization workflow, this: MUST occur in epoch 1 MUST occur exactly once in each simulation run MUST occur as the first task the component accomplishes in the epoch Topic names Any topic name involved in the initialization workflow MUST start with \"Init.\". To prevent confusion in the processing of messages, a topic name involved in the calculation workflow of any component MUST NOT be involved in the initialization workflow of any component. Publish In this example, the component publishes a message in the initialization workflow. This is appropriate if the component has some information the other components need. function run_initialization_workflow() publish init_info to topic \"Init.Xyz\" Receive In this example, the component receives a message in the initialization workflow. This is appropriate if the component needs some information from another component. function run_initialization_workflow() recv init_info from topic \"Init.Xyz\" Calculation workflow This section describes the rules of interaction for components within one epoch. Although the word \"calculation\" appears in the title, the component does not necessarily calculate anything. If appropriate, the component may as well supply predefined values from a time series, for instance. The calculation workflow takes place after each reception of an epoch message. That is, this excludes the reception of the epoch message! REQUIRED items function run_calculation_workflow() // 1. Calculate whatever you want. Communicate with other components as needed. // ... // 2. Report readiness publ ready When a component has finished its operation in the epoch, it MUST send a ready message. This is the sole requirement set by the platform. A particular simulation scenario CAN set further requirements to enable the components to interact, but these are beyond the core functionality of the platform. Send in Every Epoch A component MAY publish results (i.e., output data) as the developers consider appropriate, but there is a rule called \"Send in Every Epoch\" (SIEE). This means that the component SHOULD be predictable in its publishing behaviour. For example, let component C have the capability to publish a result of type R. If C publishes an R in any epoch, it SHOULD publish an R in all epochs during the simulation run. The motivation is that the other components may not know when to expect R and when not. Therefore, it is most straightforward to always publish an R. Depending on the simulation scenario, the data enclosed in R can remain unchanged between certain epochs. For instance, if the resolution of a timeseries is 60 minutes and epoch length 15 minutes, a change will occur only in every fourth epoch. To follow the SIEE rule, C would re-send the same result data again when no changes have occurred. To help other components in saving resources and possibly avoid redundant calculation, C SHOULD assign the value of the field \"LastUpdatedInEpoch\" to indicate when the most recent change has occurred (see AbstractResult ). Still, C MUST update the other metadata as specified in page AbstractResult . Without input data This is an OPTIONAL workflow. It is applicable when no input data is needed for calculation. function run_calculation_workflow() calc result publ result publ ready The component calculates a result and publishes this. What is calculated and how and to which topic it is published depends on the component. Finally, the component reports readiness. With input data This is an OPTIONAL workflow. It is applicable when input data is necessary for calculation. function run_calculation_workflow() wait for one of recv stop quit recv input calc result publ result publ ready Before calculation, the component waits for input data. If it the platform instruct the component to stop while waiting, the execution will end. After receiving the data, to component calculates and publishes a result. What this result is and to which topic it is published depends on the component. Iterative calculation during epoch Basic rules When components run an iterative algorithm during an epoch, the related functionality must be designed carefully. Iteration MUST NOT be infinite, because this would cause the simulation to get stuck. Therefore, iteration MUST be designed in one of the following ways: (a) There is a guarantee that the algorithm always converges eventually (b) If convergence cannot be guaranteed, the component MUST use another mechanism to end iteration when convergence does not occur Alternative (b) MAY require that the iterating component still publishes a reasonable result. This result MAY be: (h) A default value (i) A value calculated with a simpler algorithm (j) Anything else considered appropriate The way to guarantee a reasonable result is case-specific and therefore out of scope of the core platform. This means that the component developers MUST recognize this need on their own and design an appropriate mechanism. Multi-component iteration Multi-component schemes Iteration MAY include multiple components. This means that one or more components form one or more groups where the components both produce input data to one another and consume the result data of one another. When multi-component iteration occurs, the component developers MUST take care that the iteration ends eventually. To ensure this, the component developers MUST assign each iterating component a role of either active or passive iterator: Active iterators . Each iteration group MUST include at least one active iterator component that has the ability to decide when to end iteration. Passive iterators . In a group of iterators, all components that are not active iterators are passive. These do not actively decide when to end iteration but know that they are involved in iteration. Passive iterators MUST understand the decision of an active iterator to end. The following figure illustrates a few of the potential iteration schemes. In the figure, each arrow represents how each component supplies results that are the input data of another component. The schemes include: (A) A cycle of two components, one active and one passive (B) A cycle of three components, one active and two passive (C) A cycle of three components, two active and one passive If any active iterator decides to end iteration, the result messages will deliver this information to all (D) Two iteration cycles both of which have X as the active iterator; these cycles may operate independently if wanted Still, the scheme MAY be even more complex, that is, contain more components and more cycles. Messaging in iteration In a multi-component iteration scheme, all iterating components MUST communicate the status of iteration in each result message. The component MUST indicate this in two ways: (1) Using the field \"IterationStatus\" (see AbstractMessage ) and (2) Using the suffix \".Iter\" in topic name when the result is intermediate and omitting this suffix when the result is final Please see the naming conventions in page Conventions of naming Together, conditions (1) and (2) ensure a uniform way to communicate which of the messages represent intermediate results and which are final. This has at least the following uses: During a simulation, enable a component to receive only final results when it does not participate in iteration After simulation, enable the separation of intermediate and final results in the retrieval of logged data The following tables tells how active and passive iterators decide whether to continue iteration. An active iterator continues iteration as long as it wants and no other iterator has declared its output as \"final\". In contrast, a passive iterator never decides when to end but instead re-uses the iteration status it has received in input. Active iterator: Does the iterator want to iterate still? IterationStatus received in input data IterationStatus to assign to result message Yes Intermediate Intermediate (iteration continues) Yes Final Final (iteration ends) No Intermediate Final (iteration ends) No Final Final (iteration ends) Passive iterator: IterationStatus received in input data IterationStatus to assign to result message Intermediate Intermediate (iteration continues) Final Final (iteration ends) Active iterator workflow The following code shows the basic workflow that an active iterator MAY implement for epochs. This assumes that the iterator receives exactly one result message as the input. topic = \"TopicX\" // Just an example loop // Loop to enable iteration wait for one of recv stop quit input = recv input iter_status = decide my iter status topic_temp = topic // Iter status is final if this iterator wants it or // if the input data is final if input.iter_status is final iter_status = final if iter_status is not final topic_temp = topic_temp + \".Iter\" result = calc result result.iter_status = iter_status publ result to topic_temp if iter_status is final publ ready break loop Passive iterator workflow The following code shows the basic workflow that a passive iterator MAY implement for epochs. This assumes that the iterator receives exactly one result message as the input. topic = \"TopicY\" // Just an example loop // Loop to enable iteration wait for one of recv stop quit input = recv input topic_temp = topic if input.iter_status is not final topic_temp = topic_temp + \".Iter\" calc result result.iter_status = input.iter_status publ result to topic_temp if input.iter_status is final publ ready break loop Error handling Error is a condition that the component cannot recover from. This happens when, e.g., the component receives a message it should use in calculation but the message is malformed or when there is a bug in the component that prevents further execution. Each component SHOULD be designed to detect errors. Fortunately, modern software languages have mechanisms, such as exceptions, that enable straightforward error handling. Regardless of the mechanism, the component SHOULD be ready to encounter an error anywhere in the code. Such error handling facilitates the tracking of bugs, which inevitably occur in software. Carefully implemented error handling reduces the time required for development. Not all errors can be communicated. For example, the network can be out of reach or the component can run out of memory. However, it is common that communication is still possible regardless of an error. In case an error occurs in a component, the platform has been designed to work as follows: The component reports the error The platform signals all components to stop and will publish no more epoch messages I.e., all components MUST quit If another component is busy on calculation when the stop message arrives, it MAY continue to produce a result and publish this before quitting The following explains how a component SHOULD behave when it has encountered an error. The component immediately publishes an error message (see section how to read). Now, the component waits for the platform to stop the simulation. However, if the component receives another message instead (likely the result of another component or an epoch message), it will re-publish the error message. loop publ error wait for one of recv stop quit recv epoch recv input // From here, the execution will jump to start of loop Warnings A warning means that something is wrong in the logic of a process, but this can still produce something meaningful as the result. Possible causes for warnings include, for instance: Invalid or unrealistic input data Failure to converge the calculation Warnings are informative but not fatal. Still, the presence of a warning in a message MAY cause a fatal condition in another process. When a warning occurs, the process MAY, depending on the situation: Supply default values as the result Execute a secondary calculation logic to have some result Execute its primary calculation logic, although the result can be unreliable How to indicate warning When a component thinks a warning has occurred, it SHOULD indicate this in the result message. Please see AbstractResult . Logging Each component SHOULD have an internal log to help in development and debugging. The reason is that it can be difficult to include all relevant information in the messages that indicate errors or warnings. The log SHOULD contain at least: Error information (such as stack trace if the platform generates exceptions) Warning information The log MAY contain: Entries about the execution of the component, such a steps of the internal workflow Any other information considered relevant","title":"Workflow of component in simulation"},{"location":"core_workflow-sim/#workflow-of-component-in-simulation","text":"This page explains the workflow a component is expected to follow during a simulation run, excluding the start and end of a simulation run.","title":"Workflow of component in simulation"},{"location":"core_workflow-sim/#how-to-read-this-page","text":"Some sections in this page use pseudocode. For reference, see Pseudocode reference . Each pseudocode block is explained in text. The pseudocode is always the primary specification. That is, if the pseudocode conflicts with the text, the pseudocode has preference because the text is merely elaborative. The following apply in all pseudocode blocks of this page. Item in pseudocode Meaning publ error Publish a Status message that indicates an error to \"Status.Error\" publ ready Publish a Status message that indicates readiness to \"Status.Ready\" topic recv epoch From \"Epoch\" topic, receive an Epoch message recv input Receive input for calculation. This does not specify the topic the input comes from. recv running From \"SimState\" topic, receive a SimState message with state \"running\" recv stop From \"SimState\" topic, receive a SimState message with state \"stopped\"","title":"How to read this page"},{"location":"core_workflow-sim/#handling-simulation-state-and-epochs","text":"recv running publ ready first_epoch = true loop wait for one of recv stop quit recv epoch // Include this if block only when implementing an initialization workflow if first_epoch first_epoch = false // Reach this block only once // Run initialization workflow run_initialization_workflow() // Run calculation workflow run_calculation_workflow() The workflow start with the reception of the state message \"running\". Then, the component announces it is ready to start by publishing \"ready\". Once all components have announced they are ready, the platform starts the actual epochs of simulation. In each epoch, the component first awaits an epoch message. However, if the platform instructs the component to stop during this wait, the component will quit. In epoch 1, the component MAY start with an initialization workflow. This means that the component communicates some parameters with other components. Regardless if an initialization workflow took place or not, the component continues to the calculation workflow. Next, the component awaits another epoch to begin.","title":"Handling simulation state and epochs"},{"location":"core_workflow-sim/#initialization-workflow","text":"Initialization workflow is an OPTIONAL step in epoch 1. In this workflow, the component communicates some information with other components before starting the calculation workflow. The component developer decides the following about the initialization workflow depending on the needs: What information is communicated How many components are involved Which messages are published Which components receive the published messages Whether each component should only receive, only publish or both receive and publish messages If the component implements an initialization workflow, this: MUST occur in epoch 1 MUST occur exactly once in each simulation run MUST occur as the first task the component accomplishes in the epoch","title":"Initialization workflow"},{"location":"core_workflow-sim/#topic-names","text":"Any topic name involved in the initialization workflow MUST start with \"Init.\". To prevent confusion in the processing of messages, a topic name involved in the calculation workflow of any component MUST NOT be involved in the initialization workflow of any component.","title":"Topic names"},{"location":"core_workflow-sim/#publish","text":"In this example, the component publishes a message in the initialization workflow. This is appropriate if the component has some information the other components need. function run_initialization_workflow() publish init_info to topic \"Init.Xyz\"","title":"Publish"},{"location":"core_workflow-sim/#receive","text":"In this example, the component receives a message in the initialization workflow. This is appropriate if the component needs some information from another component. function run_initialization_workflow() recv init_info from topic \"Init.Xyz\"","title":"Receive"},{"location":"core_workflow-sim/#calculation-workflow","text":"This section describes the rules of interaction for components within one epoch. Although the word \"calculation\" appears in the title, the component does not necessarily calculate anything. If appropriate, the component may as well supply predefined values from a time series, for instance. The calculation workflow takes place after each reception of an epoch message. That is, this excludes the reception of the epoch message!","title":"Calculation workflow"},{"location":"core_workflow-sim/#required-items","text":"function run_calculation_workflow() // 1. Calculate whatever you want. Communicate with other components as needed. // ... // 2. Report readiness publ ready When a component has finished its operation in the epoch, it MUST send a ready message. This is the sole requirement set by the platform. A particular simulation scenario CAN set further requirements to enable the components to interact, but these are beyond the core functionality of the platform.","title":"REQUIRED items"},{"location":"core_workflow-sim/#send-in-every-epoch","text":"A component MAY publish results (i.e., output data) as the developers consider appropriate, but there is a rule called \"Send in Every Epoch\" (SIEE). This means that the component SHOULD be predictable in its publishing behaviour. For example, let component C have the capability to publish a result of type R. If C publishes an R in any epoch, it SHOULD publish an R in all epochs during the simulation run. The motivation is that the other components may not know when to expect R and when not. Therefore, it is most straightforward to always publish an R. Depending on the simulation scenario, the data enclosed in R can remain unchanged between certain epochs. For instance, if the resolution of a timeseries is 60 minutes and epoch length 15 minutes, a change will occur only in every fourth epoch. To follow the SIEE rule, C would re-send the same result data again when no changes have occurred. To help other components in saving resources and possibly avoid redundant calculation, C SHOULD assign the value of the field \"LastUpdatedInEpoch\" to indicate when the most recent change has occurred (see AbstractResult ). Still, C MUST update the other metadata as specified in page AbstractResult .","title":"Send in Every Epoch"},{"location":"core_workflow-sim/#without-input-data","text":"This is an OPTIONAL workflow. It is applicable when no input data is needed for calculation. function run_calculation_workflow() calc result publ result publ ready The component calculates a result and publishes this. What is calculated and how and to which topic it is published depends on the component. Finally, the component reports readiness.","title":"Without input data"},{"location":"core_workflow-sim/#with-input-data","text":"This is an OPTIONAL workflow. It is applicable when input data is necessary for calculation. function run_calculation_workflow() wait for one of recv stop quit recv input calc result publ result publ ready Before calculation, the component waits for input data. If it the platform instruct the component to stop while waiting, the execution will end. After receiving the data, to component calculates and publishes a result. What this result is and to which topic it is published depends on the component.","title":"With input data"},{"location":"core_workflow-sim/#iterative-calculation-during-epoch","text":"","title":"Iterative calculation during epoch"},{"location":"core_workflow-sim/#basic-rules","text":"When components run an iterative algorithm during an epoch, the related functionality must be designed carefully. Iteration MUST NOT be infinite, because this would cause the simulation to get stuck. Therefore, iteration MUST be designed in one of the following ways: (a) There is a guarantee that the algorithm always converges eventually (b) If convergence cannot be guaranteed, the component MUST use another mechanism to end iteration when convergence does not occur Alternative (b) MAY require that the iterating component still publishes a reasonable result. This result MAY be: (h) A default value (i) A value calculated with a simpler algorithm (j) Anything else considered appropriate The way to guarantee a reasonable result is case-specific and therefore out of scope of the core platform. This means that the component developers MUST recognize this need on their own and design an appropriate mechanism.","title":"Basic rules"},{"location":"core_workflow-sim/#multi-component-iteration","text":"","title":"Multi-component iteration"},{"location":"core_workflow-sim/#multi-component-schemes","text":"Iteration MAY include multiple components. This means that one or more components form one or more groups where the components both produce input data to one another and consume the result data of one another. When multi-component iteration occurs, the component developers MUST take care that the iteration ends eventually. To ensure this, the component developers MUST assign each iterating component a role of either active or passive iterator: Active iterators . Each iteration group MUST include at least one active iterator component that has the ability to decide when to end iteration. Passive iterators . In a group of iterators, all components that are not active iterators are passive. These do not actively decide when to end iteration but know that they are involved in iteration. Passive iterators MUST understand the decision of an active iterator to end. The following figure illustrates a few of the potential iteration schemes. In the figure, each arrow represents how each component supplies results that are the input data of another component. The schemes include: (A) A cycle of two components, one active and one passive (B) A cycle of three components, one active and two passive (C) A cycle of three components, two active and one passive If any active iterator decides to end iteration, the result messages will deliver this information to all (D) Two iteration cycles both of which have X as the active iterator; these cycles may operate independently if wanted Still, the scheme MAY be even more complex, that is, contain more components and more cycles.","title":"Multi-component schemes"},{"location":"core_workflow-sim/#messaging-in-iteration","text":"In a multi-component iteration scheme, all iterating components MUST communicate the status of iteration in each result message. The component MUST indicate this in two ways: (1) Using the field \"IterationStatus\" (see AbstractMessage ) and (2) Using the suffix \".Iter\" in topic name when the result is intermediate and omitting this suffix when the result is final Please see the naming conventions in page Conventions of naming Together, conditions (1) and (2) ensure a uniform way to communicate which of the messages represent intermediate results and which are final. This has at least the following uses: During a simulation, enable a component to receive only final results when it does not participate in iteration After simulation, enable the separation of intermediate and final results in the retrieval of logged data The following tables tells how active and passive iterators decide whether to continue iteration. An active iterator continues iteration as long as it wants and no other iterator has declared its output as \"final\". In contrast, a passive iterator never decides when to end but instead re-uses the iteration status it has received in input. Active iterator: Does the iterator want to iterate still? IterationStatus received in input data IterationStatus to assign to result message Yes Intermediate Intermediate (iteration continues) Yes Final Final (iteration ends) No Intermediate Final (iteration ends) No Final Final (iteration ends) Passive iterator: IterationStatus received in input data IterationStatus to assign to result message Intermediate Intermediate (iteration continues) Final Final (iteration ends)","title":"Messaging in iteration"},{"location":"core_workflow-sim/#active-iterator-workflow","text":"The following code shows the basic workflow that an active iterator MAY implement for epochs. This assumes that the iterator receives exactly one result message as the input. topic = \"TopicX\" // Just an example loop // Loop to enable iteration wait for one of recv stop quit input = recv input iter_status = decide my iter status topic_temp = topic // Iter status is final if this iterator wants it or // if the input data is final if input.iter_status is final iter_status = final if iter_status is not final topic_temp = topic_temp + \".Iter\" result = calc result result.iter_status = iter_status publ result to topic_temp if iter_status is final publ ready break loop","title":"Active iterator workflow"},{"location":"core_workflow-sim/#passive-iterator-workflow","text":"The following code shows the basic workflow that a passive iterator MAY implement for epochs. This assumes that the iterator receives exactly one result message as the input. topic = \"TopicY\" // Just an example loop // Loop to enable iteration wait for one of recv stop quit input = recv input topic_temp = topic if input.iter_status is not final topic_temp = topic_temp + \".Iter\" calc result result.iter_status = input.iter_status publ result to topic_temp if input.iter_status is final publ ready break loop","title":"Passive iterator workflow"},{"location":"core_workflow-sim/#error-handling","text":"Error is a condition that the component cannot recover from. This happens when, e.g., the component receives a message it should use in calculation but the message is malformed or when there is a bug in the component that prevents further execution. Each component SHOULD be designed to detect errors. Fortunately, modern software languages have mechanisms, such as exceptions, that enable straightforward error handling. Regardless of the mechanism, the component SHOULD be ready to encounter an error anywhere in the code. Such error handling facilitates the tracking of bugs, which inevitably occur in software. Carefully implemented error handling reduces the time required for development. Not all errors can be communicated. For example, the network can be out of reach or the component can run out of memory. However, it is common that communication is still possible regardless of an error. In case an error occurs in a component, the platform has been designed to work as follows: The component reports the error The platform signals all components to stop and will publish no more epoch messages I.e., all components MUST quit If another component is busy on calculation when the stop message arrives, it MAY continue to produce a result and publish this before quitting The following explains how a component SHOULD behave when it has encountered an error. The component immediately publishes an error message (see section how to read). Now, the component waits for the platform to stop the simulation. However, if the component receives another message instead (likely the result of another component or an epoch message), it will re-publish the error message. loop publ error wait for one of recv stop quit recv epoch recv input // From here, the execution will jump to start of loop","title":"Error handling"},{"location":"core_workflow-sim/#warnings","text":"A warning means that something is wrong in the logic of a process, but this can still produce something meaningful as the result. Possible causes for warnings include, for instance: Invalid or unrealistic input data Failure to converge the calculation Warnings are informative but not fatal. Still, the presence of a warning in a message MAY cause a fatal condition in another process. When a warning occurs, the process MAY, depending on the situation: Supply default values as the result Execute a secondary calculation logic to have some result Execute its primary calculation logic, although the result can be unreliable","title":"Warnings"},{"location":"core_workflow-sim/#how-to-indicate-warning","text":"When a component thinks a warning has occurred, it SHOULD indicate this in the result message. Please see AbstractResult .","title":"How to indicate warning"},{"location":"core_workflow-sim/#logging","text":"Each component SHOULD have an internal log to help in development and debugging. The reason is that it can be difficult to include all relevant information in the messages that indicate errors or warnings. The log SHOULD contain at least: Error information (such as stack trace if the platform generates exceptions) Warning information The log MAY contain: Entries about the execution of the component, such a steps of the internal workflow Any other information considered relevant","title":"Logging"},{"location":"core_workflow-start-end/","text":"Workflow of start and end This page explains the workflow of starting and stopping a simulation run from the viewpoint of a simulation component. Overview A simulation component can be either platform managed or externally managed, which determines the workflow of starting and ending. In a simulation run, there are always at least platform managed components, because the platform core executes in Docker and is therefore platform managed. As new components are developed, the developers decide whether to manage in the platform or externally. Platform managed components The workflow of a platform managed component is as follows (see also the following figure): The user runs the command to start the simulation platform. The simulation platform starts. The simulation platform starts all platform managed components and ships any parameters to these. Each platform managed component starts as a Docker container. In each platform managed component: a. The component runs the simulation workflow (see Workflow of component in simulation ). b. Once the simulation workflow has finished, the component ends execution (i.e., the program exits). This will end the execution of the Docker container. Externally managed components The workflow of an externally managed component is as follows (see also the following figure): The user ensures all externally managed components are running. The user runs the command to start the simulation platform. The simulation platform starts and publishes a Start message. Exchange of publishing: management exchange Topic of publishing: \"Start\" In each externally managed component: a. The component receives the Start message b. The component runs the simulation workflow (see Workflow of component in simulation ). Once the simulation has ended, the user takes care that the externally managed components shut down if appropriate.","title":"Workflow of start and end"},{"location":"core_workflow-start-end/#workflow-of-start-and-end","text":"This page explains the workflow of starting and stopping a simulation run from the viewpoint of a simulation component.","title":"Workflow of start and end"},{"location":"core_workflow-start-end/#overview","text":"A simulation component can be either platform managed or externally managed, which determines the workflow of starting and ending. In a simulation run, there are always at least platform managed components, because the platform core executes in Docker and is therefore platform managed. As new components are developed, the developers decide whether to manage in the platform or externally.","title":"Overview"},{"location":"core_workflow-start-end/#platform-managed-components","text":"The workflow of a platform managed component is as follows (see also the following figure): The user runs the command to start the simulation platform. The simulation platform starts. The simulation platform starts all platform managed components and ships any parameters to these. Each platform managed component starts as a Docker container. In each platform managed component: a. The component runs the simulation workflow (see Workflow of component in simulation ). b. Once the simulation workflow has finished, the component ends execution (i.e., the program exits). This will end the execution of the Docker container.","title":"Platform managed components"},{"location":"core_workflow-start-end/#externally-managed-components","text":"The workflow of an externally managed component is as follows (see also the following figure): The user ensures all externally managed components are running. The user runs the command to start the simulation platform. The simulation platform starts and publishes a Start message. Exchange of publishing: management exchange Topic of publishing: \"Start\" In each externally managed component: a. The component receives the Start message b. The component runs the simulation workflow (see Workflow of component in simulation ). Once the simulation has ended, the user takes care that the externally managed components shut down if appropriate.","title":"Externally managed components"},{"location":"energy_controller/","text":"Controller Description This component is used to regulate the power setpoint of the resources based on information from economic dispatch. Subscribe Topic Payload of interest ResourceForecastState.Dispatch Real Power and Reactive Power Publish Topic Payload of interest ControlState.PowerSetpoint Real Power and Reactive Power Input Files This component does not have any input files. Workflow Simulation is started Controller t receives SimState \"running\" Controller responds by sending Status \"ready\" message. Controller receives Epoch message for the new epoch Controller receives ResourceForecastState.Dispatch message from Economic Dispatch Controller generates and publishes specific ControlState.PowerSetpoint message for the resources connected to it for the current epoch Controller sends Status \"ready\" message Repeat steps for 6-7 If the controller receives SimState \"stopped\" closes by itself","title":"Controller"},{"location":"energy_controller/#controller","text":"","title":"Controller"},{"location":"energy_controller/#description","text":"This component is used to regulate the power setpoint of the resources based on information from economic dispatch.","title":"Description"},{"location":"energy_controller/#subscribe","text":"Topic Payload of interest ResourceForecastState.Dispatch Real Power and Reactive Power","title":"Subscribe"},{"location":"energy_controller/#publish","text":"Topic Payload of interest ControlState.PowerSetpoint Real Power and Reactive Power","title":"Publish"},{"location":"energy_controller/#input-files","text":"This component does not have any input files.","title":"Input Files"},{"location":"energy_controller/#workflow","text":"Simulation is started Controller t receives SimState \"running\" Controller responds by sending Status \"ready\" message. Controller receives Epoch message for the new epoch Controller receives ResourceForecastState.Dispatch message from Economic Dispatch Controller generates and publishes specific ControlState.PowerSetpoint message for the resources connected to it for the current epoch Controller sends Status \"ready\" message Repeat steps for 6-7 If the controller receives SimState \"stopped\" closes by itself","title":"Workflow"},{"location":"energy_conventions/","text":"Energy-domain-specific conventions This page documents domain-specific conventions. Resource power direction convention As depicted in figure above the nominal power direction of a single resource is always \"Towards the grid\". I.e., if the power flows towards the grid, use a positive number. Otherwise, the number must be negative. This convention also applies to power derivative units, like energy. Branch current convention Network branch element (e.g. lines and transformers) current when considered from either end bus perspective is always \"Towards the element\".","title":"Energy-domain-specific conventions"},{"location":"energy_conventions/#energy-domain-specific-conventions","text":"This page documents domain-specific conventions.","title":"Energy-domain-specific conventions"},{"location":"energy_conventions/#resource-power-direction-convention","text":"As depicted in figure above the nominal power direction of a single resource is always \"Towards the grid\". I.e., if the power flows towards the grid, use a positive number. Otherwise, the number must be negative. This convention also applies to power derivative units, like energy.","title":"Resource power direction convention"},{"location":"energy_conventions/#branch-current-convention","text":"Network branch element (e.g. lines and transformers) current when considered from either end bus perspective is always \"Towards the element\".","title":"Branch current convention"},{"location":"energy_distribution-management-system-dms/","text":"Distribution management system (DMS) Distributed management system (DMS) embraces a collection of applications designed for distribution system monitoring and control. Since DMS performs many tasks, following a distributed approach, various application systems need to operate inside DMS to cover all the tasks as shown in the table below. Each application system is responsible for one main functionality containing many small functionalities inside. The service-oriented architecture (SOA) is the idea behind the intended DMS design. Thanks to SOA, application systems are loosely coupled that enable the distribution of building and developing of each application system to a group of developers. To achieve modularity and extendability, as mentioned, DMS functionalities are split into distinct application systems, and therefore communications between application systems should be as clear as it is between DMS and outside world. DMS application systems State monitoring (SM) Predictive grid optimization (PGO): Network forecast state monitoring and evaluation, utilizing market and non-market based solutions for congestion management, TSO-DSO coordination State estimation (SE) Real-time congestion management (RTCM) Operational grid optimization (OGO) Long-term operational planning Fault management: Fault location isolation supply restoration (FLISR), outage information to web and customers, reporting to regulator, ... Workforce management Maintenance management Asset management Simulation environment's architecture including DMS","title":"Distribution management system (DMS)"},{"location":"energy_distribution-management-system-dms/#distribution-management-system-dms","text":"Distributed management system (DMS) embraces a collection of applications designed for distribution system monitoring and control. Since DMS performs many tasks, following a distributed approach, various application systems need to operate inside DMS to cover all the tasks as shown in the table below. Each application system is responsible for one main functionality containing many small functionalities inside. The service-oriented architecture (SOA) is the idea behind the intended DMS design. Thanks to SOA, application systems are loosely coupled that enable the distribution of building and developing of each application system to a group of developers. To achieve modularity and extendability, as mentioned, DMS functionalities are split into distinct application systems, and therefore communications between application systems should be as clear as it is between DMS and outside world. DMS application systems State monitoring (SM) Predictive grid optimization (PGO): Network forecast state monitoring and evaluation, utilizing market and non-market based solutions for congestion management, TSO-DSO coordination State estimation (SE) Real-time congestion management (RTCM) Operational grid optimization (OGO) Long-term operational planning Fault management: Fault location isolation supply restoration (FLISR), outage information to web and customers, reporting to regulator, ... Workforce management Maintenance management Asset management","title":"Distribution management system (DMS)"},{"location":"energy_distribution-management-system-dms/#simulation-environments-architecture-including-dms","text":"","title":"Simulation environment's architecture including DMS"},{"location":"energy_economicdispatch/","text":"Economic Dispatch Description Optimises dispatch of energy purchase and energy storage units given predictions on consumption and production. Data Input for optimisation Subscription Topic Payload ResourceForecast.Load.# and ResourceForecast.Generator.# ResourceForecastState.(ResourceCategory).(ResourceId) Forecasts for (non-controllable) resource utilisation PriceForecastState.# PriceForecastState.(MarketId).(ResourceId) Electricity price forecasts for each hour ResourceState.Storage.# ResourceState.Storage.(ResourceId) Resource initial state (battery state of charge) Request.(MarketId) Flexibility needs from LFM LFMMarketResult.(MarketId) Flexibility results from LFM Scenario/configuration parameters: ED and resource parameters given at startup as declared in Start message blocks : ED component name from environment variable SIMULATION_COMPONENT_NAME At least the following in the environment variables: Forecast horizon and optimisation time step length (or defaults) List of resources to be included LFM market id (if applicable) Some resource parameter values are read from Start message blocks At least storage resource initial kwh, max capacity ( Defaults are implemented internally in the Economic Dispatch - note this if defaults change! ) Outside initialisation, the following is needed for flexibility implementation: CustomerId relation to resource names (for connection to PGO flexibility Request) is read from Init.CIS.CustomerInfo message Example configuration file: EconomicDispatch: EconomicDispatchA: Horizon: PT23H Timestep: PT1H Resources: - - StaticTimeSeriesResource - Load1 - - StaticTimeSeriesResource - Load2 - - StaticTimeSeriesResource - Load3 - - StaticTimeSeriesResource - Load4 - - PriceForecaster - MarketA - - StaticTimeSeriesResource - EV - - StaticTimeSeriesResource - PV_large - - StaticTimeSeriesResource - PV_small - - StorageResource - StorageA Publish Topic Payload ResourceForecastState.Dispatch The dispatch/schedule Offer.(MarketId) Flexibility bids to LFM (if applicable) Optimised Resources The following units are included: Static loads and generators Forecasts from Static time series resource, message ResourceForecastState.Power Includes predictions for consumption and production Electricity markets Forecasts from PriceForecaster, message PriceForecastState Includes predictions on the price of power to the ED units Storages Initial state from Storage resource, message ResourceState Max storage, charge/discharge efficiencies, etc read from start message Dispatch includes: Amount to charge/discharge storage per time interval Amount of energy bought from markets per time interval Workflow ED component functionality is message triggered. The optimisation relies on input data and therefore we have a barrier for execution; all input data needs to be received before executing/solving the ED problem: Simulation is started Initialisation as declared above in \"Scenario/configuration parameters\" Epoch message is received for a new epoch. ED resets barrier arrive counter. ED waits for input data. Arrive counter keeps track of what has arrived. When all input data that is needed has arrived ED solves its optimisation problem. (Input data: Power, Price (, etc) forecasts involved resources.) LFM: If accepted Offers from previous epochs, will receive LFMMarketResult for those ED sends its results in Dispatch message. ED receives state information (StorageResources, state for start of next epoch) LFM: Flexibility Request received \u2192 Publish Offer (multiple / if none \u2192 publish Offer with zero count) LFM: LFMMarketResult received Status: \"Ready\" (If LFM status = \"Ready\") Repeat steps 3-9. Resource receives a SimState message \"stopped\" from SimulationManager. Resource closes itself.","title":"Economic Dispatch"},{"location":"energy_economicdispatch/#economic-dispatch","text":"","title":"Economic Dispatch"},{"location":"energy_economicdispatch/#description","text":"Optimises dispatch of energy purchase and energy storage units given predictions on consumption and production.","title":"Description"},{"location":"energy_economicdispatch/#data","text":"Input for optimisation Subscription Topic Payload ResourceForecast.Load.# and ResourceForecast.Generator.# ResourceForecastState.(ResourceCategory).(ResourceId) Forecasts for (non-controllable) resource utilisation PriceForecastState.# PriceForecastState.(MarketId).(ResourceId) Electricity price forecasts for each hour ResourceState.Storage.# ResourceState.Storage.(ResourceId) Resource initial state (battery state of charge) Request.(MarketId) Flexibility needs from LFM LFMMarketResult.(MarketId) Flexibility results from LFM Scenario/configuration parameters: ED and resource parameters given at startup as declared in Start message blocks : ED component name from environment variable SIMULATION_COMPONENT_NAME At least the following in the environment variables: Forecast horizon and optimisation time step length (or defaults) List of resources to be included LFM market id (if applicable) Some resource parameter values are read from Start message blocks At least storage resource initial kwh, max capacity ( Defaults are implemented internally in the Economic Dispatch - note this if defaults change! ) Outside initialisation, the following is needed for flexibility implementation: CustomerId relation to resource names (for connection to PGO flexibility Request) is read from Init.CIS.CustomerInfo message Example configuration file: EconomicDispatch: EconomicDispatchA: Horizon: PT23H Timestep: PT1H Resources: - - StaticTimeSeriesResource - Load1 - - StaticTimeSeriesResource - Load2 - - StaticTimeSeriesResource - Load3 - - StaticTimeSeriesResource - Load4 - - PriceForecaster - MarketA - - StaticTimeSeriesResource - EV - - StaticTimeSeriesResource - PV_large - - StaticTimeSeriesResource - PV_small - - StorageResource - StorageA","title":"Data"},{"location":"energy_economicdispatch/#publish","text":"Topic Payload ResourceForecastState.Dispatch The dispatch/schedule Offer.(MarketId) Flexibility bids to LFM (if applicable)","title":"Publish"},{"location":"energy_economicdispatch/#optimised-resources","text":"The following units are included: Static loads and generators Forecasts from Static time series resource, message ResourceForecastState.Power Includes predictions for consumption and production Electricity markets Forecasts from PriceForecaster, message PriceForecastState Includes predictions on the price of power to the ED units Storages Initial state from Storage resource, message ResourceState Max storage, charge/discharge efficiencies, etc read from start message Dispatch includes: Amount to charge/discharge storage per time interval Amount of energy bought from markets per time interval","title":"Optimised Resources"},{"location":"energy_economicdispatch/#workflow","text":"ED component functionality is message triggered. The optimisation relies on input data and therefore we have a barrier for execution; all input data needs to be received before executing/solving the ED problem: Simulation is started Initialisation as declared above in \"Scenario/configuration parameters\" Epoch message is received for a new epoch. ED resets barrier arrive counter. ED waits for input data. Arrive counter keeps track of what has arrived. When all input data that is needed has arrived ED solves its optimisation problem. (Input data: Power, Price (, etc) forecasts involved resources.) LFM: If accepted Offers from previous epochs, will receive LFMMarketResult for those ED sends its results in Dispatch message. ED receives state information (StorageResources, state for start of next epoch) LFM: Flexibility Request received \u2192 Publish Offer (multiple / if none \u2192 publish Offer with zero count) LFM: LFMMarketResult received Status: \"Ready\" (If LFM status = \"Ready\") Repeat steps 3-9. Resource receives a SimState message \"stopped\" from SimulationManager. Resource closes itself.","title":"Workflow"},{"location":"energy_grid-dss/","text":"Grid (DSS) TODO","title":"Grid (DSS)"},{"location":"energy_grid-dss/#grid-dss","text":"TODO","title":"Grid (DSS)"},{"location":"energy_msg-controlstate-powersetpoint/","text":"ControlState.PowerSetpoint JSON structure { { (Fields of AbstractMessage and AbstractResult must appear too!) \"RealPower\" : { \"Value\": 100.0, \"UnitOfMeasure\": \"kW\" }, \"ReactivePower\" : { \"Value\": 0.0, \"UnitOfMeasure\": \"kV.A{r}\" } } Fields and multiplicity Field Type Multiplicity Explanation PowerSetpoint PowerSetpoint block (see below) 1 Power setpoint for next epoch PowerSetpoint block Field Type Multiplicity Explanation RealPower Quantity block 1 Real power setpoint for next epoch,Unit of measure: \"kW\" ReactivePower Quantity block 1 Reactive power setpoint for next epoch,Unit of measure: \"kV.A{r}\"","title":"ControlState.PowerSetpoint"},{"location":"energy_msg-controlstate-powersetpoint/#controlstatepowersetpoint","text":"","title":"ControlState.PowerSetpoint"},{"location":"energy_msg-controlstate-powersetpoint/#json-structure","text":"{ { (Fields of AbstractMessage and AbstractResult must appear too!) \"RealPower\" : { \"Value\": 100.0, \"UnitOfMeasure\": \"kW\" }, \"ReactivePower\" : { \"Value\": 0.0, \"UnitOfMeasure\": \"kV.A{r}\" } }","title":"JSON structure"},{"location":"energy_msg-controlstate-powersetpoint/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation PowerSetpoint PowerSetpoint block (see below) 1 Power setpoint for next epoch","title":"Fields and multiplicity"},{"location":"energy_msg-controlstate-powersetpoint/#powersetpoint-block","text":"Field Type Multiplicity Explanation RealPower Quantity block 1 Real power setpoint for next epoch,Unit of measure: \"kW\" ReactivePower Quantity block 1 Reactive power setpoint for next epoch,Unit of measure: \"kV.A{r}\"","title":"PowerSetpoint block"},{"location":"energy_msg-dmsnetworkstatus-current/","text":"DMSNetworkStatus.Current JSON structure { // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"CurrentStatus\":[ { \"DeviceId\":\"transformer\", \"Phase\":1, \"StatusSendingEnd\":\"acceptable\", \"StatusReceivingEnd\":\"acceptable\", \"ViolationSendingEnd\":0, \"ViolationReceivingEnd\":0 }, { \"DeviceId\":\"transformer\", \"Phase\":2, \"StatusSendingEnd\":\"unacceptable\", \"StatusReceivingEnd\":\"acceptable\", \"ViolationSendingEnd\":10, \"ViolationReceivingEnd\":0 } ] } Fields and multiplicity Field Type Multiplicity Notes All fields from AbstractResult Fields from \"abstract base class\" CurrentStatus Current table block 1 (REQUIRED) Current table block Field Type Multiplicity Notes DeviceId String 1 (REQUIRED) DeviceIds are the same as defined in Init.NIS.NetworkComponentInfo Phase Integer 1 (REQUIRED) Phase values can be: 1, 2, 3 StatusSendingEnd String 1 (REQUIRED) State values can be: acceptable, close-to-limits, unacceptable StatusReceivingEnd String 1 (REQUIRED) State values can be: acceptable, close-to-limits, unacceptable ViolationSendingEnd Float 1 (REQUIRED) The value can be : 0 for acceptable and close-to-limits states, positive for over-loading state ViolationReceivingEnd Float 1 (REQUIRED) The value can be : 0 for acceptable and close-to-limits states, positive for over-loading state","title":"DMSNetworkStatus.Current"},{"location":"energy_msg-dmsnetworkstatus-current/#dmsnetworkstatuscurrent","text":"","title":"DMSNetworkStatus.Current"},{"location":"energy_msg-dmsnetworkstatus-current/#json-structure","text":"{ // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"CurrentStatus\":[ { \"DeviceId\":\"transformer\", \"Phase\":1, \"StatusSendingEnd\":\"acceptable\", \"StatusReceivingEnd\":\"acceptable\", \"ViolationSendingEnd\":0, \"ViolationReceivingEnd\":0 }, { \"DeviceId\":\"transformer\", \"Phase\":2, \"StatusSendingEnd\":\"unacceptable\", \"StatusReceivingEnd\":\"acceptable\", \"ViolationSendingEnd\":10, \"ViolationReceivingEnd\":0 } ] }","title":"JSON structure"},{"location":"energy_msg-dmsnetworkstatus-current/#fields-and-multiplicity","text":"Field Type Multiplicity Notes All fields from AbstractResult Fields from \"abstract base class\" CurrentStatus Current table block 1 (REQUIRED)","title":"Fields and multiplicity"},{"location":"energy_msg-dmsnetworkstatus-current/#current-table-block","text":"Field Type Multiplicity Notes DeviceId String 1 (REQUIRED) DeviceIds are the same as defined in Init.NIS.NetworkComponentInfo Phase Integer 1 (REQUIRED) Phase values can be: 1, 2, 3 StatusSendingEnd String 1 (REQUIRED) State values can be: acceptable, close-to-limits, unacceptable StatusReceivingEnd String 1 (REQUIRED) State values can be: acceptable, close-to-limits, unacceptable ViolationSendingEnd Float 1 (REQUIRED) The value can be : 0 for acceptable and close-to-limits states, positive for over-loading state ViolationReceivingEnd Float 1 (REQUIRED) The value can be : 0 for acceptable and close-to-limits states, positive for over-loading state","title":"Current table block"},{"location":"energy_msg-dmsnetworkstatus-voltage/","text":"DMSNetworkStatus.Voltage JSON structure { // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"VoltageStatus\":[ { \"BusName\":\"sourcebus\", \"Node\":1, \"Status\":\"close-to-limits\" \"Violation\":0 }, { \"BusName\":\"sourcebus\", \"Node\":2, \"Status\":\"close-to-limits\" \"Violation\":0 } ] } Fields and multiplicity Field Type Multiplicity Notes All fields from AbstractResult Fields from \"abstract base class\" VoltageStatus Voltage table block 1 (REQUIRED) Voltage table block Field Type Multiplicity Notes BusName String 1 (REQUIRED) BusNames are the same as defined in Init.NIS.NetworkBusInfo Node Integer 1 (REQUIRED) Node values can be: 1, 2, 3 Status String 1 (REQUIRED) State values can be: acceptable, close-to-limits, unacceptable Violation Float 1 (REQUIRED) The value can be : 0 for acceptable and close-to-limits states, positive for over-voltage state, negative for under-voltage state","title":"DMSNetworkStatus.Voltage"},{"location":"energy_msg-dmsnetworkstatus-voltage/#dmsnetworkstatusvoltage","text":"","title":"DMSNetworkStatus.Voltage"},{"location":"energy_msg-dmsnetworkstatus-voltage/#json-structure","text":"{ // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"VoltageStatus\":[ { \"BusName\":\"sourcebus\", \"Node\":1, \"Status\":\"close-to-limits\" \"Violation\":0 }, { \"BusName\":\"sourcebus\", \"Node\":2, \"Status\":\"close-to-limits\" \"Violation\":0 } ] }","title":"JSON structure"},{"location":"energy_msg-dmsnetworkstatus-voltage/#fields-and-multiplicity","text":"Field Type Multiplicity Notes All fields from AbstractResult Fields from \"abstract base class\" VoltageStatus Voltage table block 1 (REQUIRED)","title":"Fields and multiplicity"},{"location":"energy_msg-dmsnetworkstatus-voltage/#voltage-table-block","text":"Field Type Multiplicity Notes BusName String 1 (REQUIRED) BusNames are the same as defined in Init.NIS.NetworkBusInfo Node Integer 1 (REQUIRED) Node values can be: 1, 2, 3 Status String 1 (REQUIRED) State values can be: acceptable, close-to-limits, unacceptable Violation Float 1 (REQUIRED) The value can be : 0 for acceptable and close-to-limits states, positive for over-voltage state, negative for under-voltage state","title":"Voltage table block"},{"location":"energy_msg-flexibilityneed/","text":"FlexibilityNeed JSON structure { // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"ActivationTime\" : \"2020-06-03T04:00:00.000Z\", \"Duration\" : { \"Value\": 30, \"UnitOfMeasure\": \"Minute\" }, \"Direction\" : \"upregulation\", \"RealPowerMin\" :{ \"Value\": 100.0, \"UnitOfMeasure\": \"kW\" }, \"RealPowerRequest\" :{ \"Value\": 700.0, \"UnitOfMeasure\": \"kW\" }, \"CustomerIds\" : [\"Ele10\",\"Ele170\"], \"CongestionId\" : \"XYZ\" \"BidResolution\" : { \"Value\": 10, \"UnitOfMeasure\": \"kW\" } } Fields and multiplicity Field Type Multiplicity Explanation All fields from AbstractResult Fields from \"abstract base class\" ActivationTime ISO 8601, Date and time included, Accuracy 1 ms, UTC zone 1 (REQUIRED), (OPTIONAL if OfferCount = 0) The time when the flexibility requires to be activated Duration Quantity block 1 (REQUIRED) The duration when the flexibility requires to keep activated. The value MUST equal to a positive-integer coefficient of 15 minutes (e.g., 15, 30, 45, 60, 75 etc) Direction String 1 (REQUIRED) Allowed values: \"upregulation\", \"downregulation\" RealPowerMin Time series block 1 (REQUIRED) The value (always in kW) MUST: equal to a positive-integer coefficient of BidResolution (i.e., simulation run parameter), equal or larger than min bid size (i.e., simulation run parameter) RealPowerRequest Time series block 1 (REQUIRED) The value (always in kW) MUST: equal to a positive-integer coefficient of BidResolution (i.e., simulation run parameter), equal or larger than min bid size (i.e., simulation run parameter) CustomerIds Array of strings 1 (REQUIRED) The value corresponds to all the CustomerIds within the congestion area. CongestionId String 1 (REQUIRED) The value corresponds to the unique identifier of the congestion problem determined by DSO (PGO) BidResolution Quantity block 1 (OPTIONAL) In kW, possible bid values between RealPowerMin and RealPowerRequest .e.g., if RealPowerMin = 1 kW and RealPowerRequest = 10 kW and BidResolution = 1 kW, allowable bids are 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 kW","title":"FlexibilityNeed"},{"location":"energy_msg-flexibilityneed/#flexibilityneed","text":"","title":"FlexibilityNeed"},{"location":"energy_msg-flexibilityneed/#json-structure","text":"{ // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"ActivationTime\" : \"2020-06-03T04:00:00.000Z\", \"Duration\" : { \"Value\": 30, \"UnitOfMeasure\": \"Minute\" }, \"Direction\" : \"upregulation\", \"RealPowerMin\" :{ \"Value\": 100.0, \"UnitOfMeasure\": \"kW\" }, \"RealPowerRequest\" :{ \"Value\": 700.0, \"UnitOfMeasure\": \"kW\" }, \"CustomerIds\" : [\"Ele10\",\"Ele170\"], \"CongestionId\" : \"XYZ\" \"BidResolution\" : { \"Value\": 10, \"UnitOfMeasure\": \"kW\" } }","title":"JSON structure"},{"location":"energy_msg-flexibilityneed/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation All fields from AbstractResult Fields from \"abstract base class\" ActivationTime ISO 8601, Date and time included, Accuracy 1 ms, UTC zone 1 (REQUIRED), (OPTIONAL if OfferCount = 0) The time when the flexibility requires to be activated Duration Quantity block 1 (REQUIRED) The duration when the flexibility requires to keep activated. The value MUST equal to a positive-integer coefficient of 15 minutes (e.g., 15, 30, 45, 60, 75 etc) Direction String 1 (REQUIRED) Allowed values: \"upregulation\", \"downregulation\" RealPowerMin Time series block 1 (REQUIRED) The value (always in kW) MUST: equal to a positive-integer coefficient of BidResolution (i.e., simulation run parameter), equal or larger than min bid size (i.e., simulation run parameter) RealPowerRequest Time series block 1 (REQUIRED) The value (always in kW) MUST: equal to a positive-integer coefficient of BidResolution (i.e., simulation run parameter), equal or larger than min bid size (i.e., simulation run parameter) CustomerIds Array of strings 1 (REQUIRED) The value corresponds to all the CustomerIds within the congestion area. CongestionId String 1 (REQUIRED) The value corresponds to the unique identifier of the congestion problem determined by DSO (PGO) BidResolution Quantity block 1 (OPTIONAL) In kW, possible bid values between RealPowerMin and RealPowerRequest .e.g., if RealPowerMin = 1 kW and RealPowerRequest = 10 kW and BidResolution = 1 kW, allowable bids are 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 kW","title":"Fields and multiplicity"},{"location":"energy_msg-init-cis-customerinfo/","text":"Init.CIS.CustomerInfo Description This message contains the list of electricity distribution components to be delivered in simulation initialization stage. JSON structure { // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"ResourceId\" : [ \"load1\", \"load2\", \"load3\" ], \"CustomerId\" : [ \"GridA-1\", \"GridA-1\", \"GridA-1\" ] \"BusName\":[ \"2\", \"1\", \"\" ] } Fields and multiplicity Field Type Multiplicity Notes All fields from AbstractResult Fields from \"abstract base class\" ResourceId Array of strings N by 1 (REQUIRED) Refers to ProcessId of Resources EXC processes CustomerId Array of strings N by 1 (REQUIRED) Grid allocated customer identifier BusName Array of strings N by 1 (REQUIRED) Connected system bus name, refers to bus name in Init.NIS.NetworkBusInfo NOTE : This can be an empty string. It means that Grid (DSS) has given a resource a customer id but it doesn't consider it in loadflow calculation. This is to facilitate resources that might be considered as a part of Economic Dispatch but that are not located in modelled grid","title":"Init.CIS.CustomerInfo"},{"location":"energy_msg-init-cis-customerinfo/#initciscustomerinfo","text":"","title":"Init.CIS.CustomerInfo"},{"location":"energy_msg-init-cis-customerinfo/#description","text":"This message contains the list of electricity distribution components to be delivered in simulation initialization stage.","title":"Description"},{"location":"energy_msg-init-cis-customerinfo/#json-structure","text":"{ // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"ResourceId\" : [ \"load1\", \"load2\", \"load3\" ], \"CustomerId\" : [ \"GridA-1\", \"GridA-1\", \"GridA-1\" ] \"BusName\":[ \"2\", \"1\", \"\" ] }","title":"JSON structure"},{"location":"energy_msg-init-cis-customerinfo/#fields-and-multiplicity","text":"Field Type Multiplicity Notes All fields from AbstractResult Fields from \"abstract base class\" ResourceId Array of strings N by 1 (REQUIRED) Refers to ProcessId of Resources EXC processes CustomerId Array of strings N by 1 (REQUIRED) Grid allocated customer identifier BusName Array of strings N by 1 (REQUIRED) Connected system bus name, refers to bus name in Init.NIS.NetworkBusInfo NOTE : This can be an empty string. It means that Grid (DSS) has given a resource a customer id but it doesn't consider it in loadflow calculation. This is to facilitate resources that might be considered as a part of Economic Dispatch but that are not located in modelled grid","title":"Fields and multiplicity"},{"location":"energy_msg-init-nis-networkbusinfo/","text":"Init.NIS.NetworkBusInfo Description This message contains the list of electricity distribution components to be delivered in simulation initialization stage. JSON structure { // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- \"BusName\" : [ \"sourcebus\", \"1\", \"2\", \"3\" ], \"BusType\" : [ \"root\", \"dummy\", \"dummy\", \"usage-point\" ], \"BusVoltageBase\" : { \"UnitOfMeasure\": \"kV\", \"Values\": [ 20, 0.4, 0.4, 0.4 ] } } Fields and multiplicity Field Type Multiplicity Notes All fields from AbstractResult Fields from \"abstract base class\" BusName Array of strings N by 1 (REQUIRED) System bus name, referenced by NetworkState.Voltage BusType Array of strings (enumerated) N by 1 (REQUIRED) Allowed values for elements: \"dummy\" : This bus has no resources connected to it, it only has a topology purpose, \"root\" : This is the feed-in bus of the network, it is assumed to be connected to a constant voltage source. \"usage-point\" : This bus has resource(s) connected to it, power will be injected to or draw fron grid at this bus BusVoltageBase Quantity array block N by 1 (REQUIRED) Unit of measure is always \"kV\"","title":"Init.NIS.NetworkBusInfo"},{"location":"energy_msg-init-nis-networkbusinfo/#initnisnetworkbusinfo","text":"","title":"Init.NIS.NetworkBusInfo"},{"location":"energy_msg-init-nis-networkbusinfo/#description","text":"This message contains the list of electricity distribution components to be delivered in simulation initialization stage.","title":"Description"},{"location":"energy_msg-init-nis-networkbusinfo/#json-structure","text":"{ // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- \"BusName\" : [ \"sourcebus\", \"1\", \"2\", \"3\" ], \"BusType\" : [ \"root\", \"dummy\", \"dummy\", \"usage-point\" ], \"BusVoltageBase\" : { \"UnitOfMeasure\": \"kV\", \"Values\": [ 20, 0.4, 0.4, 0.4 ] } }","title":"JSON structure"},{"location":"energy_msg-init-nis-networkbusinfo/#fields-and-multiplicity","text":"Field Type Multiplicity Notes All fields from AbstractResult Fields from \"abstract base class\" BusName Array of strings N by 1 (REQUIRED) System bus name, referenced by NetworkState.Voltage BusType Array of strings (enumerated) N by 1 (REQUIRED) Allowed values for elements: \"dummy\" : This bus has no resources connected to it, it only has a topology purpose, \"root\" : This is the feed-in bus of the network, it is assumed to be connected to a constant voltage source. \"usage-point\" : This bus has resource(s) connected to it, power will be injected to or draw fron grid at this bus BusVoltageBase Quantity array block N by 1 (REQUIRED) Unit of measure is always \"kV\"","title":"Fields and multiplicity"},{"location":"energy_msg-init-nis-networkcomponentinfo/","text":"Init.NIS.NetworkComponentInfo Description This message contains the list of electricity distribution components to be delivered in simulation initialization stage. JSON structure { // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- \"PowerBase\" : { \"Value\" : 10, \"UnitOfMeasure\" : \"kV.A\" }, \"DeviceId\" : [ \"t1\", \"l1\", \"l2\", \"l3\" ], \"SendingEndBus\" : [ \"sourcebus\", \"1\", \"2\", \"3\", \"4\" ], \"ReceivingEndBus\" : [ \"1\", \"2\", \"3\", \"4\" ], \"Resistance\" : { \"UnitOfMeasure\": \"{pu}\", \"Values\" : [ 0.172, 0.056, 0.284, 0.054 ] }, \"Reactance\" : { \"UnitOfMeasure\": \"{pu}\", \"Values\" : [ 0.134, 0.008, 0.027, 0.036 ] }, \"ShuntAdmittance\" : { \"UnitOfMeasure\": \"{pu}\", \"Values\" : [ 0, 0, 0, 0 ] }, \"ShuntConductance\" : { \"UnitOfMeasure\": \"{pu}\", \"Values\" : [ 0.00356, 0, 0, 0 ] }, \"RatedCurrent\" : { \"UnitOfMeasure\": \"{pu}\", \"Values\" : [ 1.739130435, 1.22, 0.42, 1 ] } } Fields and multiplicity Field Type Multiplicity Notes All fields from AbstractResult Fields from \"abstract base class\" PowerBase Quantity block 1 (REQUIRED) Power base value, always in \"kV.A\" DeviceId Array of strings N by 1 (REQUIRED) List of device identifiers. NetworkState.Current and NetworkState.Loss messages refer to these. SendingEndBus Array of strings N by 1 (REQUIRED) ReceivingEndBus Array of strings N by 1 (REQUIRED) Resistance Quantity array block N by 1 ((REQUIRED), single element can be NULL) Series resistance for the device, in per unit \"{pu}\" (sending end base) Reactance Quantity array block N by 1 ((REQUIRED), single element can be NULL) Series reactance for the device, in per unit \"{pu}\" (sending end base) ShuntAdmittance Quantity array block N by 1 ((REQUIRED), single element can be NULL) Shunt Admittance for the device, in per unit \"{pu}\" (sending end base) ShuntConductance Quantity array block N by 1 ((REQUIRED), single element can be NULL) Shunt Conductance for the device, in per unit \"{pu}\" (sending end base) RatedCurrent Quantity array block N by 1 ((REQUIRED), single element can be NULL) Rated current, in per unit \"{pu}\" (sending end base)","title":"Init.NIS.NetworkComponentInfo"},{"location":"energy_msg-init-nis-networkcomponentinfo/#initnisnetworkcomponentinfo","text":"","title":"Init.NIS.NetworkComponentInfo"},{"location":"energy_msg-init-nis-networkcomponentinfo/#description","text":"This message contains the list of electricity distribution components to be delivered in simulation initialization stage.","title":"Description"},{"location":"energy_msg-init-nis-networkcomponentinfo/#json-structure","text":"{ // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- \"PowerBase\" : { \"Value\" : 10, \"UnitOfMeasure\" : \"kV.A\" }, \"DeviceId\" : [ \"t1\", \"l1\", \"l2\", \"l3\" ], \"SendingEndBus\" : [ \"sourcebus\", \"1\", \"2\", \"3\", \"4\" ], \"ReceivingEndBus\" : [ \"1\", \"2\", \"3\", \"4\" ], \"Resistance\" : { \"UnitOfMeasure\": \"{pu}\", \"Values\" : [ 0.172, 0.056, 0.284, 0.054 ] }, \"Reactance\" : { \"UnitOfMeasure\": \"{pu}\", \"Values\" : [ 0.134, 0.008, 0.027, 0.036 ] }, \"ShuntAdmittance\" : { \"UnitOfMeasure\": \"{pu}\", \"Values\" : [ 0, 0, 0, 0 ] }, \"ShuntConductance\" : { \"UnitOfMeasure\": \"{pu}\", \"Values\" : [ 0.00356, 0, 0, 0 ] }, \"RatedCurrent\" : { \"UnitOfMeasure\": \"{pu}\", \"Values\" : [ 1.739130435, 1.22, 0.42, 1 ] } }","title":"JSON structure"},{"location":"energy_msg-init-nis-networkcomponentinfo/#fields-and-multiplicity","text":"Field Type Multiplicity Notes All fields from AbstractResult Fields from \"abstract base class\" PowerBase Quantity block 1 (REQUIRED) Power base value, always in \"kV.A\" DeviceId Array of strings N by 1 (REQUIRED) List of device identifiers. NetworkState.Current and NetworkState.Loss messages refer to these. SendingEndBus Array of strings N by 1 (REQUIRED) ReceivingEndBus Array of strings N by 1 (REQUIRED) Resistance Quantity array block N by 1 ((REQUIRED), single element can be NULL) Series resistance for the device, in per unit \"{pu}\" (sending end base) Reactance Quantity array block N by 1 ((REQUIRED), single element can be NULL) Series reactance for the device, in per unit \"{pu}\" (sending end base) ShuntAdmittance Quantity array block N by 1 ((REQUIRED), single element can be NULL) Shunt Admittance for the device, in per unit \"{pu}\" (sending end base) ShuntConductance Quantity array block N by 1 ((REQUIRED), single element can be NULL) Shunt Conductance for the device, in per unit \"{pu}\" (sending end base) RatedCurrent Quantity array block N by 1 ((REQUIRED), single element can be NULL) Rated current, in per unit \"{pu}\" (sending end base)","title":"Fields and multiplicity"},{"location":"energy_msg-lfmmarketresult/","text":"LFMMarketResult JSON structure { // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"ActivationTime\" : \"2020-06-03T04:00:00.000Z\", \"Duration\" : { \"Value\": 60, \"UnitOfMeasure\": \"Minute\" }, \"Direction\" : \"upregulation\", \"RealPower\" : { \"TimeIndex\" : [ \"2020-06-03T04:00:00.000Z\", \"2020-06-03T04:15:00.000Z\", \"2020-06-03T04:30:00.000Z\", \"2020-06-03T04:45:00.000Z\" ], \"Series\" : { \"Regulation\" : { \"UnitOfMeasure\" : \"kW\", \"Values\" : [ 200, 300, 150, 210 ] } } } \"Price\" :{ \"Value\": 50, \"UnitOfMeasure\": \"EUR\" }, \"CustomerIds\" : [ \"CustomerIdA\", \"CustomerIdB\" ], \"CongestionId\" : \"XYZ\", \"OfferId\" : \"Ele-2020-06-03T04:15:07.456Z\", \"ResultCount\" : 3 } Fields and multiplicity Field Type Multiplicity Explanation All fields from AbstractResult Fields from \"abstract base class\" ActivationTime ISO 8601, Date and time included, Accuracy 1 ms, UTC zone 1 (REQUIRED) The time when the flexibility requires to be activated Duration Quantity block 1 (REQUIRED) The duration when the flexibility requires to keep activated. The value MUST equal to a positive-integer coefficient of 15 minutes (e.g., 15, 30, 45, 60, 75 etc) Direction String 1 (REQUIRED) Allowed values: \"upregulation\", \"downregulation\" RealPower Time series block \"Quantity\" Quantity block (REQUIRED) always in \"kW\" The value (always in kW) MUST: equal to a positive-integer coefficient of BidResolution (i.e., simulation run parameter), equal or larger than min bid size (i.e., simulation run parameter) Price Quantity block 1 (REQUIRED) CongestionId String 1 (REQUIRED) The value corresponds to the unique identifier of the congestion problem determined by DSO (PGO) OfferId String 1 (REQUIRED) The unique Id specific for the offer ResultCount Integer 1 (REQUIRED) Number of currently in-effect MarketResults CongestionIds Array of string 1 (REQUIRED) Lists the CustomerIds participating in the offer.","title":"LFMMarketResult"},{"location":"energy_msg-lfmmarketresult/#lfmmarketresult","text":"","title":"LFMMarketResult"},{"location":"energy_msg-lfmmarketresult/#json-structure","text":"{ // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"ActivationTime\" : \"2020-06-03T04:00:00.000Z\", \"Duration\" : { \"Value\": 60, \"UnitOfMeasure\": \"Minute\" }, \"Direction\" : \"upregulation\", \"RealPower\" : { \"TimeIndex\" : [ \"2020-06-03T04:00:00.000Z\", \"2020-06-03T04:15:00.000Z\", \"2020-06-03T04:30:00.000Z\", \"2020-06-03T04:45:00.000Z\" ], \"Series\" : { \"Regulation\" : { \"UnitOfMeasure\" : \"kW\", \"Values\" : [ 200, 300, 150, 210 ] } } } \"Price\" :{ \"Value\": 50, \"UnitOfMeasure\": \"EUR\" }, \"CustomerIds\" : [ \"CustomerIdA\", \"CustomerIdB\" ], \"CongestionId\" : \"XYZ\", \"OfferId\" : \"Ele-2020-06-03T04:15:07.456Z\", \"ResultCount\" : 3 }","title":"JSON structure"},{"location":"energy_msg-lfmmarketresult/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation All fields from AbstractResult Fields from \"abstract base class\" ActivationTime ISO 8601, Date and time included, Accuracy 1 ms, UTC zone 1 (REQUIRED) The time when the flexibility requires to be activated Duration Quantity block 1 (REQUIRED) The duration when the flexibility requires to keep activated. The value MUST equal to a positive-integer coefficient of 15 minutes (e.g., 15, 30, 45, 60, 75 etc) Direction String 1 (REQUIRED) Allowed values: \"upregulation\", \"downregulation\" RealPower Time series block \"Quantity\" Quantity block (REQUIRED) always in \"kW\" The value (always in kW) MUST: equal to a positive-integer coefficient of BidResolution (i.e., simulation run parameter), equal or larger than min bid size (i.e., simulation run parameter) Price Quantity block 1 (REQUIRED) CongestionId String 1 (REQUIRED) The value corresponds to the unique identifier of the congestion problem determined by DSO (PGO) OfferId String 1 (REQUIRED) The unique Id specific for the offer ResultCount Integer 1 (REQUIRED) Number of currently in-effect MarketResults CongestionIds Array of string 1 (REQUIRED) Lists the CustomerIds participating in the offer.","title":"Fields and multiplicity"},{"location":"energy_msg-lfmoffering/","text":"LFMOffering JSON structure { // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"ActivationTime\" : \"2020-06-03T04:00:00.000Z\", \"Duration\" : { \"Value\": 60, \"UnitOfMeasure\": \"Minute\" }, \"Direction\" : \"upregulation\", \"RealPower\" : { \"TimeIndex\" : [ \"2020-06-03T04:00:00.000Z\", \"2020-06-03T04:15:00.000Z\", \"2020-06-03T04:30:00.000Z\", \"2020-06-03T04:45:00.000Z\" ], \"Series\" : { \"Regulation\" : { \"UnitOfMeasure\" : \"kW\", \"Values\" : [ 200, 300, 150, 210 ] } } } \"Price\" :{ \"Value\": 50, \"UnitOfMeasure\": \"EUR\" }, \"CustomerIds\" : [ \"CustomerIdA\", \"CustomerIdB\" ], \"OfferCount\" : 3, \"OfferId\" : \"Ele-2020-06-03T04:15:07.456Z\", \"CongestionId\" : \"XYZ\", } Fields and multiplicity Field Type Multiplicity Explanation All fields from AbstractResult Fields from \"abstract base class\" ActivationTime ISO 8601, Date and time included, Accuracy 1 ms, UTC zone 1 (REQUIRED) The time when the flexibility requires to be activated Duration Quantity block 1 (REQUIRED) The duration when the flexibility requires to keep activated. The value MUST equal to a positive-integer coefficient of 15 minutes (e.g., 15, 30, 45, 60, 75 etc) Direction String 1 (REQUIRED) Allowed values: \"upregulation\", \"downregulation\" RealPower Time series block 1 (REQUIRED) always in \"kW\" The value (always in kW) MUST: equal to a positive-integer coefficient of BidResolution (i.e., simulation run parameter), equal or larger than min bid size (i.e., simulation run parameter) Price Quantity block 1 (REQUIRED) CustomerIds Array of string 1 (REQUIRED) Lists the CustomerIds participating in the offer. OfferCount Integer 1 (REQUIRED) Total number of offers the provider is going to send in the running epoch related to this congestion area id OfferId String 1 (REQUIRED) The unique Id specific for the offer CongestionIds Array of string 1 (REQUIRED) The value corresponds to the unique identifier of congestion problem determined by DSO (PGO)","title":"LFMOffering"},{"location":"energy_msg-lfmoffering/#lfmoffering","text":"","title":"LFMOffering"},{"location":"energy_msg-lfmoffering/#json-structure","text":"{ // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"ActivationTime\" : \"2020-06-03T04:00:00.000Z\", \"Duration\" : { \"Value\": 60, \"UnitOfMeasure\": \"Minute\" }, \"Direction\" : \"upregulation\", \"RealPower\" : { \"TimeIndex\" : [ \"2020-06-03T04:00:00.000Z\", \"2020-06-03T04:15:00.000Z\", \"2020-06-03T04:30:00.000Z\", \"2020-06-03T04:45:00.000Z\" ], \"Series\" : { \"Regulation\" : { \"UnitOfMeasure\" : \"kW\", \"Values\" : [ 200, 300, 150, 210 ] } } } \"Price\" :{ \"Value\": 50, \"UnitOfMeasure\": \"EUR\" }, \"CustomerIds\" : [ \"CustomerIdA\", \"CustomerIdB\" ], \"OfferCount\" : 3, \"OfferId\" : \"Ele-2020-06-03T04:15:07.456Z\", \"CongestionId\" : \"XYZ\", }","title":"JSON structure"},{"location":"energy_msg-lfmoffering/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation All fields from AbstractResult Fields from \"abstract base class\" ActivationTime ISO 8601, Date and time included, Accuracy 1 ms, UTC zone 1 (REQUIRED) The time when the flexibility requires to be activated Duration Quantity block 1 (REQUIRED) The duration when the flexibility requires to keep activated. The value MUST equal to a positive-integer coefficient of 15 minutes (e.g., 15, 30, 45, 60, 75 etc) Direction String 1 (REQUIRED) Allowed values: \"upregulation\", \"downregulation\" RealPower Time series block 1 (REQUIRED) always in \"kW\" The value (always in kW) MUST: equal to a positive-integer coefficient of BidResolution (i.e., simulation run parameter), equal or larger than min bid size (i.e., simulation run parameter) Price Quantity block 1 (REQUIRED) CustomerIds Array of string 1 (REQUIRED) Lists the CustomerIds participating in the offer. OfferCount Integer 1 (REQUIRED) Total number of offers the provider is going to send in the running epoch related to this congestion area id OfferId String 1 (REQUIRED) The unique Id specific for the offer CongestionIds Array of string 1 (REQUIRED) The value corresponds to the unique identifier of congestion problem determined by DSO (PGO)","title":"Fields and multiplicity"},{"location":"energy_msg-networkforecaststate-current/","text":"NetworkForecastState.Current JSON structure { // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"Forecast\" : { \"TimeIndex\" : [ \"2020-06-25T00:00:00Z\", \"2020-06-25T01:00:00Z\", \"2020-06-25T02:00:00Z\", \"2020-06-25T03:00:00Z\" ], \"Series\" : { \"MagnitudeSendingEnd\" : { \"UnitOfMeasure\" : \"A\", \"Values\" : [ 0.2, 0.27, 0.15, 0.21 ] } \"MagnitudeReceivingEnd\" : { \"UnitOfMeasure\" : \"A\", \"Values\" : [ 2, 27, 15, 1 ] } \"AngleSendingEnd\" : { \"UnitOfMeasure\" : \"degree\", \"Values\" : [ 0.2, 0.27, 0.15, 0.21 ] } \"AngleReceivingEnd\" : { \"UnitOfMeasure\" : \"degree\", \"Values\" : [ 2, 27, 15, 1 ] } } } \"DeviceId\" : \"XYZ\", \"Phase\" : 1 } Fields and multiplicity Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" Forecast [Time series block] (core_block-time-series.md) \"MagnitudeSendingEnd\" (REQUIRED) always in \"A\". Sign is towards the branch. Sending End, \"MagnitudeReceivingEnd\" (REQUIRED) always in \"A\". Sign is towards the branch. Receiving End, \"AngleSendingEnd\" (REQUIRED) always in degree. (\"deg\" as specified in UCUM). Sending End, \"AngleReceivingEnd\" (REQUIRED) always in degree. (\"deg\" as specified in UCUM). Receiving End The time MUST be ordered from lowest to highest (i.e., ascending). DeviceId String 1 (REQUIRED) Must correspond to an entry in network model branches Phase Integer 1 (REQUIRED) Allowed values 1,2 and 3","title":"NetworkForecastState.Current"},{"location":"energy_msg-networkforecaststate-current/#networkforecaststatecurrent","text":"","title":"NetworkForecastState.Current"},{"location":"energy_msg-networkforecaststate-current/#json-structure","text":"{ // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"Forecast\" : { \"TimeIndex\" : [ \"2020-06-25T00:00:00Z\", \"2020-06-25T01:00:00Z\", \"2020-06-25T02:00:00Z\", \"2020-06-25T03:00:00Z\" ], \"Series\" : { \"MagnitudeSendingEnd\" : { \"UnitOfMeasure\" : \"A\", \"Values\" : [ 0.2, 0.27, 0.15, 0.21 ] } \"MagnitudeReceivingEnd\" : { \"UnitOfMeasure\" : \"A\", \"Values\" : [ 2, 27, 15, 1 ] } \"AngleSendingEnd\" : { \"UnitOfMeasure\" : \"degree\", \"Values\" : [ 0.2, 0.27, 0.15, 0.21 ] } \"AngleReceivingEnd\" : { \"UnitOfMeasure\" : \"degree\", \"Values\" : [ 2, 27, 15, 1 ] } } } \"DeviceId\" : \"XYZ\", \"Phase\" : 1 }","title":"JSON structure"},{"location":"energy_msg-networkforecaststate-current/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" Forecast [Time series block] (core_block-time-series.md) \"MagnitudeSendingEnd\" (REQUIRED) always in \"A\". Sign is towards the branch. Sending End, \"MagnitudeReceivingEnd\" (REQUIRED) always in \"A\". Sign is towards the branch. Receiving End, \"AngleSendingEnd\" (REQUIRED) always in degree. (\"deg\" as specified in UCUM). Sending End, \"AngleReceivingEnd\" (REQUIRED) always in degree. (\"deg\" as specified in UCUM). Receiving End The time MUST be ordered from lowest to highest (i.e., ascending). DeviceId String 1 (REQUIRED) Must correspond to an entry in network model branches Phase Integer 1 (REQUIRED) Allowed values 1,2 and 3","title":"Fields and multiplicity"},{"location":"energy_msg-networkforecaststate-voltage/","text":"NetworkForecastState.Voltage Description The message structure is used by Grid in the predictive mode to publish the forecasted voltage values of the distribution system. JSON structure { // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"Forecast\" : { \"TimeIndex\" : [ \"2020-06-25T00:00:00Z\", \"2020-06-25T01:00:00Z\", \"2020-06-25T02:00:00Z\", \"2020-06-25T03:00:00Z\" ], \"Series\" : { \"Magnitude\" : { \"UnitOfMeasure\" : \"kV\", \"Values\" : [ 0.2, 0.27, 0.15, 0.21 ] } \"Angle\" : { \"UnitOfMeasure\" : \"deg\", \"Values\" : [ 2, 27, 15, 1 ] } } } \"Bus\" : \"loadbus\", \"Node\" : 2 } Fields and multiplicity Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" Forecast [Time series block] (core_block-time-series.md) \"Magnitude\" (REQUIRED) always in \"kV\", \"Angle\" (REQUIRED) always in degrees (\"deg\") The time MUST be ordered from lowest to highest (i.e., ascending). Bus String 1 (REQUIRED) Node Integer 1 (REQUIRED) Allowed values 1, 2 and 3","title":"NetworkForecastState.Voltage"},{"location":"energy_msg-networkforecaststate-voltage/#networkforecaststatevoltage","text":"","title":"NetworkForecastState.Voltage"},{"location":"energy_msg-networkforecaststate-voltage/#description","text":"The message structure is used by Grid in the predictive mode to publish the forecasted voltage values of the distribution system.","title":"Description"},{"location":"energy_msg-networkforecaststate-voltage/#json-structure","text":"{ // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"Forecast\" : { \"TimeIndex\" : [ \"2020-06-25T00:00:00Z\", \"2020-06-25T01:00:00Z\", \"2020-06-25T02:00:00Z\", \"2020-06-25T03:00:00Z\" ], \"Series\" : { \"Magnitude\" : { \"UnitOfMeasure\" : \"kV\", \"Values\" : [ 0.2, 0.27, 0.15, 0.21 ] } \"Angle\" : { \"UnitOfMeasure\" : \"deg\", \"Values\" : [ 2, 27, 15, 1 ] } } } \"Bus\" : \"loadbus\", \"Node\" : 2 }","title":"JSON structure"},{"location":"energy_msg-networkforecaststate-voltage/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" Forecast [Time series block] (core_block-time-series.md) \"Magnitude\" (REQUIRED) always in \"kV\", \"Angle\" (REQUIRED) always in degrees (\"deg\") The time MUST be ordered from lowest to highest (i.e., ascending). Bus String 1 (REQUIRED) Node Integer 1 (REQUIRED) Allowed values 1, 2 and 3","title":"Fields and multiplicity"},{"location":"energy_msg-networkstate-current/","text":"NetworkState.Current JSON structure { (Fields of AbstractMessage and AbstractResult must appear too!) \"MagnitudeSendingEnd\" : { \"Value\": 0.1, \"UnitOfMeasure\": \"A\" }, \"MagnitudeReceivingEnd\" : { \"Value\": 0.2, \"UnitOfMeasure\": \"A\" }, \"AngleSendingEnd\" : { \"Value\": 10.0, \"UnitOfMeasure\": \"deg\" }, \"AngleReceivingEnd\" : { \"Value\": 20.0, \"UnitOfMeasure\": \"deg\" }, \"DeviceId\" : \"xyz-3\", \"Phase\" : 3 } Fields and multiplicity Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" MagnitudeSendingEnd Quantity block 1 (REQUIRED) Always in \"A\". Sign is towards the branch. Sending end. MagnitudeReceivingEnd Quantity block 1 (REQUIRED) Always in \"A\". Sign is towards the branch. Receiving end. AngleSendingEnd Quantity block 1 (REQUIRED) Always in degrees (\"deg\" as specified in UCUM); sending end AngleReceivingEnd Quantity block 1 (REQUIRED) Always in degrees (\"deg\" as specified in UCUM); receiving end DeviceId String 1 (REQUIRED) Must correspond to an entry in network model branches Phase Integer 1 (REQUIRED) Allowed values 1,2 and 3","title":"NetworkState.Current"},{"location":"energy_msg-networkstate-current/#networkstatecurrent","text":"","title":"NetworkState.Current"},{"location":"energy_msg-networkstate-current/#json-structure","text":"{ (Fields of AbstractMessage and AbstractResult must appear too!) \"MagnitudeSendingEnd\" : { \"Value\": 0.1, \"UnitOfMeasure\": \"A\" }, \"MagnitudeReceivingEnd\" : { \"Value\": 0.2, \"UnitOfMeasure\": \"A\" }, \"AngleSendingEnd\" : { \"Value\": 10.0, \"UnitOfMeasure\": \"deg\" }, \"AngleReceivingEnd\" : { \"Value\": 20.0, \"UnitOfMeasure\": \"deg\" }, \"DeviceId\" : \"xyz-3\", \"Phase\" : 3 }","title":"JSON structure"},{"location":"energy_msg-networkstate-current/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" MagnitudeSendingEnd Quantity block 1 (REQUIRED) Always in \"A\". Sign is towards the branch. Sending end. MagnitudeReceivingEnd Quantity block 1 (REQUIRED) Always in \"A\". Sign is towards the branch. Receiving end. AngleSendingEnd Quantity block 1 (REQUIRED) Always in degrees (\"deg\" as specified in UCUM); sending end AngleReceivingEnd Quantity block 1 (REQUIRED) Always in degrees (\"deg\" as specified in UCUM); receiving end DeviceId String 1 (REQUIRED) Must correspond to an entry in network model branches Phase Integer 1 (REQUIRED) Allowed values 1,2 and 3","title":"Fields and multiplicity"},{"location":"energy_msg-networkstate-loss/","text":"NetworkState.Loss JSON structure { (Fields of AbstractMessage and AbstractResult must appear too!) \"RealPowerShunt\" : { \"Value\": 1.0, \"UnitOfMeasure\": \"?\" }, \"RealPowerSeries\" : { \"Value\": 1.0, \"UnitOfMeasure\": \"?\" }, \"ReactivePowerShunt\" : { \"Value\": 1.0, \"UnitOfMeasure\": \"?\" }, \"ReactivePowerSeries\" : { \"Value\": 1.0, \"UnitOfMeasure\": \"?\" }, \"DeviceId\" : \"xyz\" } Fields and multiplicity Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" RealPowerShunt Quantity block 1 (REQUIRED) Voltage-dependent losses (e.g. transformer core effect losses) RealPowerSeries Quantity block 1 (REQUIRED) Current dependent losses (e.g. line losses) ReactivePowerShunt Quantity block 0..1 (OPTIONAL) Voltage-dependent losses (e.g. transformer magnetization current) ReactivePowerSeries Quantity block 0..1 (OPTIONAL) Current dependent losses (e.g. transformer stray inductance) DeviceId String 1 (REQUIRED) Must correspond to an entry in network model branches","title":"NetworkState.Loss"},{"location":"energy_msg-networkstate-loss/#networkstateloss","text":"","title":"NetworkState.Loss"},{"location":"energy_msg-networkstate-loss/#json-structure","text":"{ (Fields of AbstractMessage and AbstractResult must appear too!) \"RealPowerShunt\" : { \"Value\": 1.0, \"UnitOfMeasure\": \"?\" }, \"RealPowerSeries\" : { \"Value\": 1.0, \"UnitOfMeasure\": \"?\" }, \"ReactivePowerShunt\" : { \"Value\": 1.0, \"UnitOfMeasure\": \"?\" }, \"ReactivePowerSeries\" : { \"Value\": 1.0, \"UnitOfMeasure\": \"?\" }, \"DeviceId\" : \"xyz\" }","title":"JSON structure"},{"location":"energy_msg-networkstate-loss/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" RealPowerShunt Quantity block 1 (REQUIRED) Voltage-dependent losses (e.g. transformer core effect losses) RealPowerSeries Quantity block 1 (REQUIRED) Current dependent losses (e.g. line losses) ReactivePowerShunt Quantity block 0..1 (OPTIONAL) Voltage-dependent losses (e.g. transformer magnetization current) ReactivePowerSeries Quantity block 0..1 (OPTIONAL) Current dependent losses (e.g. transformer stray inductance) DeviceId String 1 (REQUIRED) Must correspond to an entry in network model branches","title":"Fields and multiplicity"},{"location":"energy_msg-networkstate-voltage/","text":"NetworkState.Voltage JSON structure { (Fields of AbstractMessage and AbstractResult must appear too!) ... \"Magnitude\" : { \"Value\" : 227.6, \"UnitOfMeasure\" : \"kV\" }, \"Angle\" : { \"Value\" : 119.5, \"UnitOfMeasure\" : \"deg\" }, \"Bus\" : \"loadbus\", \"Node\" : 2 } Fields and multiplicity Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" Magnitude Quantity block 1 (REQUIRED) Always in \"kV\" Angle Quantity block 1 (REQUIRED) Always in degrees (\"deg\") Bus String 1 (REQUIRED) Node Integer 1 (REQUIRED) Allowed values 1, 2 and 3","title":"NetworkState.Voltage"},{"location":"energy_msg-networkstate-voltage/#networkstatevoltage","text":"","title":"NetworkState.Voltage"},{"location":"energy_msg-networkstate-voltage/#json-structure","text":"{ (Fields of AbstractMessage and AbstractResult must appear too!) ... \"Magnitude\" : { \"Value\" : 227.6, \"UnitOfMeasure\" : \"kV\" }, \"Angle\" : { \"Value\" : 119.5, \"UnitOfMeasure\" : \"deg\" }, \"Bus\" : \"loadbus\", \"Node\" : 2 }","title":"JSON structure"},{"location":"energy_msg-networkstate-voltage/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" Magnitude Quantity block 1 (REQUIRED) Always in \"kV\" Angle Quantity block 1 (REQUIRED) Always in degrees (\"deg\") Bus String 1 (REQUIRED) Node Integer 1 (REQUIRED) Allowed values 1, 2 and 3","title":"Fields and multiplicity"},{"location":"energy_msg-offer/","text":"Offer JSON structure { // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"ActivationTime\" : \"2020-06-03T04:00:00.000Z\", \"Duration\" : { \"Value\": 60, \"UnitOfMeasure\": \"Minute\" }, \"Direction\" : \"upregulation\", \"RealPower\" : { \"TimeIndex\" : [ \"2020-06-03T04:00:00.000Z\", \"2020-06-03T04:15:00.000Z\", \"2020-06-03T04:30:00.000Z\", \"2020-06-03T04:45:00.000Z\" ], \"Series\" : { \"Regulation\" : { \"UnitOfMeasure\" : \"kW\", \"Values\" : [ 200, 300, 150, 210 ] } } } \"Price\" :{ \"Value\": 50, \"UnitOfMeasure\": \"EUR\" }, \"CongestionId\" : \"XYZ\", \"CustomerIds\" : [ \"CustomerIdA\", \"CustomerIdB\" ], \"OfferId\" : \"Elenia-2020-06-03T04:15:07.456Z\", \"OfferCount\" : 1 } Fields and multiplicity Field Type Multiplicity Explanation All fields from AbstractResult Fields from \"abstract base class\" ActivationTime ISO 8601, Date and time included, Accuracy 1 ms, UTC zone 1 (REQUIRED), (OPTIONAL if OfferCount = 0) The time when the flexibility requires to be activated Duration Quantity block 1 (REQUIRED), (OPTIONAL if OfferCount = 0) The duration when the flexibility requires to keep activated. The value MUST equal to a positive-integer coefficient of 15 minutes (e.g., 15, 30, 45, 60, 75 etc) Direction String 1 (REQUIRED), (OPTIONAL if OfferCount = 0) Allowed values: \"upregulation\", \"downregulation\" RealPower Time series block 1 (REQUIRED), (OPTIONAL if OfferCount = 0) Offered values of regulation always in \"kW\". Series \"Regulation\" Price Quantity block 1 (REQUIRED), (OPTIONAL if OfferCount = 0) CongestionId String 1 (REQUIRED) The value corresponds to the unique identifier of the congestion problem determined by DSO (PGO) CustomerIds Array of strings 1 (REQUIRED) Lists the CustomerIds participating in the offer. OfferId String 1 (REQUIRED), (OPTIONAL if OfferCount = 0) The unique Id specific for the offer OfferCount Integer 1 (REQUIRED) Total number of offers the provider is going to send in the running epoch related to this congestion area id","title":"Offer"},{"location":"energy_msg-offer/#offer","text":"","title":"Offer"},{"location":"energy_msg-offer/#json-structure","text":"{ // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"ActivationTime\" : \"2020-06-03T04:00:00.000Z\", \"Duration\" : { \"Value\": 60, \"UnitOfMeasure\": \"Minute\" }, \"Direction\" : \"upregulation\", \"RealPower\" : { \"TimeIndex\" : [ \"2020-06-03T04:00:00.000Z\", \"2020-06-03T04:15:00.000Z\", \"2020-06-03T04:30:00.000Z\", \"2020-06-03T04:45:00.000Z\" ], \"Series\" : { \"Regulation\" : { \"UnitOfMeasure\" : \"kW\", \"Values\" : [ 200, 300, 150, 210 ] } } } \"Price\" :{ \"Value\": 50, \"UnitOfMeasure\": \"EUR\" }, \"CongestionId\" : \"XYZ\", \"CustomerIds\" : [ \"CustomerIdA\", \"CustomerIdB\" ], \"OfferId\" : \"Elenia-2020-06-03T04:15:07.456Z\", \"OfferCount\" : 1 }","title":"JSON structure"},{"location":"energy_msg-offer/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation All fields from AbstractResult Fields from \"abstract base class\" ActivationTime ISO 8601, Date and time included, Accuracy 1 ms, UTC zone 1 (REQUIRED), (OPTIONAL if OfferCount = 0) The time when the flexibility requires to be activated Duration Quantity block 1 (REQUIRED), (OPTIONAL if OfferCount = 0) The duration when the flexibility requires to keep activated. The value MUST equal to a positive-integer coefficient of 15 minutes (e.g., 15, 30, 45, 60, 75 etc) Direction String 1 (REQUIRED), (OPTIONAL if OfferCount = 0) Allowed values: \"upregulation\", \"downregulation\" RealPower Time series block 1 (REQUIRED), (OPTIONAL if OfferCount = 0) Offered values of regulation always in \"kW\". Series \"Regulation\" Price Quantity block 1 (REQUIRED), (OPTIONAL if OfferCount = 0) CongestionId String 1 (REQUIRED) The value corresponds to the unique identifier of the congestion problem determined by DSO (PGO) CustomerIds Array of strings 1 (REQUIRED) Lists the CustomerIds participating in the offer. OfferId String 1 (REQUIRED), (OPTIONAL if OfferCount = 0) The unique Id specific for the offer OfferCount Integer 1 (REQUIRED) Total number of offers the provider is going to send in the running epoch related to this congestion area id","title":"Fields and multiplicity"},{"location":"energy_msg-priceforecaststate/","text":"PriceForecastState JSON structure { (Fields of AbstractMessage and AbstractResult must appear too!) \"MarketId\": \"assign-market-here\", \"ResourceId\": \"assign-resource-here\", \"Prices\": { \"TimeIndex\" : [ \"2020-02-17T10:00:00Z\", \"2020-02-17T11:00:00Z\", \"2020-02-17T12:00:00Z\" ], \"Series\" : { \"Price\" : { \"UnitOfMeasure\" : \"{EUR}/(kW.h)\", \"Values\" : [ 0.041, 0.042, 0.043 ] } } } } Fields and multiplicity Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" MarketId String 1 (REQUIRED) Market identifier ResourceId String 0..1 (OPTIONAL) The resource related to the price. If there is no resource specified, the message MUST contain market prices. PricingType ? 0..1 (OPTIONAL) ? Prices Time series block 1 (REQUIRED) See (1) below (1) Series included in the block: REQUIRED: \"Price\" Unit of measure: \"{EUR}/(kW.h)\" (or \"{EUR}/(MW.h)\"?) Currencies are not supported in UCUM, therefore \"EUR\" is an annotation in curly brackets OPTIONAL: variance or similar (TBD!)","title":"PriceForecastState"},{"location":"energy_msg-priceforecaststate/#priceforecaststate","text":"","title":"PriceForecastState"},{"location":"energy_msg-priceforecaststate/#json-structure","text":"{ (Fields of AbstractMessage and AbstractResult must appear too!) \"MarketId\": \"assign-market-here\", \"ResourceId\": \"assign-resource-here\", \"Prices\": { \"TimeIndex\" : [ \"2020-02-17T10:00:00Z\", \"2020-02-17T11:00:00Z\", \"2020-02-17T12:00:00Z\" ], \"Series\" : { \"Price\" : { \"UnitOfMeasure\" : \"{EUR}/(kW.h)\", \"Values\" : [ 0.041, 0.042, 0.043 ] } } } }","title":"JSON structure"},{"location":"energy_msg-priceforecaststate/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" MarketId String 1 (REQUIRED) Market identifier ResourceId String 0..1 (OPTIONAL) The resource related to the price. If there is no resource specified, the message MUST contain market prices. PricingType ? 0..1 (OPTIONAL) ? Prices Time series block 1 (REQUIRED) See (1) below (1) Series included in the block: REQUIRED: \"Price\" Unit of measure: \"{EUR}/(kW.h)\" (or \"{EUR}/(MW.h)\"?) Currencies are not supported in UCUM, therefore \"EUR\" is an annotation in curly brackets OPTIONAL: variance or similar (TBD!)","title":"Fields and multiplicity"},{"location":"energy_msg-request/","text":"Request JSON structure { // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"ActivationTime\" : \"2020-06-03T04:00:00.000Z\", \"Duration\" : { \"Value\": 30, \"UnitOfMeasure\": \"Minute\" }, \"Direction\" : \"upregulation\", \"RealPowerMin\" :{ \"Value\": 100.0, \"UnitOfMeasure\": \"kW\" }, \"RealPowerRequest\" :{ \"Value\": 700.0, \"UnitOfMeasure\": \"kW\" }, \"CustomerIds\" : [\"Ele10\",\"Ele170\"], \"CongestionId\" : \"XYZ\", \"BidResolution\":{ \"Value\": 10.0, \"UnitOfMeasure\": \"kW\" } } Fields and multiplicity Field Type Multiplicity Explanation All fields from AbstractResult Fields from \"abstract base class\" ActivationTime ISO 8601, Date and time included, Accuracy 1 ms, UTC zone 1 (REQUIRED), (OPTIONAL if OfferCount = 0) The time when the flexibility requires to be activated Duration Quantity block 1 (REQUIRED) The duration when the flexibility requires to keep activated. The value MUST equal to a positive-integer coefficient of 15 minutes (e.g., 15, 30, 45, 60, 75 etc) Direction String 1 (REQUIRED) Allowed values: \"upregulation\", \"downregulation\" RealPowerMin Time series block 1 (REQUIRED) The value (always in kW) MUST: equal to a positive-integer coefficient of BidResolution (i.e., simulation run parameter), equal or larger than min bid size (i.e., simulation run parameter) RealPowerRequest Time series block 1 (REQUIRED) The value (always in kW) MUST: equal to a positive-integer coefficient of BidResolution (i.e., simulation run parameter), equal or larger than min bid size (i.e., simulation run parameter) CustomerIds Array of strings 1 (REQUIRED) The value corresponds to all the CustomerIds within the congestion area. CongestionId String 1 (REQUIRED) The value corresponds to the unique identifier of the congestion problem determined by DSO (PGO) BidResolution Quantity block 1 (OPTIONAL) In kW, possible bid values between RealPowerMin and RealPowerRequest .e.g., if RealPowerMin = 1 kW and RealPowerRequest = 10 kW and BidResolution = 1 kW, allowable bids are 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 kW","title":"Request"},{"location":"energy_msg-request/#request","text":"","title":"Request"},{"location":"energy_msg-request/#json-structure","text":"{ // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"ActivationTime\" : \"2020-06-03T04:00:00.000Z\", \"Duration\" : { \"Value\": 30, \"UnitOfMeasure\": \"Minute\" }, \"Direction\" : \"upregulation\", \"RealPowerMin\" :{ \"Value\": 100.0, \"UnitOfMeasure\": \"kW\" }, \"RealPowerRequest\" :{ \"Value\": 700.0, \"UnitOfMeasure\": \"kW\" }, \"CustomerIds\" : [\"Ele10\",\"Ele170\"], \"CongestionId\" : \"XYZ\", \"BidResolution\":{ \"Value\": 10.0, \"UnitOfMeasure\": \"kW\" } }","title":"JSON structure"},{"location":"energy_msg-request/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation All fields from AbstractResult Fields from \"abstract base class\" ActivationTime ISO 8601, Date and time included, Accuracy 1 ms, UTC zone 1 (REQUIRED), (OPTIONAL if OfferCount = 0) The time when the flexibility requires to be activated Duration Quantity block 1 (REQUIRED) The duration when the flexibility requires to keep activated. The value MUST equal to a positive-integer coefficient of 15 minutes (e.g., 15, 30, 45, 60, 75 etc) Direction String 1 (REQUIRED) Allowed values: \"upregulation\", \"downregulation\" RealPowerMin Time series block 1 (REQUIRED) The value (always in kW) MUST: equal to a positive-integer coefficient of BidResolution (i.e., simulation run parameter), equal or larger than min bid size (i.e., simulation run parameter) RealPowerRequest Time series block 1 (REQUIRED) The value (always in kW) MUST: equal to a positive-integer coefficient of BidResolution (i.e., simulation run parameter), equal or larger than min bid size (i.e., simulation run parameter) CustomerIds Array of strings 1 (REQUIRED) The value corresponds to all the CustomerIds within the congestion area. CongestionId String 1 (REQUIRED) The value corresponds to the unique identifier of the congestion problem determined by DSO (PGO) BidResolution Quantity block 1 (OPTIONAL) In kW, possible bid values between RealPowerMin and RealPowerRequest .e.g., if RealPowerMin = 1 kW and RealPowerRequest = 10 kW and BidResolution = 1 kW, allowable bids are 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 kW","title":"Fields and multiplicity"},{"location":"energy_msg-resourceforecaststate-dispatch/","text":"ResourceForecastState.Dispatch JSON structure { // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"Dispatch\" : { \"ResourceA\" : { \"TimeIndex\" : [ \"2020-06-25T00:00:00Z\", \"2020-06-25T01:00:00Z\" ], \"Series\" : { \"RealPower\" : { \"UnitOfMeasure\" : \"kW\", \"Values\" : [ 0.2, 0.27 ] } } }, \"ResourceB\" : { \"TimeIndex\" : [ \"2020-06-25T00:00:00Z\", \"2020-06-25T01:00:00Z ], \"Series\" : { \"RealPower\" : { \"UnitOfMeasure\" : \"kW\", \"Values\" : [ 0.27, 0.2 ] } } } } } Fields and multiplicity Field Type Multiplicity Explanation All fields from AbstractResult Fields from \"abstract base class\" Dispatch Dictionary; key is string, value is Time series block 1 (REQUIRED) The key is the process identifier, value is a time series (power)","title":"ResourceForecastState.Dispatch"},{"location":"energy_msg-resourceforecaststate-dispatch/#resourceforecaststatedispatch","text":"","title":"ResourceForecastState.Dispatch"},{"location":"energy_msg-resourceforecaststate-dispatch/#json-structure","text":"{ // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"Dispatch\" : { \"ResourceA\" : { \"TimeIndex\" : [ \"2020-06-25T00:00:00Z\", \"2020-06-25T01:00:00Z\" ], \"Series\" : { \"RealPower\" : { \"UnitOfMeasure\" : \"kW\", \"Values\" : [ 0.2, 0.27 ] } } }, \"ResourceB\" : { \"TimeIndex\" : [ \"2020-06-25T00:00:00Z\", \"2020-06-25T01:00:00Z ], \"Series\" : { \"RealPower\" : { \"UnitOfMeasure\" : \"kW\", \"Values\" : [ 0.27, 0.2 ] } } } } }","title":"JSON structure"},{"location":"energy_msg-resourceforecaststate-dispatch/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation All fields from AbstractResult Fields from \"abstract base class\" Dispatch Dictionary; key is string, value is Time series block 1 (REQUIRED) The key is the process identifier, value is a time series (power)","title":"Fields and multiplicity"},{"location":"energy_msg-resourceforecaststate-power/","text":"ResourceForecastState.Power JSON structure { (Fields of AbstractMessage and AbstractResult must appear too!) \"ResourceId\" : \"load1\", \"Forecast\" : { \"TimeIndex\" : [ \"2020-06-25T00:00:00Z\", \"2020-06-25T01:00:00Z\", \"2020-06-25T02:00:00Z\", \"2020-06-25T03:00:00Z\" ], \"Series\" : { \"RealPower\" : { \"UnitOfMeasure\" : \"kW\", \"Values\" : [ -0.2, -0.27, -0.15, -0.21 ] } } } } Example file: ResourceStateForecast-example.json Fields and multiplicity Field Type Multiplicity Explanation All fields from AbstractResult Fields from \"abstract base class\" ResourceId String 1 (REQUIRED) Reference to resource \"name\" Forecast Time series block See (1) (1): \"RealPower\": 1 (REQUIRED); unit of measure \"kW\" \"RealPowerVariance\" OR \"RealPowerStandardDeviation\": 0..1 (OPTIONAL) \"ReactivePower\": 0..1 (OPTIONAL); unit of measure \"kV.A{r}\" \"ReactivePowerVariance\" OR \"ReactivePowerStandardDeviation\": 0..1 (OPTIONAL) if \"ReactivePower\" exists)","title":"ResourceForecastState.Power"},{"location":"energy_msg-resourceforecaststate-power/#resourceforecaststatepower","text":"","title":"ResourceForecastState.Power"},{"location":"energy_msg-resourceforecaststate-power/#json-structure","text":"{ (Fields of AbstractMessage and AbstractResult must appear too!) \"ResourceId\" : \"load1\", \"Forecast\" : { \"TimeIndex\" : [ \"2020-06-25T00:00:00Z\", \"2020-06-25T01:00:00Z\", \"2020-06-25T02:00:00Z\", \"2020-06-25T03:00:00Z\" ], \"Series\" : { \"RealPower\" : { \"UnitOfMeasure\" : \"kW\", \"Values\" : [ -0.2, -0.27, -0.15, -0.21 ] } } } } Example file: ResourceStateForecast-example.json","title":"JSON structure"},{"location":"energy_msg-resourceforecaststate-power/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation All fields from AbstractResult Fields from \"abstract base class\" ResourceId String 1 (REQUIRED) Reference to resource \"name\" Forecast Time series block See (1) (1): \"RealPower\": 1 (REQUIRED); unit of measure \"kW\" \"RealPowerVariance\" OR \"RealPowerStandardDeviation\": 0..1 (OPTIONAL) \"ReactivePower\": 0..1 (OPTIONAL); unit of measure \"kV.A{r}\" \"ReactivePowerVariance\" OR \"ReactivePowerStandardDeviation\": 0..1 (OPTIONAL) if \"ReactivePower\" exists)","title":"Fields and multiplicity"},{"location":"energy_msg-resourcestate/","text":"ResourceState JSON structure { (Fields of AbstractMessage and AbstractResult must appear too!) \"Bus\" : \"loadbus1\", \"RealPower\" : { \"Value\": 100.0, \"UnitOfMeasure\": \"kW\" }, \"ReactivePower\" : { \"Value\": 0.0, \"UnitOfMeasure\": \"kV.A{r}\" }, \"Node\" : 2, // Optional \"StateOfCharge\" : { \"Value\": 68.1, \"UnitOfMeasure\": \"%\" } // Optional } Fields and multiplicity Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" Bus String 1 (REQUIRED) Name of bus to which the resource is connected. RealPower Quantity block 1 (REQUIRED) 'Towards the grid' is positive. Always in \"kW\". ReactivePower Quantity block 1 (REQUIRED) Reactive power. Always in \"kV.A{r}\" Node Integer 0..1 (OPTIONAL) Node that 1-phase resource is connected to. Possible values 1, 2 and 3. If this is not specified then it is assumed that the resource is 3-phase resource. StateOfCharge Quantity block 0..1 (OPTIONAL) Present amount of energy stored, % of rated kWh. Unit of measure: \"%\".","title":"ResourceState"},{"location":"energy_msg-resourcestate/#resourcestate","text":"","title":"ResourceState"},{"location":"energy_msg-resourcestate/#json-structure","text":"{ (Fields of AbstractMessage and AbstractResult must appear too!) \"Bus\" : \"loadbus1\", \"RealPower\" : { \"Value\": 100.0, \"UnitOfMeasure\": \"kW\" }, \"ReactivePower\" : { \"Value\": 0.0, \"UnitOfMeasure\": \"kV.A{r}\" }, \"Node\" : 2, // Optional \"StateOfCharge\" : { \"Value\": 68.1, \"UnitOfMeasure\": \"%\" } // Optional }","title":"JSON structure"},{"location":"energy_msg-resourcestate/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" Bus String 1 (REQUIRED) Name of bus to which the resource is connected. RealPower Quantity block 1 (REQUIRED) 'Towards the grid' is positive. Always in \"kW\". ReactivePower Quantity block 1 (REQUIRED) Reactive power. Always in \"kV.A{r}\" Node Integer 0..1 (OPTIONAL) Node that 1-phase resource is connected to. Possible values 1, 2 and 3. If this is not specified then it is assumed that the resource is 3-phase resource. StateOfCharge Quantity block 0..1 (OPTIONAL) Present amount of energy stored, % of rated kWh. Unit of measure: \"%\".","title":"Fields and multiplicity"},{"location":"energy_msg-selectedoffer/","text":"SelectedOffer JSON structure { // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"OfferIds\" : [ \"Ele-2020-06-03T04:15:07.456Z\", \"Ele-2020-06-03T04:16:07.566Z\" ] } Fields and multiplicity Field Type Multiplicity Explanation All fields from AbstractResult Fields from \"abstract base class\" OfferIds Array of Ids 1 (REQUIRED) The values refer to specific offers","title":"SelectedOffer"},{"location":"energy_msg-selectedoffer/#selectedoffer","text":"","title":"SelectedOffer"},{"location":"energy_msg-selectedoffer/#json-structure","text":"{ // *** Messages MUST be encoded in UTF-8! *** // --- Fields of AbstractMessage begin --- \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", // --- Fields of AbstractMessage end --- // --- Fields of AbstractResult begin --- \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], // --- Fields of AbstractResult end --- \"OfferIds\" : [ \"Ele-2020-06-03T04:15:07.456Z\", \"Ele-2020-06-03T04:16:07.566Z\" ] }","title":"JSON structure"},{"location":"energy_msg-selectedoffer/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation All fields from AbstractResult Fields from \"abstract base class\" OfferIds Array of Ids 1 (REQUIRED) The values refer to specific offers","title":"Fields and multiplicity"},{"location":"energy_msg-startmessageblocks/","text":"Start message blocks This page contains the domain-specific parameter blocks included in the start message (see Start (message) ). JSON structure { \"ProcessParameters\" : { \"EconomicDispatch\": // Include this if relevant { \"EconomicDispatchA\": // Use a name because there can be multiple economic dispatches { \"Horizon\": \"PT36H\", // optional \"Timestep\": \"PT1H\", // optional \"Resources\": [ [\"StaticTimeSeriesResource\", \"LoadA\"], [\"StaticTimeSeriesResource\", \"GeneratorA\"], [\"StorageResource\", \"storageA\"] ], \"Weights\": { // optional -- See below for examples ... }, \"ParticipatingMarketId\": [ \"MarketA\" ], // LFM Market Id if applicable \"CommitmentTime\": \"12:00\", \"SkipOpenOffers\": \"True\" }, \"EconomicDispatchB\": { \"Horizon\": \"PT36H\", // optional \"Timestep\": \"PT1H\", // optional \"Resources\": [ [\"StaticTimeSeriesResource\", \"LoadB\"], [\"StaticTimeSeriesResource\", \"GeneratorB\"], [\"StorageResource\", \"storageB\"], [\"PriceForecaster\", \"marketB\"] ], \"ParticipatingMarketId\": [ \"MarketA\" ] // optional } }, \"Grid\": // Include this if relevant { \"GridA\": // Use a name because there can be multiple grids { \"ModelName\" : \"set_model_name_or_identifier_here\", \"Resources\": [ [\"LoadA\",\"bus3\"], [\"GeneratorA\",\"bus5\"] ], \"Symmetrical\" : false, //can be omitted, default is false \"MaxControlCount\" : 15 //can be omitted, default is 15 }, \"GridB\": { \"ModelName\" : \"set_model_name_or_identifier_here\", \"Resources\" : [], \"Symmetrical\" : false, //can be omitted, default is false \"MaxControlCount\" : 15 //can be omitted, default is 15 } }, \"PredictiveGridOptimization\": // Include this if relevant { \"PredictiveGridOptimizationA\": // Use a name because there can be multiple grids { \"MonitoredGridName\" : \"GridA\", \"FlexibilityNeedMargin\" : 0.2 , \"MaxVoltage\" : 1.05, \"MinVoltage\" : 0.95, \"UpperAmberBandVoltage\" : 0.01, \"LowerAmberBandVoltage\" : 0.01, \"OverloadingBaseline\" : 1, \"AmberLoadingBaseline\" : 0.9 }, \"PredictiveGridOptimizationB\": { \"MonitoredGridName\" : \"GridB\", \"RelativeSensitivity\" : 45 , \"FlexibilityNeedMargin\" : 0.2 , \"MaxVoltage\" : 1.05, \"MinVoltage\" : 0.95, \"UpperAmberBandVoltage\" : 0.01, \"LowerAmberBandVoltage\" : 0.01, \"OverloadingBaseline\" : 1, \"AmberLoadingBaseline\" : 0.9 } }, \"StateMonitoring\": // Include this if relevant { \"SM_A\": // Use a name because there can be multiple grids { \"MonitoredGridName\" : \"GridA\", \"MaxVoltage\" : 1.05, \"MinVoltage\" : 0.95, \"UpperAmberBandVoltage\" : 0.01, \"LowerAmberBandVoltage\" : 0.01, \"OverloadingBaseline\" : 1, \"AmberLoadingBaseline\" : 0.9 }, \"SM_B\": { \"MonitoredGridName\" : \"GridB\", \"MaxVoltage\" : 1.05, \"MinVoltage\" : 0.95, \"UpperAmberBandVoltage\" : 0.01, \"LowerAmberBandVoltage\" : 0.01, \"OverloadingBaseline\" : 1, \"AmberLoadingBaseline\" : 0.9 } }, \"StaticTimeSeriesResourceForecaster\": // Include this if it is relevant { \"ResourceForecaster\": // The identifier for the resource forecaster { \"ResourceForecastComponentIds\": \"load1, generator1\", \"ResourceTypes\": \"Load, Generator\", \"ResourceForecastStateCsvFolder\": \"/resources/forecasts/\" } }, \"StaticTimeSeriesResource\": // Include this if it is relevant { \"LoadA\": // The identifier for the resource { \"ResourceType\": \"Load\", \"ResourceStateFile\": \"load.csv\", \"ResourceFileDelimiter\": \",\" // optional, default value is \",\" }, \"GeneratorA\": { \"ResourceType\": \"Generator\", \"ResourceStateFile\": \"generator.csv\" } }, \"PriceForecaster\": // Include this if it is relevant { \"PriceForecasterA\": // Use a name because there can be multiple price forecasters { \"PriceForecasterStateCsvFile\": \"priceA.csv\", \"PriceForecasterStateCsvDelimiter\": \",\" // optional, default value is \",\" }, \"PriceForecasterB\": { \"PriceForecasterStateCsvFile\": \"priceB.csv\" } }, \"StorageResource\": // Include this if it is relevant { \"storageA\": // The identifier for the storage { \"ResourceStateCsvFile\": \"control.csv\", \"ResourceStateCsvDelimiter\": \",\", \"Bus\": \"bus1\", \"ChargeRate\": 100.0, \"DischargeRate\": 100.0, \"InitialStateOfCharge\": 50.0, \"KwhRated\": 100.0, \"DischargeEfficiency\": 90.0, \"ChargeEfficiency\": 90.0, \"KwRated\": 100.0, \"SelfDischarge\": 0.0 } } \"ProcemLFM\": { \"LFM1\": { \"MarketOpeningTime\": 14, \"MarketClosingTime\": 17, \"FlexibilityProviderList\": [\"economic-dispatch1\",\"economic-dispatch1\"], \"FlexibilityProcurerList\": [\"pgo1\"] } } } } Process parameter blocks Economic dispatch block Note: the Platform Manager passes these parameters directly to the Economic Dispatch instance through environmental variables. They are included as part of the Start message to make the used parameters visible to the other components as well as to the Logging System. Field Type Multiplicity Explanation Horizon ISO 8601 duration; e.g. 36 hours: \"PT36H\" 0..1 (OPTIONAL) Optimisation problem horizon (length of time range). If omitted, the default (36 h) is applied. NOTE: This must be compatible with the received forecasts, i.e. regarding forecast length Timestep ISO 8601 duration; e.g. 1 hour interval: \"PT1H\" (DEFAULT) or 15 min: \"PT15M\" 0..1 (OPTIONAL) The length of timestep. If omitted, the default (1 h) is applied. Note: This must be compatible with the received forecasts, i.e. regarding forecast resolution Resources N by 2 array of string 1 (REQUIRED) Array of component keys and resources in the economic dispatch scenario. Component key identifies component type. Allowed keys (currently): \"StaticTimeSeriesResource\", \"PriceForecaster\", \"StorageResource\" Weights Dictionary with identifier for (storage) resource (or \"default\" if to be applied to all). Fields (1) TerminalSOCBound: Percentage (0-100), Default: 40.0. (2) TerminalSOCTarget: Percentage (0-100), Default: None. (3) TerminalWeight: Unitless, in effect EUR/kwh, Default: None 0..1 (OPTIONAL) Optimisation weights, See (1) below table ParticipatingMarketId String 0..1 (OPTIONAL), REQUIRED if LFM is to be used MarketId for LFM. Required for participation in LFM. (Name is not checked - will operate if none is given. ED epoch \"Ready\" status is dependent on LFM \"Ready\" status, so will never be ready if wrong name is given.) CommitmentTime String 0..1 (OPTIONAL) Time at which day-ahead market closes (for next day). Given as a string with hours and minutes (must coincide with start time of epoch). For example \"12:00\". Commits to next day electricity market values at 12:00. Next day: midnight to midnight. SkipOpenOffers String 0..1 (OPTIONAL) Ignores open offers when calculating LFM offers. String valued. Accepted values: \"True\"/\"False\". (1) Optimisation weights: - Case 1: TerminalSOCBound given and TerminalSOCTarget + TerminalWeight not given. - Limits the storage state on the last time instant in optimisation horizon with the lower bound TerminalSOCBound For example: \"Weights\": { \"storageA\": // Identifier for resource component { \"TerminalSOCBound\": 50.0 } } Case 2: TerminalSOCBound, TerminalSOCTarget, TerminalWeight given Limits the storage state on the last time instant with the lower bound of TerminalSOCTarget - TerminalSOCBound Limits the storage state on the last time instant with the upper bound of TerminalSOCTarget + TerminalSOCBound (i.e. maximum deviation) Deviation from TerminalSOCTarget on last time instant minimized in either direction by linearly weighting with TerminalWeight For example: \"Weights\": { \"storageB\": // Identifier for resource component { \"TerminalSOCBound\": 10.0, \"TerminalSOCTarget\": 40.0, \"TerminalWeight\": 30.0 } } Grid block Field Type Multiplicity Explanation ModelName String 1 (REQUIRED) String referring to a network model in Grid model library. If erroneous or missing will cause an error in Grid process. Case-insensitive. Resources N by 2 array of string 0..1 (OPTIONALish) Array of resources and buses to which they are connected that the grid instance should consider. If omitted grid collects all resource names from any parameter block thats name ends in \"Resource\" and uses their default locations in the grid model. If no default location exists the resource is not considered. NOTE: It's very dangerous to omit this field!!! Symmetrical Boolean 0..1 (OPTIONAL) Indicator whether or not the grid should be considered symmetrical. If omitted assumed FALSE. MaxControlCount Integer ( > 0 ) 0..1 (OPTIONAL) Maximum number of control iteration allowed for Grid's internally modelled controllers per loadflow. Default if omitted is 15. Purpose of this variable is to interrupt set point hunting and ensure convergence. NOTE: This variable only impacts the Grid modelled controllers, external controllers have to keep their own iteration count. ModelVoltageBand Float ( < 1, > 0 ) 0..1 (OPTIONAL) The +/- band of voltages where nominal voltage dependency of resources is assumed to apply e.g. ModelVoltageBand=0.1 would assume that the dependency models apply between 0.9 to 1.1 pu. Beyond this band the model is assumed to revert to constant impedance to ensure convergence. If omitted 0.15 is used. ForecastFlows Boolean 0..1 (OPTIONAL) Indicator whether or not the Grid should also calculate forecasted load flows. Can be omitted, default is false. Set true if PGO is part of the simulation PredictiveGridOptimization block Field Type Multiplicity Explanation MonitoredGridName String 1 (REQUIRED) String referring to a Grid instance in the running simulation (e.g. \"GridA\") RelativeSensitivity Integer 1 (REQUIRED) RelativeRessitivity (RS) defines the size of a congestion area. 100 means the largest possible. 0 means the smallest possible. 0<=RS=<100 FlexibilityNeedMargin Float ( > -1, < 1 ) 1 (REQUIRED) FlexibilityNeedMargin (FNM) defines adjustment of the flexibility need's volume: if positive, over-purchase if negative, under-purchase if zero, neutral MaxVoltage Float ( > 0, > MinVoltage ) 1 (REQUIRED) Maximum allowable voltage for customer connected nodes (p.u.). Violation of this voltage causes RED condition. (identical for both MV and LV lines) MinVoltage Float ( > 0, < MaxVoltage) 1 (REQUIRED) Minimum allowable voltage for customer connected nodes (p.u.). Violation of this voltage causes RED condition. (identical for both MV and LV lines) UpperAmberBandVoltage Float (MaxVoltage - UpperAmberBand > MinVoltage + LowerAmberBand, >0) 1 (REQUIRED) Voltage margin for AMBER condition of overvoltage. (p.u.) LowerAmberBandVoltage Float (MaxVoltage - UpperAmberBand > MinVoltage + LowerAmberBand, >0) 1 (REQUIRED) Voltage margin for AMBER condition of undervoltage. (p.u.) OverloadingBaseline Float ( >0 ) 1 (REQUIRED) Component loading limit that is considered RED condition (typically 1, corresponding to 100% loading). AmberloadingBaseline Float ( >0, <= OverloadingBaseline) 1 (REQUIRED) Component loading limit that is considered AMBER condition (e.g., 0.9) StateMonitoring block Field Type Multiplicity Explanation MonitoredGridName String 1 (REQUIRED) String referring to a Grid instance in the running simulation (e.g. \"GridA\") MaxVoltage Float ( > 0, > MinVoltage ) 1 (REQUIRED) Maximum allowable voltage for customer connected nodes (p.u.). Violation of this voltage causes RED condition. (identical for both MV and LV lines) MinVoltage Float ( > 0, < MaxVoltage) 1 (REQUIRED) Minimum allowable voltage for customer connected nodes (p.u.). Violation of this voltage causes RED condition. (identical for both MV and LV lines) UpperAmberBandVoltage Float (MaxVoltage - UpperAmberBand > MinVoltage + LowerAmberBand, >0) 1 (REQUIRED) Voltage margin for AMBER condition of overvoltage. (p.u.) LowerAmberBandVoltage Float (MaxVoltage - UpperAmberBand > MinVoltage + LowerAmberBand, >0) 1 (REQUIRED) Voltage margin for AMBER condition of undervoltage. (p.u.) OverloadingBaseline Float ( >0 ) 1 (REQUIRED) Component loading limit that is considered RED condition (typically 1, corresponding to 100% loading) AmberloadingBaseline Float ( >0, <= OverloadingBaseline) 1 (REQUIRED) Component loading limit that is considered AMBER condition (e.g., 0.9) Static time series block Note: the Platform Manager passes these parameters directly to the Static Time Series Resource instance through environmental variables. They are included as part of the Start message to make the used parameters visible to the other components as well as to the Logging System. Field Type Multiplicity Explanation ResourceType String 1(REQUIRED) The type of the resource. MUST be either \"Load\" or \"Resource\". ResourceStateFile String 1 (REQUIRED) The name of the CSV file containing the static time series. ResourceFileDelimiter String 0..1 (OPTIONAL) The delimiter that is used in the CSV file. The default delimiter is comma, i.e. \",\". Storage resource block Note: the Platform Manager passes these parameters directly to the Storage Resource instance through environmental variables. They are included as part of the Start message to make the used parameters visible to the other components as well as to the Logging System. Field Type Multiplicity Explanation ResourceStateFile String 0..1 (OPTIONAL) The name of the CSV file containing control state information. ResourceStateDelimiter String 0..1 (OPTIONAL) The delimiter that is used in the CSV file. The default delimiter is comma, i.e. \",\". Bus String 0..1 (OPTIONAL) Name of bus to which the resource is connected. Required if ResourceStateCsvFile is not given. Node String 0..1 (OPTIONAL) Node that 1-phase resource is connected to. Possible values 1, 2 and 3. Used if file state source is not used and if then this is not specified then it is assumed that the resource is 3-phase resource. ChargeRate Float 0..1 (OPTIONAL) Charging rate (input power) in Percent of rated kW. Default value 100.0. DischargeRate Float 0..1 (OPTIONAL) Discharge rate (output power) in Percent of rated kW. Default value 100.0. InitialStateOfCharge Float 1 (REQUIRED) Initial amount of energy stored, %. KwhRated Float 1 (REQUIRED) Rated storage capacity in kWh. DischargeEfficiency Float 0..1 (OPTIONAL) Percent, efficiency for discharging the storage. Default value 90.0. ChargeEfficiency Float 0..1 (OPTIONAL) Percent, efficiency for charging the storage. Default value 90.0. KwRated Float 1 (REQUIRED) kW rating of power output. SelfDischarge Float 0..1 (OPTIONAL) Percent of rated kWh drained from storage while idling. Default value 0.0. Static Time Series Resource Forecaster block Note: the Platform Manager passes these parameters directly to the Static Time Series Resource Forecaster instance through environmental variables. They are included as part of the Start message to make the used parameters visible to the other components as well as to the Logging System. Field Type Multiplicity Explanation ResourceForecastComponentIds String 1 (REQUIRED) List names (strings) of forecasted resources. This information should match with csv file names that contain resource forecast state information. ResourceTypes String 1 (REQUIRED) List types (strings) of forecasted resources. Accepted values are Generator or Load. ResourceForecastStateCsvFolder String 1 (REQUIRED) Location of the folder that contains csv files. Csv files contain the resource forecast state information used in the simulation. Relative file paths are in relation to the current working directory. ResourceStateCsvDelimiter String 0..1 (OPTIONAL) The delimiter that is used in the CSV file. The default delimiter is comma, i.e. \",\". ResourceType String 0..1 (OPTIONAL) Type of this resource. Default is \"ResourceForecaster\". ResourceForecastTopic String 0..1 (OPTIONAL) The upper level topic under whose subtopics the resource states are published. If this environment variable is not present \"ResourceForecastState\" is used. ForecastHorizon String 0..1 (OPTIONAL) If this environment variable is not present then default \"PT36H\" is used. UnitOfMeasure String 0..1 (OPTIONAL) If this environment variable is not present then default \"kW\" is used. LFM block Field Type Multiplicity Explanation MarketOpeningTime Integer [0 ... 24] 1 (REQUIRED) Hour of day when market opens MarketClosingTime Integer [0 ... 24] 1 (REQUIRED) Hour of day when market closes FlexibilityProviderList Array of String 1 (REQUIRED) List of SourceProcessIds for processes that are expected to send FlexibilityNeed msgs FlexibilityProcurerList Array of String 1 (REQUIRED) List of SourceProcessIds for processes that are expected to send Offer msgs","title":"Start message blocks"},{"location":"energy_msg-startmessageblocks/#start-message-blocks","text":"This page contains the domain-specific parameter blocks included in the start message (see Start (message) ).","title":"Start message blocks"},{"location":"energy_msg-startmessageblocks/#json-structure","text":"{ \"ProcessParameters\" : { \"EconomicDispatch\": // Include this if relevant { \"EconomicDispatchA\": // Use a name because there can be multiple economic dispatches { \"Horizon\": \"PT36H\", // optional \"Timestep\": \"PT1H\", // optional \"Resources\": [ [\"StaticTimeSeriesResource\", \"LoadA\"], [\"StaticTimeSeriesResource\", \"GeneratorA\"], [\"StorageResource\", \"storageA\"] ], \"Weights\": { // optional -- See below for examples ... }, \"ParticipatingMarketId\": [ \"MarketA\" ], // LFM Market Id if applicable \"CommitmentTime\": \"12:00\", \"SkipOpenOffers\": \"True\" }, \"EconomicDispatchB\": { \"Horizon\": \"PT36H\", // optional \"Timestep\": \"PT1H\", // optional \"Resources\": [ [\"StaticTimeSeriesResource\", \"LoadB\"], [\"StaticTimeSeriesResource\", \"GeneratorB\"], [\"StorageResource\", \"storageB\"], [\"PriceForecaster\", \"marketB\"] ], \"ParticipatingMarketId\": [ \"MarketA\" ] // optional } }, \"Grid\": // Include this if relevant { \"GridA\": // Use a name because there can be multiple grids { \"ModelName\" : \"set_model_name_or_identifier_here\", \"Resources\": [ [\"LoadA\",\"bus3\"], [\"GeneratorA\",\"bus5\"] ], \"Symmetrical\" : false, //can be omitted, default is false \"MaxControlCount\" : 15 //can be omitted, default is 15 }, \"GridB\": { \"ModelName\" : \"set_model_name_or_identifier_here\", \"Resources\" : [], \"Symmetrical\" : false, //can be omitted, default is false \"MaxControlCount\" : 15 //can be omitted, default is 15 } }, \"PredictiveGridOptimization\": // Include this if relevant { \"PredictiveGridOptimizationA\": // Use a name because there can be multiple grids { \"MonitoredGridName\" : \"GridA\", \"FlexibilityNeedMargin\" : 0.2 , \"MaxVoltage\" : 1.05, \"MinVoltage\" : 0.95, \"UpperAmberBandVoltage\" : 0.01, \"LowerAmberBandVoltage\" : 0.01, \"OverloadingBaseline\" : 1, \"AmberLoadingBaseline\" : 0.9 }, \"PredictiveGridOptimizationB\": { \"MonitoredGridName\" : \"GridB\", \"RelativeSensitivity\" : 45 , \"FlexibilityNeedMargin\" : 0.2 , \"MaxVoltage\" : 1.05, \"MinVoltage\" : 0.95, \"UpperAmberBandVoltage\" : 0.01, \"LowerAmberBandVoltage\" : 0.01, \"OverloadingBaseline\" : 1, \"AmberLoadingBaseline\" : 0.9 } }, \"StateMonitoring\": // Include this if relevant { \"SM_A\": // Use a name because there can be multiple grids { \"MonitoredGridName\" : \"GridA\", \"MaxVoltage\" : 1.05, \"MinVoltage\" : 0.95, \"UpperAmberBandVoltage\" : 0.01, \"LowerAmberBandVoltage\" : 0.01, \"OverloadingBaseline\" : 1, \"AmberLoadingBaseline\" : 0.9 }, \"SM_B\": { \"MonitoredGridName\" : \"GridB\", \"MaxVoltage\" : 1.05, \"MinVoltage\" : 0.95, \"UpperAmberBandVoltage\" : 0.01, \"LowerAmberBandVoltage\" : 0.01, \"OverloadingBaseline\" : 1, \"AmberLoadingBaseline\" : 0.9 } }, \"StaticTimeSeriesResourceForecaster\": // Include this if it is relevant { \"ResourceForecaster\": // The identifier for the resource forecaster { \"ResourceForecastComponentIds\": \"load1, generator1\", \"ResourceTypes\": \"Load, Generator\", \"ResourceForecastStateCsvFolder\": \"/resources/forecasts/\" } }, \"StaticTimeSeriesResource\": // Include this if it is relevant { \"LoadA\": // The identifier for the resource { \"ResourceType\": \"Load\", \"ResourceStateFile\": \"load.csv\", \"ResourceFileDelimiter\": \",\" // optional, default value is \",\" }, \"GeneratorA\": { \"ResourceType\": \"Generator\", \"ResourceStateFile\": \"generator.csv\" } }, \"PriceForecaster\": // Include this if it is relevant { \"PriceForecasterA\": // Use a name because there can be multiple price forecasters { \"PriceForecasterStateCsvFile\": \"priceA.csv\", \"PriceForecasterStateCsvDelimiter\": \",\" // optional, default value is \",\" }, \"PriceForecasterB\": { \"PriceForecasterStateCsvFile\": \"priceB.csv\" } }, \"StorageResource\": // Include this if it is relevant { \"storageA\": // The identifier for the storage { \"ResourceStateCsvFile\": \"control.csv\", \"ResourceStateCsvDelimiter\": \",\", \"Bus\": \"bus1\", \"ChargeRate\": 100.0, \"DischargeRate\": 100.0, \"InitialStateOfCharge\": 50.0, \"KwhRated\": 100.0, \"DischargeEfficiency\": 90.0, \"ChargeEfficiency\": 90.0, \"KwRated\": 100.0, \"SelfDischarge\": 0.0 } } \"ProcemLFM\": { \"LFM1\": { \"MarketOpeningTime\": 14, \"MarketClosingTime\": 17, \"FlexibilityProviderList\": [\"economic-dispatch1\",\"economic-dispatch1\"], \"FlexibilityProcurerList\": [\"pgo1\"] } } } }","title":"JSON structure"},{"location":"energy_msg-startmessageblocks/#process-parameter-blocks","text":"","title":"Process parameter blocks"},{"location":"energy_msg-startmessageblocks/#economic-dispatch-block","text":"Note: the Platform Manager passes these parameters directly to the Economic Dispatch instance through environmental variables. They are included as part of the Start message to make the used parameters visible to the other components as well as to the Logging System. Field Type Multiplicity Explanation Horizon ISO 8601 duration; e.g. 36 hours: \"PT36H\" 0..1 (OPTIONAL) Optimisation problem horizon (length of time range). If omitted, the default (36 h) is applied. NOTE: This must be compatible with the received forecasts, i.e. regarding forecast length Timestep ISO 8601 duration; e.g. 1 hour interval: \"PT1H\" (DEFAULT) or 15 min: \"PT15M\" 0..1 (OPTIONAL) The length of timestep. If omitted, the default (1 h) is applied. Note: This must be compatible with the received forecasts, i.e. regarding forecast resolution Resources N by 2 array of string 1 (REQUIRED) Array of component keys and resources in the economic dispatch scenario. Component key identifies component type. Allowed keys (currently): \"StaticTimeSeriesResource\", \"PriceForecaster\", \"StorageResource\" Weights Dictionary with identifier for (storage) resource (or \"default\" if to be applied to all). Fields (1) TerminalSOCBound: Percentage (0-100), Default: 40.0. (2) TerminalSOCTarget: Percentage (0-100), Default: None. (3) TerminalWeight: Unitless, in effect EUR/kwh, Default: None 0..1 (OPTIONAL) Optimisation weights, See (1) below table ParticipatingMarketId String 0..1 (OPTIONAL), REQUIRED if LFM is to be used MarketId for LFM. Required for participation in LFM. (Name is not checked - will operate if none is given. ED epoch \"Ready\" status is dependent on LFM \"Ready\" status, so will never be ready if wrong name is given.) CommitmentTime String 0..1 (OPTIONAL) Time at which day-ahead market closes (for next day). Given as a string with hours and minutes (must coincide with start time of epoch). For example \"12:00\". Commits to next day electricity market values at 12:00. Next day: midnight to midnight. SkipOpenOffers String 0..1 (OPTIONAL) Ignores open offers when calculating LFM offers. String valued. Accepted values: \"True\"/\"False\". (1) Optimisation weights: - Case 1: TerminalSOCBound given and TerminalSOCTarget + TerminalWeight not given. - Limits the storage state on the last time instant in optimisation horizon with the lower bound TerminalSOCBound For example: \"Weights\": { \"storageA\": // Identifier for resource component { \"TerminalSOCBound\": 50.0 } } Case 2: TerminalSOCBound, TerminalSOCTarget, TerminalWeight given Limits the storage state on the last time instant with the lower bound of TerminalSOCTarget - TerminalSOCBound Limits the storage state on the last time instant with the upper bound of TerminalSOCTarget + TerminalSOCBound (i.e. maximum deviation) Deviation from TerminalSOCTarget on last time instant minimized in either direction by linearly weighting with TerminalWeight For example: \"Weights\": { \"storageB\": // Identifier for resource component { \"TerminalSOCBound\": 10.0, \"TerminalSOCTarget\": 40.0, \"TerminalWeight\": 30.0 } }","title":"Economic dispatch block"},{"location":"energy_msg-startmessageblocks/#grid-block","text":"Field Type Multiplicity Explanation ModelName String 1 (REQUIRED) String referring to a network model in Grid model library. If erroneous or missing will cause an error in Grid process. Case-insensitive. Resources N by 2 array of string 0..1 (OPTIONALish) Array of resources and buses to which they are connected that the grid instance should consider. If omitted grid collects all resource names from any parameter block thats name ends in \"Resource\" and uses their default locations in the grid model. If no default location exists the resource is not considered. NOTE: It's very dangerous to omit this field!!! Symmetrical Boolean 0..1 (OPTIONAL) Indicator whether or not the grid should be considered symmetrical. If omitted assumed FALSE. MaxControlCount Integer ( > 0 ) 0..1 (OPTIONAL) Maximum number of control iteration allowed for Grid's internally modelled controllers per loadflow. Default if omitted is 15. Purpose of this variable is to interrupt set point hunting and ensure convergence. NOTE: This variable only impacts the Grid modelled controllers, external controllers have to keep their own iteration count. ModelVoltageBand Float ( < 1, > 0 ) 0..1 (OPTIONAL) The +/- band of voltages where nominal voltage dependency of resources is assumed to apply e.g. ModelVoltageBand=0.1 would assume that the dependency models apply between 0.9 to 1.1 pu. Beyond this band the model is assumed to revert to constant impedance to ensure convergence. If omitted 0.15 is used. ForecastFlows Boolean 0..1 (OPTIONAL) Indicator whether or not the Grid should also calculate forecasted load flows. Can be omitted, default is false. Set true if PGO is part of the simulation","title":"Grid block"},{"location":"energy_msg-startmessageblocks/#predictivegridoptimization-block","text":"Field Type Multiplicity Explanation MonitoredGridName String 1 (REQUIRED) String referring to a Grid instance in the running simulation (e.g. \"GridA\") RelativeSensitivity Integer 1 (REQUIRED) RelativeRessitivity (RS) defines the size of a congestion area. 100 means the largest possible. 0 means the smallest possible. 0<=RS=<100 FlexibilityNeedMargin Float ( > -1, < 1 ) 1 (REQUIRED) FlexibilityNeedMargin (FNM) defines adjustment of the flexibility need's volume: if positive, over-purchase if negative, under-purchase if zero, neutral MaxVoltage Float ( > 0, > MinVoltage ) 1 (REQUIRED) Maximum allowable voltage for customer connected nodes (p.u.). Violation of this voltage causes RED condition. (identical for both MV and LV lines) MinVoltage Float ( > 0, < MaxVoltage) 1 (REQUIRED) Minimum allowable voltage for customer connected nodes (p.u.). Violation of this voltage causes RED condition. (identical for both MV and LV lines) UpperAmberBandVoltage Float (MaxVoltage - UpperAmberBand > MinVoltage + LowerAmberBand, >0) 1 (REQUIRED) Voltage margin for AMBER condition of overvoltage. (p.u.) LowerAmberBandVoltage Float (MaxVoltage - UpperAmberBand > MinVoltage + LowerAmberBand, >0) 1 (REQUIRED) Voltage margin for AMBER condition of undervoltage. (p.u.) OverloadingBaseline Float ( >0 ) 1 (REQUIRED) Component loading limit that is considered RED condition (typically 1, corresponding to 100% loading). AmberloadingBaseline Float ( >0, <= OverloadingBaseline) 1 (REQUIRED) Component loading limit that is considered AMBER condition (e.g., 0.9)","title":"PredictiveGridOptimization block"},{"location":"energy_msg-startmessageblocks/#statemonitoring-block","text":"Field Type Multiplicity Explanation MonitoredGridName String 1 (REQUIRED) String referring to a Grid instance in the running simulation (e.g. \"GridA\") MaxVoltage Float ( > 0, > MinVoltage ) 1 (REQUIRED) Maximum allowable voltage for customer connected nodes (p.u.). Violation of this voltage causes RED condition. (identical for both MV and LV lines) MinVoltage Float ( > 0, < MaxVoltage) 1 (REQUIRED) Minimum allowable voltage for customer connected nodes (p.u.). Violation of this voltage causes RED condition. (identical for both MV and LV lines) UpperAmberBandVoltage Float (MaxVoltage - UpperAmberBand > MinVoltage + LowerAmberBand, >0) 1 (REQUIRED) Voltage margin for AMBER condition of overvoltage. (p.u.) LowerAmberBandVoltage Float (MaxVoltage - UpperAmberBand > MinVoltage + LowerAmberBand, >0) 1 (REQUIRED) Voltage margin for AMBER condition of undervoltage. (p.u.) OverloadingBaseline Float ( >0 ) 1 (REQUIRED) Component loading limit that is considered RED condition (typically 1, corresponding to 100% loading) AmberloadingBaseline Float ( >0, <= OverloadingBaseline) 1 (REQUIRED) Component loading limit that is considered AMBER condition (e.g., 0.9)","title":"StateMonitoring block"},{"location":"energy_msg-startmessageblocks/#static-time-series-block","text":"Note: the Platform Manager passes these parameters directly to the Static Time Series Resource instance through environmental variables. They are included as part of the Start message to make the used parameters visible to the other components as well as to the Logging System. Field Type Multiplicity Explanation ResourceType String 1(REQUIRED) The type of the resource. MUST be either \"Load\" or \"Resource\". ResourceStateFile String 1 (REQUIRED) The name of the CSV file containing the static time series. ResourceFileDelimiter String 0..1 (OPTIONAL) The delimiter that is used in the CSV file. The default delimiter is comma, i.e. \",\".","title":"Static time series block"},{"location":"energy_msg-startmessageblocks/#storage-resource-block","text":"Note: the Platform Manager passes these parameters directly to the Storage Resource instance through environmental variables. They are included as part of the Start message to make the used parameters visible to the other components as well as to the Logging System. Field Type Multiplicity Explanation ResourceStateFile String 0..1 (OPTIONAL) The name of the CSV file containing control state information. ResourceStateDelimiter String 0..1 (OPTIONAL) The delimiter that is used in the CSV file. The default delimiter is comma, i.e. \",\". Bus String 0..1 (OPTIONAL) Name of bus to which the resource is connected. Required if ResourceStateCsvFile is not given. Node String 0..1 (OPTIONAL) Node that 1-phase resource is connected to. Possible values 1, 2 and 3. Used if file state source is not used and if then this is not specified then it is assumed that the resource is 3-phase resource. ChargeRate Float 0..1 (OPTIONAL) Charging rate (input power) in Percent of rated kW. Default value 100.0. DischargeRate Float 0..1 (OPTIONAL) Discharge rate (output power) in Percent of rated kW. Default value 100.0. InitialStateOfCharge Float 1 (REQUIRED) Initial amount of energy stored, %. KwhRated Float 1 (REQUIRED) Rated storage capacity in kWh. DischargeEfficiency Float 0..1 (OPTIONAL) Percent, efficiency for discharging the storage. Default value 90.0. ChargeEfficiency Float 0..1 (OPTIONAL) Percent, efficiency for charging the storage. Default value 90.0. KwRated Float 1 (REQUIRED) kW rating of power output. SelfDischarge Float 0..1 (OPTIONAL) Percent of rated kWh drained from storage while idling. Default value 0.0.","title":"Storage resource block"},{"location":"energy_msg-startmessageblocks/#static-time-series-resource-forecaster-block","text":"Note: the Platform Manager passes these parameters directly to the Static Time Series Resource Forecaster instance through environmental variables. They are included as part of the Start message to make the used parameters visible to the other components as well as to the Logging System. Field Type Multiplicity Explanation ResourceForecastComponentIds String 1 (REQUIRED) List names (strings) of forecasted resources. This information should match with csv file names that contain resource forecast state information. ResourceTypes String 1 (REQUIRED) List types (strings) of forecasted resources. Accepted values are Generator or Load. ResourceForecastStateCsvFolder String 1 (REQUIRED) Location of the folder that contains csv files. Csv files contain the resource forecast state information used in the simulation. Relative file paths are in relation to the current working directory. ResourceStateCsvDelimiter String 0..1 (OPTIONAL) The delimiter that is used in the CSV file. The default delimiter is comma, i.e. \",\". ResourceType String 0..1 (OPTIONAL) Type of this resource. Default is \"ResourceForecaster\". ResourceForecastTopic String 0..1 (OPTIONAL) The upper level topic under whose subtopics the resource states are published. If this environment variable is not present \"ResourceForecastState\" is used. ForecastHorizon String 0..1 (OPTIONAL) If this environment variable is not present then default \"PT36H\" is used. UnitOfMeasure String 0..1 (OPTIONAL) If this environment variable is not present then default \"kW\" is used.","title":"Static Time Series Resource Forecaster block"},{"location":"energy_msg-startmessageblocks/#lfm-block","text":"Field Type Multiplicity Explanation MarketOpeningTime Integer [0 ... 24] 1 (REQUIRED) Hour of day when market opens MarketClosingTime Integer [0 ... 24] 1 (REQUIRED) Hour of day when market closes FlexibilityProviderList Array of String 1 (REQUIRED) List of SourceProcessIds for processes that are expected to send FlexibilityNeed msgs FlexibilityProcurerList Array of String 1 (REQUIRED) List of SourceProcessIds for processes that are expected to send Offer msgs","title":"LFM block"},{"location":"energy_msgtype/","text":"Message type names (energy) Message Type name (case sensitive) ControlState.PowerSetpoint ControlState DMSNetworkStatus.Current (same as message name) DMSNetworkStatus.Voltage (same as message name) FlexibilityNeed (same as message name) Init.CIS.CustomerInfo (same as message name) Init.NIS.NetworkBusInfo (same as message name) Init.NIS.NetworkComponentInfo (same as message name) LFMMarketResult (same as message name) LFMOffering ? NetworkForecastState.Current (same as message name) NetworkForecastState.Voltage (same as message name) NetworkState.Current (same as message name) NetworkState.Loss (same as message name) NetworkState.Voltage (same as message name) Offer (same as message name) PriceForecastState (same as message name) ResourceForecastState.Dispatch (same as message name) ResourceForecastState.Power (same as message name) ResourceState (same as message name) Request (same as message name) SelectedOffer (same as message name)","title":"Message type names (energy)"},{"location":"energy_msgtype/#message-type-names-energy","text":"Message Type name (case sensitive) ControlState.PowerSetpoint ControlState DMSNetworkStatus.Current (same as message name) DMSNetworkStatus.Voltage (same as message name) FlexibilityNeed (same as message name) Init.CIS.CustomerInfo (same as message name) Init.NIS.NetworkBusInfo (same as message name) Init.NIS.NetworkComponentInfo (same as message name) LFMMarketResult (same as message name) LFMOffering ? NetworkForecastState.Current (same as message name) NetworkForecastState.Voltage (same as message name) NetworkState.Current (same as message name) NetworkState.Loss (same as message name) NetworkState.Voltage (same as message name) Offer (same as message name) PriceForecastState (same as message name) ResourceForecastState.Dispatch (same as message name) ResourceForecastState.Power (same as message name) ResourceState (same as message name) Request (same as message name) SelectedOffer (same as message name)","title":"Message type names (energy)"},{"location":"energy_overview/","text":"Energy domain overview Energy-domain-specific conventions Components (energy): Controller Distribution management system (DMS) Grid (DSS) Economic Dispatch Price Forecaster Procem-LFM Resource Forecaster Static time series resource Storage Message structures (energy): ControlState.PowerSetpoint DMSNetworkStatus.Current DMSNetworkStatus.Voltage FlexibilityNeed Init.CIS.CustomerInfo Init.NIS.NetworkBusInfo Init.NIS.NetworkComponentInfo LFMMarketResult LFMOffering NetworkForecastState.Current NetworkForecastState.Voltage NetworkState.Current NetworkState.Loss NetworkState.Voltage Offer PriceForecastState Request ResourceForecastState.Dispatch ResourceForecastState.Power ResourceState SelectedOffer Start message blocks Message type names (energy) Software packages Topics (energy): Topics (energy) PriceForecastState.(MarketId).(ResourceId) ResourceForecastState.(ResourceCategory).(ResourceId) ResourceState.(ResourceCategory).(ResourceId) Scenarios: Energy community demo","title":"Overview"},{"location":"energy_overview/#energy-domain-overview","text":"Energy-domain-specific conventions Components (energy): Controller Distribution management system (DMS) Grid (DSS) Economic Dispatch Price Forecaster Procem-LFM Resource Forecaster Static time series resource Storage Message structures (energy): ControlState.PowerSetpoint DMSNetworkStatus.Current DMSNetworkStatus.Voltage FlexibilityNeed Init.CIS.CustomerInfo Init.NIS.NetworkBusInfo Init.NIS.NetworkComponentInfo LFMMarketResult LFMOffering NetworkForecastState.Current NetworkForecastState.Voltage NetworkState.Current NetworkState.Loss NetworkState.Voltage Offer PriceForecastState Request ResourceForecastState.Dispatch ResourceForecastState.Power ResourceState SelectedOffer Start message blocks Message type names (energy) Software packages Topics (energy): Topics (energy) PriceForecastState.(MarketId).(ResourceId) ResourceForecastState.(ResourceCategory).(ResourceId) ResourceState.(ResourceCategory).(ResourceId) Scenarios: Energy community demo","title":"Energy domain overview"},{"location":"energy_priceforecaster/","text":"Price Forecaster Description PriceForecaster component predicts / takes a value from historian / etc. for the future status of the price. It subscribes to SimState and Epoch topics and publishes to PriceForecastState topic. Functionalities Predicts the future prices Input file The component has pricedata.csv as an input file. The CSV file should contain MarketId, ResourceId, PricingType, UnitOfMeasure, time slots, and prices associated with time slots. Each time slot needs a column and time slots are named as Time1, Time2, Time3, so on. Price associated with each time slot needs a column and time slot prices are named as Price1, Price2, Price3, so on. Needless to mention, the value in PriceX column belongs to the time in TimeX column. Each row contains values which represent data for one epoch. There should be at least as many data rows as the number of simulation epochs. In the CSV file, \".\" is the decimal separator. Example content for an input file with 2 epoches and 3 time slots (the first two rows are used for the two epoches): Time4 MarketId ResourceId PricingType UnitOfMeasure Time1 Time2 Time3 Price1 Price2 Price3 MyMarket NoResource TOU {EUR}/(kW.h) 2020-02-17T10:00:00Z 2020-02-17T11:00:00Z 2020-02-17T12:00:00Z 14.3 15.8 15.8 MyMarket NoResource TOU {EUR}/(kW.h) 2020-02-17T11:00:00Z 2020-02-17T12:00:00Z 2020-02-17T13:00:00Z 15.8 15.7 14.9 Environment variables Variable Example value Note SIMULATION_COMPONENT_NAME PriceForecaster PRICE_FORECASTER_STATE_CSV_FILE pricedata.csv Workflow of the component Simulation is started PriceForecaster receives SimState message \"running\" from SimulationManager. PriceForecaster responds to SimulationManager with Status message \"ready\". PriceForecaster receives an Epoch message for a new epoch. The epoch number for the first epoch is 1. PriceForecaster publishes PriceForecastState a. PriceForecaster re-publishes PriceForecastState if it receives Epoch message for the running epoch again PriceForecaster sends a Status message with value \"ready\" Repeat steps 4-6 for each epoch with growing epoch number. PriceForecaster receives a SimState message \"stopped\" from SimulationManager. PriceForecaster closes itself. Epoch workflow of the component Read next line from CSV file Create a PriceForecastState message based on the data taken from the CSV file Publish the PriceForecastState message a. Re-publish PriceForecastState message if Epoch message is received for the running epoch again Publish status ready message External packages The following packages are needed. Package Version Why needed URL Simulation Tools Component implementation based on AbstractSimulationComponent https://github.com/simcesplatform/simulation-tools Domain messages Uses the PriceForecastStateMessage class https://github.com/simcesplatform/domain-messages","title":"Price Forecaster"},{"location":"energy_priceforecaster/#price-forecaster","text":"","title":"Price Forecaster"},{"location":"energy_priceforecaster/#description","text":"PriceForecaster component predicts / takes a value from historian / etc. for the future status of the price. It subscribes to SimState and Epoch topics and publishes to PriceForecastState topic.","title":"Description"},{"location":"energy_priceforecaster/#functionalities","text":"Predicts the future prices","title":"Functionalities"},{"location":"energy_priceforecaster/#input-file","text":"The component has pricedata.csv as an input file. The CSV file should contain MarketId, ResourceId, PricingType, UnitOfMeasure, time slots, and prices associated with time slots. Each time slot needs a column and time slots are named as Time1, Time2, Time3, so on. Price associated with each time slot needs a column and time slot prices are named as Price1, Price2, Price3, so on. Needless to mention, the value in PriceX column belongs to the time in TimeX column. Each row contains values which represent data for one epoch. There should be at least as many data rows as the number of simulation epochs. In the CSV file, \".\" is the decimal separator. Example content for an input file with 2 epoches and 3 time slots (the first two rows are used for the two epoches): Time4 MarketId ResourceId PricingType UnitOfMeasure Time1 Time2 Time3 Price1 Price2 Price3 MyMarket NoResource TOU {EUR}/(kW.h) 2020-02-17T10:00:00Z 2020-02-17T11:00:00Z 2020-02-17T12:00:00Z 14.3 15.8 15.8 MyMarket NoResource TOU {EUR}/(kW.h) 2020-02-17T11:00:00Z 2020-02-17T12:00:00Z 2020-02-17T13:00:00Z 15.8 15.7 14.9","title":"Input file"},{"location":"energy_priceforecaster/#environment-variables","text":"Variable Example value Note SIMULATION_COMPONENT_NAME PriceForecaster PRICE_FORECASTER_STATE_CSV_FILE pricedata.csv","title":"Environment variables"},{"location":"energy_priceforecaster/#workflow-of-the-component","text":"Simulation is started PriceForecaster receives SimState message \"running\" from SimulationManager. PriceForecaster responds to SimulationManager with Status message \"ready\". PriceForecaster receives an Epoch message for a new epoch. The epoch number for the first epoch is 1. PriceForecaster publishes PriceForecastState a. PriceForecaster re-publishes PriceForecastState if it receives Epoch message for the running epoch again PriceForecaster sends a Status message with value \"ready\" Repeat steps 4-6 for each epoch with growing epoch number. PriceForecaster receives a SimState message \"stopped\" from SimulationManager. PriceForecaster closes itself.","title":"Workflow of the component"},{"location":"energy_priceforecaster/#epoch-workflow-of-the-component","text":"Read next line from CSV file Create a PriceForecastState message based on the data taken from the CSV file Publish the PriceForecastState message a. Re-publish PriceForecastState message if Epoch message is received for the running epoch again Publish status ready message","title":"Epoch workflow of the component"},{"location":"energy_priceforecaster/#external-packages","text":"The following packages are needed. Package Version Why needed URL Simulation Tools Component implementation based on AbstractSimulationComponent https://github.com/simcesplatform/simulation-tools Domain messages Uses the PriceForecastStateMessage class https://github.com/simcesplatform/domain-messages","title":"External packages"},{"location":"energy_procem-lfm/","text":"Procem-LFM TODO","title":"Procem-LFM"},{"location":"energy_procem-lfm/#procem-lfm","text":"TODO","title":"Procem-LFM"},{"location":"energy_resourceforecaster/","text":"Resource Forecaster Description ResourceForecaster component predicts / takes a value from historian / etc. for the future status of the resource. Note! This is static time series version of Resource Forecaster. Functionalities Predicts the future status of resource ResourceForecaster definition Input parameters Property Datatype Example forecasting_horizon ISO 8601 duration PT36H Environment variables Variable Example value Note SIMULATION_COMPONENT_NAME resource_forecaster RESOURCE_TYPES Load, Generator List types of forecasted resources. Accepted types are Generator or Load. RESOURCE_FORECAST_COMPONENT_IDS load1, generator1 This should match with information provided with 'name' input parameter in Resources for each resource to be forecasted RESOURCE_FORECAST_STATE_CSV_FOLDER ./ FORECAST_HORIZON PT36H Data Subscribe Topic Payload Publish Topic Payload ResourceForecastState.(ResourceCategory).(ResourceId) Real power Workflow Simulation is started ResourceForecaster receives SimState message \"running\" from SimulationManager. ResourceForecaster responds to SimulationManager with Status message \"ready\". ResourceForecaster receives an Epoch message for a new epoch. The epoch number for the first epoch is 1. ResourceForecaster publishes ResourceForecast.Power message to ResourceForecastState topic. Real powers are selected from imported timeseries. Running epoch start time + variable 'forecast_horizon' determines how many real power values are sended. a. ResourceForecaster re-sends ResourceForecast if it receives Epoch message for the running epoch again ResourceForecaster sends a Status message with value \"ready\" Repeat steps 4-6 for each epoch with growing epoch number. ResourceForecaster receives a SimState message \"stopped\" from SimulationManager. ResourceForecaster closes itself","title":"Resource Forecaster"},{"location":"energy_resourceforecaster/#resource-forecaster","text":"","title":"Resource Forecaster"},{"location":"energy_resourceforecaster/#description","text":"ResourceForecaster component predicts / takes a value from historian / etc. for the future status of the resource. Note! This is static time series version of Resource Forecaster.","title":"Description"},{"location":"energy_resourceforecaster/#functionalities","text":"Predicts the future status of resource","title":"Functionalities"},{"location":"energy_resourceforecaster/#resourceforecaster-definition","text":"","title":"ResourceForecaster definition"},{"location":"energy_resourceforecaster/#input-parameters","text":"Property Datatype Example forecasting_horizon ISO 8601 duration PT36H","title":"Input parameters"},{"location":"energy_resourceforecaster/#environment-variables","text":"Variable Example value Note SIMULATION_COMPONENT_NAME resource_forecaster RESOURCE_TYPES Load, Generator List types of forecasted resources. Accepted types are Generator or Load. RESOURCE_FORECAST_COMPONENT_IDS load1, generator1 This should match with information provided with 'name' input parameter in Resources for each resource to be forecasted RESOURCE_FORECAST_STATE_CSV_FOLDER ./ FORECAST_HORIZON PT36H","title":"Environment variables"},{"location":"energy_resourceforecaster/#data","text":"Subscribe Topic Payload Publish Topic Payload ResourceForecastState.(ResourceCategory).(ResourceId) Real power","title":"Data"},{"location":"energy_resourceforecaster/#workflow","text":"Simulation is started ResourceForecaster receives SimState message \"running\" from SimulationManager. ResourceForecaster responds to SimulationManager with Status message \"ready\". ResourceForecaster receives an Epoch message for a new epoch. The epoch number for the first epoch is 1. ResourceForecaster publishes ResourceForecast.Power message to ResourceForecastState topic. Real powers are selected from imported timeseries. Running epoch start time + variable 'forecast_horizon' determines how many real power values are sended. a. ResourceForecaster re-sends ResourceForecast if it receives Epoch message for the running epoch again ResourceForecaster sends a Status message with value \"ready\" Repeat steps 4-6 for each epoch with growing epoch number. ResourceForecaster receives a SimState message \"stopped\" from SimulationManager. ResourceForecaster closes itself","title":"Workflow"},{"location":"energy_run-ec-demo/","text":"Running the Energy Community demo scenario simulation After successfully running the first test simulation , the next step is to run a simulation with at least one domain component. The Energy Community (EC) demo scenario uses platform managed Static time series resource components along with the core components. The scenario is defined at the documentation page Energy community demo scenario . Installing the domain component To be able to use the Static time series resource component in a simulation run, it must first be installed. Use the following steps to make it available for the platform to use. Ensure that the file docker_images_domain.txt contains the Docker image name for the StaticTimeSeriesResource: ghcr.io/simcesplatform/static-time-series-resource:latest Ensure that the file components/github_server_domain.yml contains in the Repositories list the code repository for StaticTimeSeriesResource: simcesplatform/static-time-series-resource Using Bash compatible terminal (Git Bash in Windows) navigate to the platform folder (the folder where the platform is installed). Install the StaticTimeSeriesResource component along with the other domain components by using the command: source platform_domain_setup.sh This script will fetch the Docker images and component manifest files for the domain components as well as make all the input files in the resources folder available for the simulation platform. (Optional) Look through the simulation configuration file and see how it corresponds to the scenario description at Energy community demo scenario . The ready-made configuration file can be found at simulation_configuration_ec.yml . Note, that the filenames for the CSV files that resource component uses are given as /resources/<filename> where the <filename> is the corresponding filename at the local folder platform/resources/ Starting the simulation run To start the EC demo scenario simulation, use Bash compatible terminal to navigate to the platform folder and use the command source start_simulation.sh simulation_configuration_ec.yml To follow the simulation run while it is running see the page: Following a running simulation Checking the results from the simulation run After the simulation run has been completed you should be able to use the Log Reader to look through the messages used in the simulation. A couple of examples of using the Log Reader API are given below. In all examples, <simulation_id> should be replaced by the simulation id given by the Platform Manager. Get a list of messages sent from the electric vehicle component (electric_vehicle) at epoch 16. Request: http://localhost:8080/simulations/<simulation_id>/messages?process=electric_vehicle&epoch=12 Response: [ { \"CustomerId\": \"10\", \"EpochNumber\": 16, \"MessageId\": \"electric_vehicle-32\", \"Node\": 2, \"ReactivePower\": { \"UnitOfMeasure\": \"kV.A{r}\", \"Value\": 0.0 }, \"RealPower\": { \"UnitOfMeasure\": \"kW\", \"Value\": -5.5 }, \"SimulationId\": \"2021-10-12T13:37:48.914Z\", \"SourceProcessId\": \"electric_vehicle\", \"Timestamp\": \"2021-10-12T13:38:53.593000Z\", \"Topic\": \"ResourceState.Load.electric_vehicle\", \"TriggeringMessageIds\": [ \"simulation-manager-17\" ], \"Type\": \"ResourceState\" }, { \"EpochNumber\": 16, \"MessageId\": \"electric_vehicle-33\", \"SimulationId\": \"2021-10-12T13:37:48.914Z\", \"SourceProcessId\": \"electric_vehicle\", \"Timestamp\": \"2021-10-12T13:38:53.599000Z\", \"Topic\": \"Status.Ready\", \"TriggeringMessageIds\": [ \"simulation-manager-17\" ], \"Type\": \"Status\", \"Value\": \"ready\" } ] Get a time series for the real powers for the first load (load_1) for the entire simulation (the result given in CSV format). Request: http://localhost:8080/simulations/<simulation_id>/timeseries?attrs=RealPower&topic=ResourceState.Load.load_1&format=csv Response: epoch;timestamp;ResourceState.Load.load_1:load_1.RealPower 1;2020-06-24T21:00:00Z;-0.2 2;2020-06-24T22:00:00Z;-0.27 3;2020-06-24T23:00:00Z;-0.15 4;2020-06-25T00:00:00Z;-0.21 5;2020-06-25T01:00:00Z;-0.26 6;2020-06-25T02:00:00Z;-0.15 7;2020-06-25T03:00:00Z;-0.21 8;2020-06-25T04:00:00Z;-0.26 9;2020-06-25T05:00:00Z;-0.16 10;2020-06-25T06:00:00Z;-0.22 11;2020-06-25T07:00:00Z;-0.23 12;2020-06-25T08:00:00Z;-0.17 13;2020-06-25T09:00:00Z;-0.24 14;2020-06-25T10:00:00Z;-0.2 15;2020-06-25T11:00:00Z;-0.17 16;2020-06-25T12:00:00Z;-0.27 17;2020-06-25T13:00:00Z;-0.18 18;2020-06-25T14:00:00Z;-0.18 19;2020-06-25T15:00:00Z;-0.28 20;2020-06-25T16:00:00Z;-0.16 21;2020-06-25T17:00:00Z;-0.2 22;2020-06-25T18:00:00Z;-0.27 23;2020-06-25T19:00:00Z;-0.15 24;2020-06-25T20:00:00Z;-0.21 Get a time series for real powers of the generators between epochs 5 and 8 (the result given in CSV format). Request: http://localhost:8080/simulations/<simulation_id>/timeseries?attrs=RealPower&topic=ResourceState.Generator.%23&startEpoch=5&endEpoch=8&format=csv Response: epoch;timestamp;ResourceState.Generator.pv_large:pv_large.RealPower;ResourceState.Generator.pv_small:pv_small.RealPower 5;2020-06-25T01:00:00Z;0.35;0.14 6;2020-06-25T02:00:00Z;0.84;0.34 7;2020-06-25T03:00:00Z;1.4;0.57 8;2020-06-25T04:00:00Z;1.89;0.76 Note, that when using the Log Reader API, the special # characters which can be used with RabbitMQ topic names, must be replaced with %23 as has been done in the last example. See more information about URL encoding from https://www.w3schools.com/tags/ref_urlencode.ASP .","title":"Run Energy Community demo"},{"location":"energy_run-ec-demo/#running-the-energy-community-demo-scenario-simulation","text":"After successfully running the first test simulation , the next step is to run a simulation with at least one domain component. The Energy Community (EC) demo scenario uses platform managed Static time series resource components along with the core components. The scenario is defined at the documentation page Energy community demo scenario .","title":"Running the Energy Community demo scenario simulation"},{"location":"energy_run-ec-demo/#installing-the-domain-component","text":"To be able to use the Static time series resource component in a simulation run, it must first be installed. Use the following steps to make it available for the platform to use. Ensure that the file docker_images_domain.txt contains the Docker image name for the StaticTimeSeriesResource: ghcr.io/simcesplatform/static-time-series-resource:latest Ensure that the file components/github_server_domain.yml contains in the Repositories list the code repository for StaticTimeSeriesResource: simcesplatform/static-time-series-resource Using Bash compatible terminal (Git Bash in Windows) navigate to the platform folder (the folder where the platform is installed). Install the StaticTimeSeriesResource component along with the other domain components by using the command: source platform_domain_setup.sh This script will fetch the Docker images and component manifest files for the domain components as well as make all the input files in the resources folder available for the simulation platform. (Optional) Look through the simulation configuration file and see how it corresponds to the scenario description at Energy community demo scenario . The ready-made configuration file can be found at simulation_configuration_ec.yml . Note, that the filenames for the CSV files that resource component uses are given as /resources/<filename> where the <filename> is the corresponding filename at the local folder platform/resources/","title":"Installing the domain component"},{"location":"energy_run-ec-demo/#starting-the-simulation-run","text":"To start the EC demo scenario simulation, use Bash compatible terminal to navigate to the platform folder and use the command source start_simulation.sh simulation_configuration_ec.yml To follow the simulation run while it is running see the page: Following a running simulation","title":"Starting the simulation run"},{"location":"energy_run-ec-demo/#checking-the-results-from-the-simulation-run","text":"After the simulation run has been completed you should be able to use the Log Reader to look through the messages used in the simulation. A couple of examples of using the Log Reader API are given below. In all examples, <simulation_id> should be replaced by the simulation id given by the Platform Manager. Get a list of messages sent from the electric vehicle component (electric_vehicle) at epoch 16. Request: http://localhost:8080/simulations/<simulation_id>/messages?process=electric_vehicle&epoch=12 Response: [ { \"CustomerId\": \"10\", \"EpochNumber\": 16, \"MessageId\": \"electric_vehicle-32\", \"Node\": 2, \"ReactivePower\": { \"UnitOfMeasure\": \"kV.A{r}\", \"Value\": 0.0 }, \"RealPower\": { \"UnitOfMeasure\": \"kW\", \"Value\": -5.5 }, \"SimulationId\": \"2021-10-12T13:37:48.914Z\", \"SourceProcessId\": \"electric_vehicle\", \"Timestamp\": \"2021-10-12T13:38:53.593000Z\", \"Topic\": \"ResourceState.Load.electric_vehicle\", \"TriggeringMessageIds\": [ \"simulation-manager-17\" ], \"Type\": \"ResourceState\" }, { \"EpochNumber\": 16, \"MessageId\": \"electric_vehicle-33\", \"SimulationId\": \"2021-10-12T13:37:48.914Z\", \"SourceProcessId\": \"electric_vehicle\", \"Timestamp\": \"2021-10-12T13:38:53.599000Z\", \"Topic\": \"Status.Ready\", \"TriggeringMessageIds\": [ \"simulation-manager-17\" ], \"Type\": \"Status\", \"Value\": \"ready\" } ] Get a time series for the real powers for the first load (load_1) for the entire simulation (the result given in CSV format). Request: http://localhost:8080/simulations/<simulation_id>/timeseries?attrs=RealPower&topic=ResourceState.Load.load_1&format=csv Response: epoch;timestamp;ResourceState.Load.load_1:load_1.RealPower 1;2020-06-24T21:00:00Z;-0.2 2;2020-06-24T22:00:00Z;-0.27 3;2020-06-24T23:00:00Z;-0.15 4;2020-06-25T00:00:00Z;-0.21 5;2020-06-25T01:00:00Z;-0.26 6;2020-06-25T02:00:00Z;-0.15 7;2020-06-25T03:00:00Z;-0.21 8;2020-06-25T04:00:00Z;-0.26 9;2020-06-25T05:00:00Z;-0.16 10;2020-06-25T06:00:00Z;-0.22 11;2020-06-25T07:00:00Z;-0.23 12;2020-06-25T08:00:00Z;-0.17 13;2020-06-25T09:00:00Z;-0.24 14;2020-06-25T10:00:00Z;-0.2 15;2020-06-25T11:00:00Z;-0.17 16;2020-06-25T12:00:00Z;-0.27 17;2020-06-25T13:00:00Z;-0.18 18;2020-06-25T14:00:00Z;-0.18 19;2020-06-25T15:00:00Z;-0.28 20;2020-06-25T16:00:00Z;-0.16 21;2020-06-25T17:00:00Z;-0.2 22;2020-06-25T18:00:00Z;-0.27 23;2020-06-25T19:00:00Z;-0.15 24;2020-06-25T20:00:00Z;-0.21 Get a time series for real powers of the generators between epochs 5 and 8 (the result given in CSV format). Request: http://localhost:8080/simulations/<simulation_id>/timeseries?attrs=RealPower&topic=ResourceState.Generator.%23&startEpoch=5&endEpoch=8&format=csv Response: epoch;timestamp;ResourceState.Generator.pv_large:pv_large.RealPower;ResourceState.Generator.pv_small:pv_small.RealPower 5;2020-06-25T01:00:00Z;0.35;0.14 6;2020-06-25T02:00:00Z;0.84;0.34 7;2020-06-25T03:00:00Z;1.4;0.57 8;2020-06-25T04:00:00Z;1.89;0.76 Note, that when using the Log Reader API, the special # characters which can be used with RabbitMQ topic names, must be replaced with %23 as has been done in the last example. See more information about URL encoding from https://www.w3schools.com/tags/ref_urlencode.ASP .","title":"Checking the results from the simulation run"},{"location":"energy_scenario-ec-demo/","text":"Energy community demo scenario Simple energy community (EC) demo scenario that is used as a SimCES simulation platform test case: Running the EC demo scenario Description This scenario describes the behavior of a small rural energy community of four detached houses. The houses have no controllable loads or storages but two of them have a small scale PV (photovoltaic) systems installed and one has a electric vehicle charging. Scenario spans over one day with hourly resolution (epochs). Scenario setup is depicted on image below. The scenario network has 12 buses (Source + 11 others) where houses are connected to buses 5, 7, 10 and 11. Houses at buses 5 and 7 have the PV generation and the house at bus 10 has the EV charging. Load and generation timeseries Load curves (i.e. the hourly energy demand) of the houses are depicted in figure below for the scenario time period. Houses at buses 5, 7 and 11 have moderate consumption throughout the day whereas the house in bus 10 has relatively higher consumption that increases at afternoon. Generation for the two PV systems is depicted in figure below. The smaller system is connected to bus 5 and the larger one to bus 7. generation profile shows sunny morning with intermittent cloud coverage around noon. The data for the demo scenario in CSV files can be found at https://github.com/simcesplatform/Platform-Manager/tree/master/resources . The given CSV files are compatible for use with the Static time series resource component in simulation runs. Epochs Epoch # Start time End time 1 2020-06-25T00:00 2020-06-25T01:00 2 2020-06-25T01:00 2020-06-25T02:00 3 2020-06-25T02:00 2020-06-25T03:00 4 2020-06-25T03:00 2020-06-25T04:00 5 2020-06-25T04:00 2020-06-25T05:00 6 2020-06-25T05:00 2020-06-25T06:00 7 2020-06-25T06:00 2020-06-25T07:00 8 2020-06-25T07:00 2020-06-25T08:00 9 2020-06-25T08:00 2020-06-25T09:00 10 2020-06-25T09:00 2020-06-25T10:00 11 2020-06-25T10:00 2020-06-25T11:00 12 2020-06-25T11:00 2020-06-25T12:00 13 2020-06-25T12:00 2020-06-25T13:00 14 2020-06-25T13:00 2020-06-25T14:00 15 2020-06-25T14:00 2020-06-25T15:00 16 2020-06-25T15:00 2020-06-25T16:00 17 2020-06-25T16:00 2020-06-25T17:00 18 2020-06-25T17:00 2020-06-25T18:00 19 2020-06-25T18:00 2020-06-25T19:00 20 2020-06-25T19:00 2020-06-25T20:00 21 2020-06-25T20:00 2020-06-25T21:00 22 2020-06-25T21:00 2020-06-25T22:00 23 2020-06-25T22:00 2020-06-25T23:00 24 2020-06-25T23:00 2020-06-26T00:00 All times are given in Finnish local time (EEST). Network model (for State Monitoring) V B = 400 V, S B = 50 kW. All values in pu. Positive sequence only. Branch Name SE bus RE bus R X Y G I RATED T1 SourceBus 1 0.072 0.134 0 0.00256 1.73913 L1 1 2 0.056 0.008 0 0 1.12 L2 2 3 0.084 0.007 0 0 0.72 L3 3 4 0.054 0.006 0 0 1 L4 4 5 0.064 0.005 0 0 0.72 L5 2 6 0.249 0.038 0 0 1.12 L6 6 7 0.143 0.002 0 0 0.624 L7 1 8 0.016 0.002 0 0 1.12 L8 8 9 0.074 0.011 0 0 1.12 L9 9 10 0.077 0.006 0 0 0.72 L10 8 11 0.001 0.000 0 0 0.8 Bus Name Type SourceBus SLACK 1 DUMMY 2 DUMMY 3 DUMMY 4 DUMMY 5 PQ 6 DUMMY 7 PQ 8 DUMMY 9 DUMMY 10 PQ 11 PQ","title":"Energy community demo"},{"location":"energy_scenario-ec-demo/#energy-community-demo-scenario","text":"Simple energy community (EC) demo scenario that is used as a SimCES simulation platform test case: Running the EC demo scenario","title":"Energy community demo scenario"},{"location":"energy_scenario-ec-demo/#description","text":"This scenario describes the behavior of a small rural energy community of four detached houses. The houses have no controllable loads or storages but two of them have a small scale PV (photovoltaic) systems installed and one has a electric vehicle charging. Scenario spans over one day with hourly resolution (epochs). Scenario setup is depicted on image below. The scenario network has 12 buses (Source + 11 others) where houses are connected to buses 5, 7, 10 and 11. Houses at buses 5 and 7 have the PV generation and the house at bus 10 has the EV charging.","title":"Description"},{"location":"energy_scenario-ec-demo/#load-and-generation-timeseries","text":"Load curves (i.e. the hourly energy demand) of the houses are depicted in figure below for the scenario time period. Houses at buses 5, 7 and 11 have moderate consumption throughout the day whereas the house in bus 10 has relatively higher consumption that increases at afternoon. Generation for the two PV systems is depicted in figure below. The smaller system is connected to bus 5 and the larger one to bus 7. generation profile shows sunny morning with intermittent cloud coverage around noon. The data for the demo scenario in CSV files can be found at https://github.com/simcesplatform/Platform-Manager/tree/master/resources . The given CSV files are compatible for use with the Static time series resource component in simulation runs.","title":"Load and generation timeseries"},{"location":"energy_scenario-ec-demo/#epochs","text":"Epoch # Start time End time 1 2020-06-25T00:00 2020-06-25T01:00 2 2020-06-25T01:00 2020-06-25T02:00 3 2020-06-25T02:00 2020-06-25T03:00 4 2020-06-25T03:00 2020-06-25T04:00 5 2020-06-25T04:00 2020-06-25T05:00 6 2020-06-25T05:00 2020-06-25T06:00 7 2020-06-25T06:00 2020-06-25T07:00 8 2020-06-25T07:00 2020-06-25T08:00 9 2020-06-25T08:00 2020-06-25T09:00 10 2020-06-25T09:00 2020-06-25T10:00 11 2020-06-25T10:00 2020-06-25T11:00 12 2020-06-25T11:00 2020-06-25T12:00 13 2020-06-25T12:00 2020-06-25T13:00 14 2020-06-25T13:00 2020-06-25T14:00 15 2020-06-25T14:00 2020-06-25T15:00 16 2020-06-25T15:00 2020-06-25T16:00 17 2020-06-25T16:00 2020-06-25T17:00 18 2020-06-25T17:00 2020-06-25T18:00 19 2020-06-25T18:00 2020-06-25T19:00 20 2020-06-25T19:00 2020-06-25T20:00 21 2020-06-25T20:00 2020-06-25T21:00 22 2020-06-25T21:00 2020-06-25T22:00 23 2020-06-25T22:00 2020-06-25T23:00 24 2020-06-25T23:00 2020-06-26T00:00 All times are given in Finnish local time (EEST).","title":"Epochs"},{"location":"energy_scenario-ec-demo/#network-model-for-state-monitoring","text":"V B = 400 V, S B = 50 kW. All values in pu. Positive sequence only.","title":"Network model (for State Monitoring)"},{"location":"energy_scenario-ec-demo/#branch","text":"Name SE bus RE bus R X Y G I RATED T1 SourceBus 1 0.072 0.134 0 0.00256 1.73913 L1 1 2 0.056 0.008 0 0 1.12 L2 2 3 0.084 0.007 0 0 0.72 L3 3 4 0.054 0.006 0 0 1 L4 4 5 0.064 0.005 0 0 0.72 L5 2 6 0.249 0.038 0 0 1.12 L6 6 7 0.143 0.002 0 0 0.624 L7 1 8 0.016 0.002 0 0 1.12 L8 8 9 0.074 0.011 0 0 1.12 L9 9 10 0.077 0.006 0 0 0.72 L10 8 11 0.001 0.000 0 0 0.8","title":"Branch"},{"location":"energy_scenario-ec-demo/#bus","text":"Name Type SourceBus SLACK 1 DUMMY 2 DUMMY 3 DUMMY 4 DUMMY 5 PQ 6 DUMMY 7 PQ 8 DUMMY 9 DUMMY 10 PQ 11 PQ","title":"Bus"},{"location":"energy_software-pkg/","text":"Software packages To reduce the amount of redundant development work, there are re-usable software packages. Domain Messages This package implements classes for processing messages that multiple components must use in communication. These messages include at least ResourceState and PriceForecastState. The package and its detailed documentation are available at https://github.com/simcesplatform/domain-messages Domain Tools This package contains miscellaneous shared domain specific code for the simulation platform. The package and its detailed documentation are available at https://github.com/simcesplatform/domain-tools Matlab integration To integrate Matlab with the RabbitMQ/AMQP message bus, you can use one of the following. AmqpMathToolIntegration This Java library provides you a full control over when you check for new messages. See https://github.com/simcesplatform/AmqpMathToolIntegration Cocop.AmqpMathToolConnector This Java library delivers received messages as Matlab events as soon as they arrive. See https://github.com/kannisto/Cocop.AmqpMathToolConnector","title":"Software packages"},{"location":"energy_software-pkg/#software-packages","text":"To reduce the amount of redundant development work, there are re-usable software packages.","title":"Software packages"},{"location":"energy_software-pkg/#domain-messages","text":"This package implements classes for processing messages that multiple components must use in communication. These messages include at least ResourceState and PriceForecastState. The package and its detailed documentation are available at https://github.com/simcesplatform/domain-messages","title":"Domain Messages"},{"location":"energy_software-pkg/#domain-tools","text":"This package contains miscellaneous shared domain specific code for the simulation platform. The package and its detailed documentation are available at https://github.com/simcesplatform/domain-tools","title":"Domain Tools"},{"location":"energy_software-pkg/#matlab-integration","text":"To integrate Matlab with the RabbitMQ/AMQP message bus, you can use one of the following.","title":"Matlab integration"},{"location":"energy_software-pkg/#amqpmathtoolintegration","text":"This Java library provides you a full control over when you check for new messages. See https://github.com/simcesplatform/AmqpMathToolIntegration","title":"AmqpMathToolIntegration"},{"location":"energy_software-pkg/#cocopamqpmathtoolconnector","text":"This Java library delivers received messages as Matlab events as soon as they arrive. See https://github.com/kannisto/Cocop.AmqpMathToolConnector","title":"Cocop.AmqpMathToolConnector"},{"location":"energy_static-time-series-resource/","text":"Static time series resource Names and locations Item Value Link to source code https://github.com/simcesplatform/static-time-series-resource Management type Platform managed Docker image name ghcr.io/simcesplatform/static-time-series-resource Location of manifest file https://raw.githubusercontent.com/simcesplatform/static-time-series-resource/master/component_manifest.yml Description A component used to simulate simple loads and generators whose published states are determined by a file containing a simple time series of attribute values for each epoch. Messaging Please note that all topics are specified on the page Topics (energy) . Refer to this page for exact topic patterns and the related message structures. Subscribe This component does not receive any result messages. Publish Topic Payload ResourceState.(ResourceCategory).(ResourceId) State of the resource including real power, reactive power, bus and node for the current epoch. Warnings This component has no documentation about the publishing of warnings in result messages. Startup parameters This component uses the block \"StaticTimeSeriesResource\" in startup parameters. Input files The following table gives a list of the input files. Startup parameter for file Description ResourceStateFile The CSV file should contain columns named after the ResourceState message attributes: RealPower, ReactivePower, CustomerId and Node. The Node column is optional. Each row containing values will then represent data for one epoch. There should be at least as many data rows as there will be epochs. The file may contain other columns which the component ignores. The column separator is by default comma \",\" and it can be changed with the ResourceFileDelimiter startup parameter. Initialization workflow This component does not have any initialization workflow. Epoch workflow In each epoch, the component does the following: Read next line from resource state CSV file. Create a ResourceState message from the CSV line and publish it. Publish ready message Implementation details Language and platform Property Value Programming language Python Platform Python 3.7.6 Operating system Docker Debian 10 (python:3.7.6) External packages The following packages are needed. Package Version Why needed URL Simulation Tools Component implementation based on AbstractSimulationComponent. https://github.com/simcesplatform/simulation-tools Domain tools Uses the shared CSV file reading code. https://github.com/simcesplatform/domain-tools Domain messages Uses the ResourceStateMessage class. https://github.com/simcesplatform/domain-messages","title":"Static time series resource"},{"location":"energy_static-time-series-resource/#static-time-series-resource","text":"","title":"Static time series resource"},{"location":"energy_static-time-series-resource/#names-and-locations","text":"Item Value Link to source code https://github.com/simcesplatform/static-time-series-resource Management type Platform managed Docker image name ghcr.io/simcesplatform/static-time-series-resource Location of manifest file https://raw.githubusercontent.com/simcesplatform/static-time-series-resource/master/component_manifest.yml","title":"Names and locations"},{"location":"energy_static-time-series-resource/#description","text":"A component used to simulate simple loads and generators whose published states are determined by a file containing a simple time series of attribute values for each epoch.","title":"Description"},{"location":"energy_static-time-series-resource/#messaging","text":"Please note that all topics are specified on the page Topics (energy) . Refer to this page for exact topic patterns and the related message structures.","title":"Messaging"},{"location":"energy_static-time-series-resource/#subscribe","text":"This component does not receive any result messages.","title":"Subscribe"},{"location":"energy_static-time-series-resource/#publish","text":"Topic Payload ResourceState.(ResourceCategory).(ResourceId) State of the resource including real power, reactive power, bus and node for the current epoch.","title":"Publish"},{"location":"energy_static-time-series-resource/#warnings","text":"This component has no documentation about the publishing of warnings in result messages.","title":"Warnings"},{"location":"energy_static-time-series-resource/#startup-parameters","text":"This component uses the block \"StaticTimeSeriesResource\" in startup parameters.","title":"Startup parameters"},{"location":"energy_static-time-series-resource/#input-files","text":"The following table gives a list of the input files. Startup parameter for file Description ResourceStateFile The CSV file should contain columns named after the ResourceState message attributes: RealPower, ReactivePower, CustomerId and Node. The Node column is optional. Each row containing values will then represent data for one epoch. There should be at least as many data rows as there will be epochs. The file may contain other columns which the component ignores. The column separator is by default comma \",\" and it can be changed with the ResourceFileDelimiter startup parameter.","title":"Input files"},{"location":"energy_static-time-series-resource/#initialization-workflow","text":"This component does not have any initialization workflow.","title":"Initialization workflow"},{"location":"energy_static-time-series-resource/#epoch-workflow","text":"In each epoch, the component does the following: Read next line from resource state CSV file. Create a ResourceState message from the CSV line and publish it. Publish ready message","title":"Epoch workflow"},{"location":"energy_static-time-series-resource/#implementation-details","text":"","title":"Implementation details"},{"location":"energy_static-time-series-resource/#language-and-platform","text":"Property Value Programming language Python Platform Python 3.7.6 Operating system Docker Debian 10 (python:3.7.6)","title":"Language and platform"},{"location":"energy_static-time-series-resource/#external-packages","text":"The following packages are needed. Package Version Why needed URL Simulation Tools Component implementation based on AbstractSimulationComponent. https://github.com/simcesplatform/simulation-tools Domain tools Uses the shared CSV file reading code. https://github.com/simcesplatform/domain-tools Domain messages Uses the ResourceStateMessage class. https://github.com/simcesplatform/domain-messages","title":"External packages"},{"location":"energy_storage/","text":"Storage resource Description A component for simulating a resource which stores energy. The storage is given a initial state such as energy currently stored, maximum storage capacity and maximum power input and output. The storage is then controlled in each epoch by asking for desired power input or output. This control information can be read from a CSV file or received in each epoch from ControlState messages. The storage reports its state in each epoch with a ResourceState message containing the power input or output and the state of charge as a percentage. If the storage cannot fulfil the desired power for example there is not enough energy stored, the actual power the storage is capable of is reported and the message contains a warning. Messaging Subscribe This component does not receive any result messages if a CSV file is used to control it. If a CSV file is not used this component receives the following result messages: Topic Payload ControlState.(process_id) Power output or input required from the storage for the current epoch Publish Topic Payload ResourceState.Storage.(process_id) Real power and state of charge for the epoch Warnings This component may publish warnings in result messages as explained in the following table. Warning cause When used Related topic warning.input.range Storage is unable to operate with the requested real power. The storage does not have enough energy, it cannot store enough energy or the power is more than the storage is rated for. ResourceState.Storage.(process_id) Startup parameters This component uses the block \"StorageResource\" in startup parameters. Input files The following table gives a list of the input files. Startup parameter for file Description ResourceStateCsvFile When using a CSV file as control state source the file should contain the following columns: RealPower, ReactivePower and CustomerId. A optional Node column can be used. The file may include other columns which will be ignored by the component. ReactivePower is currently not used so it can be for example always zero. Each row containing values will then represent data for one epoch. There should be at least as many data rows as there will be epochs. Decimal separator is \".\" and column separator is by default \",\" which can be changed with the ResourceStateDelimiter startup parameter. Initialization workflow This component does not have any initialization workflow. Epoch workflow In each epoch, the component does the following: Get control state information from either: a. If a CSV file is not used receive a ContRolState message from topic ControlState.process_id b. If a CSV file is used read next line from it Calculate new state for the storage based on real power from control information and the duration of current epoch. Create a ResourceState message from the new state of the storage notably real power and state of charge percentage. If real power of storage state differs from control information add a warning.input.range warning to the message. This indicates that the storage could not operate according to the control power for example it was asked for too much energy. Publish the ResourceState message to topic ResourceState.Storage.(process_id). Publish status ready message. Implementation details Language and platform Programming language Python Platform Python 3.7.6 Operating system Docker Debian 10 (python:3.7.6)","title":"Storage"},{"location":"energy_storage/#storage-resource","text":"","title":"Storage resource"},{"location":"energy_storage/#description","text":"A component for simulating a resource which stores energy. The storage is given a initial state such as energy currently stored, maximum storage capacity and maximum power input and output. The storage is then controlled in each epoch by asking for desired power input or output. This control information can be read from a CSV file or received in each epoch from ControlState messages. The storage reports its state in each epoch with a ResourceState message containing the power input or output and the state of charge as a percentage. If the storage cannot fulfil the desired power for example there is not enough energy stored, the actual power the storage is capable of is reported and the message contains a warning.","title":"Description"},{"location":"energy_storage/#messaging","text":"","title":"Messaging"},{"location":"energy_storage/#subscribe","text":"This component does not receive any result messages if a CSV file is used to control it. If a CSV file is not used this component receives the following result messages: Topic Payload ControlState.(process_id) Power output or input required from the storage for the current epoch","title":"Subscribe"},{"location":"energy_storage/#publish","text":"Topic Payload ResourceState.Storage.(process_id) Real power and state of charge for the epoch","title":"Publish"},{"location":"energy_storage/#warnings","text":"This component may publish warnings in result messages as explained in the following table. Warning cause When used Related topic warning.input.range Storage is unable to operate with the requested real power. The storage does not have enough energy, it cannot store enough energy or the power is more than the storage is rated for. ResourceState.Storage.(process_id)","title":"Warnings"},{"location":"energy_storage/#startup-parameters","text":"This component uses the block \"StorageResource\" in startup parameters.","title":"Startup parameters"},{"location":"energy_storage/#input-files","text":"The following table gives a list of the input files. Startup parameter for file Description ResourceStateCsvFile When using a CSV file as control state source the file should contain the following columns: RealPower, ReactivePower and CustomerId. A optional Node column can be used. The file may include other columns which will be ignored by the component. ReactivePower is currently not used so it can be for example always zero. Each row containing values will then represent data for one epoch. There should be at least as many data rows as there will be epochs. Decimal separator is \".\" and column separator is by default \",\" which can be changed with the ResourceStateDelimiter startup parameter.","title":"Input files"},{"location":"energy_storage/#initialization-workflow","text":"This component does not have any initialization workflow.","title":"Initialization workflow"},{"location":"energy_storage/#epoch-workflow","text":"In each epoch, the component does the following: Get control state information from either: a. If a CSV file is not used receive a ContRolState message from topic ControlState.process_id b. If a CSV file is used read next line from it Calculate new state for the storage based on real power from control information and the duration of current epoch. Create a ResourceState message from the new state of the storage notably real power and state of charge percentage. If real power of storage state differs from control information add a warning.input.range warning to the message. This indicates that the storage could not operate according to the control power for example it was asked for too much energy. Publish the ResourceState message to topic ResourceState.Storage.(process_id). Publish status ready message.","title":"Epoch workflow"},{"location":"energy_storage/#implementation-details","text":"","title":"Implementation details"},{"location":"energy_storage/#language-and-platform","text":"Programming language Python Platform Python 3.7.6 Operating system Docker Debian 10 (python:3.7.6)","title":"Language and platform"},{"location":"energy_topic-priceforecaststate/","text":"PriceForecastState.(MarketId).(ResourceId) This topic uses subtopics to enable finer-grained message routing. The naming is as follows: PriceForecastState.(MarketId).(ResourceId) For a particular message, the ResourceId part MUST match the identifier of the related resource! This can be, e.g.: PriceForecastState.MyMarket.(ResourceId)","title":"PriceForecastState.(MarketId).(ResourceId)"},{"location":"energy_topic-priceforecaststate/#priceforecaststatemarketidresourceid","text":"This topic uses subtopics to enable finer-grained message routing. The naming is as follows: PriceForecastState.(MarketId).(ResourceId) For a particular message, the ResourceId part MUST match the identifier of the related resource! This can be, e.g.: PriceForecastState.MyMarket.(ResourceId)","title":"PriceForecastState.(MarketId).(ResourceId)"},{"location":"energy_topic-resourceforecaststate/","text":"ResourceForecastState.(ResourceCategory).(ResourceId) This topic uses subtopics to enable finer-grained message routing. The naming is as follows: ResourceForecastState.(ResourceCategory).(ResourceId) For example: ResourceForecastState.Generator.Generator1 Please note that subtopics do not prevent any component from receiving messages from all subtopics, as there can be wildcard subscriptions.","title":"ResourceForecastState.(ResourceCategory).(ResourceId)"},{"location":"energy_topic-resourceforecaststate/#resourceforecaststateresourcecategoryresourceid","text":"This topic uses subtopics to enable finer-grained message routing. The naming is as follows: ResourceForecastState.(ResourceCategory).(ResourceId) For example: ResourceForecastState.Generator.Generator1 Please note that subtopics do not prevent any component from receiving messages from all subtopics, as there can be wildcard subscriptions.","title":"ResourceForecastState.(ResourceCategory).(ResourceId)"},{"location":"energy_topic-resourcestate/","text":"ResourceState.(ResourceCategory).(ResourceId) This topic uses subtopics to enable finer-grained message routing. The naming is as follows: ResourceState.(ResourceCategory).(ResourceId) For a particular message, the ResourceId part MUST match SourceProcessId in the message! Example: ResourceState.Generator.Generator1 Please note that subtopics do not prevent any component from receiving messages from all subtopics, as there can be wildcard subscriptions.","title":"ResourceState.(ResourceCategory).(ResourceId)"},{"location":"energy_topic-resourcestate/#resourcestateresourcecategoryresourceid","text":"This topic uses subtopics to enable finer-grained message routing. The naming is as follows: ResourceState.(ResourceCategory).(ResourceId) For a particular message, the ResourceId part MUST match SourceProcessId in the message! Example: ResourceState.Generator.Generator1 Please note that subtopics do not prevent any component from receiving messages from all subtopics, as there can be wildcard subscriptions.","title":"ResourceState.(ResourceCategory).(ResourceId)"},{"location":"energy_topics/","text":"Topics (energy) The following table shows which message type occurs in each topic. Some topics have even a dedicated page for additional information. The table below is the primary source of topic-related information. If any other page conflicting topic information, this table has the precedence. In many cases, each message structure only occurs in one topic, but a message structure can be reusable between topics as well. For instance, several topics might deliver forecasts using an identical structure. However, in one topic, you likely expect only one message type. Topic (1) Message type Publisher(s); see (2) Subscriber(s); see (2) ControlState.PowerSetpoint ControlState.PowerSetpoint Controller Storage DMSNetworkState.Voltage DMSNetworkState.Voltage Distribution management system (DMS) - SM Distribution management system (DMS) - RTCM DMSNetworkState.Current DMSNetworkState.Current Distribution management system (DMS) - SM Distribution management system (DMS) - RTCM FlexibilityNeed.(MarketID) FlexibilityNeed Distribution management system (DMS) - PGO Procem-LFM Init.CIS.CustomerInfo Init.CIS.CustomerInfo Grid (DSS) Distribution management system (DMS) - PGO, SM Init.NIS.NetworkBusInfo Init.NIS.NetworkBusInfo Grid (DSS) Distribution management system (DMS) - PGO, SM Init.NIS.NetworkComponentInfo Init.NIS.NetworkComponentInfo Grid (DSS) Distribution management system (DMS) - PGO, SM LFMMarketResult.(MarketId) LFMMarketResult Procem-LFM Economic Dispatch LFMOffering.(PGOId) LFMOffering Procem-LFM Distribution management system (DMS) - PGO NetworkForecastState.(GridId).Voltage.(BusName) NetworkForecastState.Voltage Grid (DSS) Distribution management system (DMS) - PGO NetworkForecastState.(GridId).Current.(DeviceId) NetworkForecastState.Current Grid (DSS) Distribution management system (DMS) - PGO NetworkState.(GridId).Current.(DeviceId) NetworkState.Current Grid (DSS) Distribution management system (DMS) - SM NetworkState.(GridId).Voltage.(BusName) NetworkState.Voltage Grid (DSS) Distribution management system (DMS) - SM NetworkState.(GridId).Loss.(DeviceId) NetworkState.Loss Grid (DSS) Distribution management system (DMS) - SM Offer.(MarketID) Offer Economic Dispatch Procem-LFM Request.(MarketID) Request Procem-LFM Economic Dispatch ResourceForecastState.(ResourceCategory).(ResourceId) ResourceForecastState.Power ResourceForecaster Economic Dispatch ResourceForecastState.Dispatch ResourceForecastState.Dispatch Economic Dispatch Controller ResourceForecastState.(ResourceCategory).(ResourceId) ResourceState (Resources) Grid (DSS) SelectedOffer.(MarketID) SelectedOffer Distribution management system (DMS) - PGO Procem-LFM (1) Topic name: If the name starts with \"Init\", the purpose of the topic is initialization before the actual simulation cycles begin, once for each simulation run Otherwise, the purpose is the communication of result data (multiple times during a simulation run) (2) Abbreviations: PGO: Predictive Grid Optimization RTCM: Real-time Congestion Management SM: State Monitoring","title":"Topics (energy)"},{"location":"energy_topics/#topics-energy","text":"The following table shows which message type occurs in each topic. Some topics have even a dedicated page for additional information. The table below is the primary source of topic-related information. If any other page conflicting topic information, this table has the precedence. In many cases, each message structure only occurs in one topic, but a message structure can be reusable between topics as well. For instance, several topics might deliver forecasts using an identical structure. However, in one topic, you likely expect only one message type. Topic (1) Message type Publisher(s); see (2) Subscriber(s); see (2) ControlState.PowerSetpoint ControlState.PowerSetpoint Controller Storage DMSNetworkState.Voltage DMSNetworkState.Voltage Distribution management system (DMS) - SM Distribution management system (DMS) - RTCM DMSNetworkState.Current DMSNetworkState.Current Distribution management system (DMS) - SM Distribution management system (DMS) - RTCM FlexibilityNeed.(MarketID) FlexibilityNeed Distribution management system (DMS) - PGO Procem-LFM Init.CIS.CustomerInfo Init.CIS.CustomerInfo Grid (DSS) Distribution management system (DMS) - PGO, SM Init.NIS.NetworkBusInfo Init.NIS.NetworkBusInfo Grid (DSS) Distribution management system (DMS) - PGO, SM Init.NIS.NetworkComponentInfo Init.NIS.NetworkComponentInfo Grid (DSS) Distribution management system (DMS) - PGO, SM LFMMarketResult.(MarketId) LFMMarketResult Procem-LFM Economic Dispatch LFMOffering.(PGOId) LFMOffering Procem-LFM Distribution management system (DMS) - PGO NetworkForecastState.(GridId).Voltage.(BusName) NetworkForecastState.Voltage Grid (DSS) Distribution management system (DMS) - PGO NetworkForecastState.(GridId).Current.(DeviceId) NetworkForecastState.Current Grid (DSS) Distribution management system (DMS) - PGO NetworkState.(GridId).Current.(DeviceId) NetworkState.Current Grid (DSS) Distribution management system (DMS) - SM NetworkState.(GridId).Voltage.(BusName) NetworkState.Voltage Grid (DSS) Distribution management system (DMS) - SM NetworkState.(GridId).Loss.(DeviceId) NetworkState.Loss Grid (DSS) Distribution management system (DMS) - SM Offer.(MarketID) Offer Economic Dispatch Procem-LFM Request.(MarketID) Request Procem-LFM Economic Dispatch ResourceForecastState.(ResourceCategory).(ResourceId) ResourceForecastState.Power ResourceForecaster Economic Dispatch ResourceForecastState.Dispatch ResourceForecastState.Dispatch Economic Dispatch Controller ResourceForecastState.(ResourceCategory).(ResourceId) ResourceState (Resources) Grid (DSS) SelectedOffer.(MarketID) SelectedOffer Distribution management system (DMS) - PGO Procem-LFM (1) Topic name: If the name starts with \"Init\", the purpose of the topic is initialization before the actual simulation cycles begin, once for each simulation run Otherwise, the purpose is the communication of result data (multiple times during a simulation run) (2) Abbreviations: PGO: Predictive Grid Optimization RTCM: Real-time Congestion Management SM: State Monitoring","title":"Topics (energy)"},{"location":"maintenance-plan/","text":"Maintenance plan This document is a plan to maintain SimCES. Please note that because SimCES is open source, anyone can exploit it and even publish another version. Therefore, this document refers to the original SimCES developed by Tampere University and VTT Technical Research Centre of Finland. Still, PLEASE NOTE that each component of SimCES ships with a license that defines any exploitation-related conditions. Terminology \"Core\": any component or aspect of SimCES that is agnostic of any domain-specific simulations \"RP\": responsible person \"SimCES\": the simulation platform \"Simulation Environment of Complex Energy System\" Responsible persons The responsible persons (RP) are as follows (in alphabetical order): Person Email Amir Safdarian, VTT amir.safdarian@vtt.fi Antti Keski-Koukkari, VTT antti.keski-koukkari@vtt.fi Kari Syst\u00e4, Tampere University kari.systa@tuni.fi Petri Kannisto, Tampere University petri.kannisto@tuni.fi Sami Repo, Tampere University sami.repo@tuni.fi The group of RPs may change if the existing RPs find this appropriate. For instance, this should occur if a person moves to another employer or if SimCES is to be developed further in a new research project. Communication and coordination The primary communication medium between RPs and/or developers is email. Any error fixes as well as the development of new features are coordinated with this issue board: https://github.com/orgs/simcesplatform/projects/1 . Development of new features New core features are not expected at the time of writing (Sep 2021) because there are neither resources nor funding. This means that any new simulation components should comply with what the existing core supports.","title":"Maintenance plan"},{"location":"maintenance-plan/#maintenance-plan","text":"This document is a plan to maintain SimCES. Please note that because SimCES is open source, anyone can exploit it and even publish another version. Therefore, this document refers to the original SimCES developed by Tampere University and VTT Technical Research Centre of Finland. Still, PLEASE NOTE that each component of SimCES ships with a license that defines any exploitation-related conditions.","title":"Maintenance plan"},{"location":"maintenance-plan/#terminology","text":"\"Core\": any component or aspect of SimCES that is agnostic of any domain-specific simulations \"RP\": responsible person \"SimCES\": the simulation platform \"Simulation Environment of Complex Energy System\"","title":"Terminology"},{"location":"maintenance-plan/#responsible-persons","text":"The responsible persons (RP) are as follows (in alphabetical order): Person Email Amir Safdarian, VTT amir.safdarian@vtt.fi Antti Keski-Koukkari, VTT antti.keski-koukkari@vtt.fi Kari Syst\u00e4, Tampere University kari.systa@tuni.fi Petri Kannisto, Tampere University petri.kannisto@tuni.fi Sami Repo, Tampere University sami.repo@tuni.fi The group of RPs may change if the existing RPs find this appropriate. For instance, this should occur if a person moves to another employer or if SimCES is to be developed further in a new research project.","title":"Responsible persons"},{"location":"maintenance-plan/#communication-and-coordination","text":"The primary communication medium between RPs and/or developers is email. Any error fixes as well as the development of new features are coordinated with this issue board: https://github.com/orgs/simcesplatform/projects/1 .","title":"Communication and coordination"},{"location":"maintenance-plan/#development-of-new-features","text":"New core features are not expected at the time of writing (Sep 2021) because there are neither resources nor funding. This means that any new simulation components should comply with what the existing core supports.","title":"Development of new features"}]}